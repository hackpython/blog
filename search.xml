<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>实现满足WSGI协议的Web服务</title>
    <url>/blog/2019/11/18/%E5%AE%9E%E7%8E%B0%E6%BB%A1%E8%B6%B3WSGI%E5%8D%8F%E8%AE%AE%E7%9A%84Web%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>面试Python web相关岗位时，最容易被问到的问题，WSGI协议是什么？</p>
<p>这篇文章就简单解释一下WSGI并实现一个满足WSGI协议的服务。</p>
<a id="more"></a>
<h2 id="wsgi协议"><a class="markdownIt-Anchor" href="#wsgi协议"></a> WSGI协议</h2>
<p>WSGI(Python Web Server Gateway Interface, Python Web服务器网关接口)由PEP333提出，它是一种指定Web服务器与Python Web应用程序之间通信的一种标准，目的就是将Web服务器与Python Web应用解耦。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191026165621.png" alt="" /></p>
<p>我们熟悉的Django、Flask、Trondao等Python web框架其实都是满足WSGI协议的Web应用，而uWSGI、Gunicorn等都是满足WSGI协议的Web服务。</p>
<p>以部署Flask为例，常见的部署方法为Nginx+uWSGI+Flask，其中Nginx接受客户端的请求后，会将数据传递给uWSGI，uWSGI服务接受到数据后，会依据WSGI协议，将数据解析成相应的格式传递给Flask，Flask调用相应的逻辑后，同样依据WSGI协议将要方法的数据组织成相应的格式返回给uWSGI，uWSGI再次组织后，将其回传给Nginx。</p>
<h2 id="wsgi工作原理"><a class="markdownIt-Anchor" href="#wsgi工作原理"></a> WSGI工作原理</h2>
<p>从PEP333中可以看出，WSGI协议的主要目的就是规范数据解析格式，如果一个Web服务满足WSGI协议，那么它的作用就是将原始的socket数据解析为environ对象(使用时，就是一个字典对象)，environ数据包含Web服务自身的信息和请求的header与body等信息。当Web应用处理完后，可以通过start_response()方法进行回调，形象如下图：</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191026173123.png" alt="" /></p>
<p>整个过程比较清晰，不多赘述。</p>
<h2 id="实现一个满足wsgi协议的web服务"><a class="markdownIt-Anchor" href="#实现一个满足wsgi协议的web服务"></a> 实现一个满足WSGI协议的Web服务</h2>
<p>要纯手撸一个WSGI其实还要注意很多细节与规则，繁杂却没有特别大的技术难度，这里直接使用wsgiref内置库来实现满足WSGI协议的Web服务，wsgiref帮我们实现了socket数据解析的过程，从而可以直接获得envireon与start_response回调方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> wsgiref.simple_server <span class="keyword">import</span> make_server</span><br><span class="line"><span class="comment"># web应用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">web_app</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    start_response(<span class="string">'200 OK'</span>, [(<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>)])</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">b'&lt;h1&gt;Hello, HackPython!&lt;/h1&gt;'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># web服务</span></span><br><span class="line">    server = make_server(<span class="string">'127.0.0.1'</span>, <span class="number">8888</span>, web_app)</span><br><span class="line">    print(<span class="string">"Serving HTTP on port 8888..."</span>)</span><br><span class="line">    server.serve_forever()</span><br></pre></td></tr></table></figure>
<p>利用make_server()方法轻松构建了满足WSGI协议的web服务，运行后，通过浏览器访问则可。</p>
<p>make_server()背后究竟做了什么？简单阅读一下它的源码.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_server</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    host, port, app, server_class=WSGIServer, handler_class=WSGIRequestHandler</span></span></span><br><span class="line"><span class="function"><span class="params">)</span>:</span></span><br><span class="line">    <span class="string">"""Create a new WSGI server listening on `host` and `port` for `app`"""</span></span><br><span class="line">    server = server_class((host, port), handler_class)</span><br><span class="line">    server.set_app(app)</span><br><span class="line">    <span class="keyword">return</span> server</span><br></pre></td></tr></table></figure>
<p>发现关键是WSGIServer，而WSGIServer继承自HTTPServer，而HTTPServer继承自socketserver.TCPServer，TCPServer类主要就是处理TCP网络连接的逻辑，比如它激活服务的逻辑其实就是监听socket。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Lib/socketserver/TCPServer</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">server_activate</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Called by constructor to activate the server.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        May be overridden.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.socket.listen(self.request_queue_size)</span><br></pre></td></tr></table></figure>
<p>通过层层继承，到WSGIServer这一层，就完成了 Socket数据 --&gt; HTTP数据 --&gt; 符合WSGI协议数据格式 这样的过程，运行的本质就是启动socket监听进程，监听相应端口的网络请求。</p>
<p>除了通过方法形式，以类的方式也可以，通过<code>__call__</code>的形式去实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Web</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># init params</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line">        start_response(<span class="string">'200 OK'</span>, [(<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>)])</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">b'&lt;h1&gt;Hello, HackPython!&lt;/h1&gt;'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">listen</span><span class="params">(self,host=<span class="string">'127.0.0.1'</span>,port=<span class="number">8888</span>)</span>:</span></span><br><span class="line">        <span class="keyword">from</span> wsgiref.simple_server <span class="keyword">import</span> make_server</span><br><span class="line">        server = make_server(host, port, self)</span><br><span class="line">        print(<span class="string">f'serve on <span class="subst">&#123;host&#125;</span>:<span class="subst">&#123;port&#125;</span>'</span>)</span><br><span class="line">        server.serve_forever()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    web = Web()</span><br><span class="line">    web.listen()</span><br></pre></td></tr></table></figure>
<p>如果想深究WSGI协议的细节，可以阅读wsgiref的实现，这里不再深究。</p>
<h2 id="uwsgi与wsgi的关系"><a class="markdownIt-Anchor" href="#uwsgi与wsgi的关系"></a> uWSGI与WSGI的关系</h2>
<p>uWSGI是一个Web服务，它实现了WSGI协议，此外还实现了uwsgi协议与http协议。</p>
<p>需要区分一下WSGI、uWSGI与uwsgi三者的差别。</p>
<ul>
<li>WSGI是一种协议</li>
<li>uwsgi同样也是一种协议，与WSGI没有什么关系</li>
<li>uWSGI是Web服务，它实现了WSGI协议与uwsgi协议</li>
</ul>
<p>uwsgi协议是uWSGI特有的，它用于定义传输信息的类型，每个uwsgi包的前4字节都用于记录传输信息类型的描述。</p>
<p>那有了uWSGI这个web服务后，为什么还需要Nginx？</p>
<p>因为Nginx有优秀的静态内容处理能力，当客户端请求静态内容时，Nginx层直接返回，如果请求动态内容，Nginx才会转发给uWSGI，uWSGI才更加WSGI协议解析信息传递给Flask、Django这类Python Web应用。</p>
<h2 id="尾"><a class="markdownIt-Anchor" href="#尾"></a> 尾</h2>
<p>感谢大家阅读，后面将会写点自然语言处理方面的入门内容，来看一下Python究竟是怎么玩转语言的。</p>
<p>最后如果文字对你有帮助，麻烦点击「在看」，叩谢豪恩。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>不要等到使用「水滴筹」时才意识到风险控制</title>
    <url>/blog/2019/11/18/%E4%B8%8D%E8%A6%81%E7%AD%89%E5%88%B0%E4%BD%BF%E7%94%A8%E3%80%8C%E6%B0%B4%E6%BB%B4%E7%AD%B9%E3%80%8D%E6%97%B6%E6%89%8D%E6%84%8F%E8%AF%86%E5%88%B0%E9%A3%8E%E9%99%A9%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>时常在朋友圈看见好友们为人转发「水滴筹」，某某重病，很需要钱，我路过看见，是认识的人，都会小捐10~20块。</p>
<p>对重病来说，我这点钱形式意义大于实际意义，杯水车薪。</p>
<p>有时看见「水滴筹」会有点恍惚，自己父母也到了容易生各种病的年纪了，我是不是马上也要面临这样的问题了？</p>
<p>我是个爱面子的人，不到很困难的时候，是不会弄「水滴筹」求朋友转发集钱治病的，但谁不爱面子？现实就是，一场重病掏空普通中产家庭，这可能就是富人与中产之间最明显的差别，此时钱就是命。</p>
<p>实话说，我家没什么钱，我想象着自己父母重病，我能做什么？</p>
<p>那时我自己可能也成家了，父母重病，作为子女，我得拿出所有的钱给他们治病？那后面的房贷、小孩开销呢？而且钱也不都是我挣的，跟另一半该怎么说？</p>
<p>没有钱，自己的小家难以维持，不给钱治父母的病又不现实。</p>
<p>为了减少这种两难情况落到我头上的概率，我选择去了解商业保险。</p>
<p>注意，我不会给你推荐任何保险，只会说出我个人的看法感觉以及我与父母在保险这事上的博弈。</p>
<p>商业保险，给人的第一印象就是骗钱的。</p>
<p>无论跟父母说还是跟几个亲近的朋友讲，他们都会有这样的感觉，商业保险会给你设置很多细节，到你真的得病了，肯定会说你不满足这个条件不满足那个条件，最终不会给你赔钱。这玩意就是骗钱的。</p>
<p>面对这样的问题，我会简单的解释，商业保险是为了挣钱，我们买，只是买个不一定用的上的保障而已，主要的目的是减低自己未来生活所面对的风险。</p>
<p>这话说的很像一个保险推销人员。</p>
<p>对于朋友，我简单说一下，他们不听就罢了，但对于父母，他们就必须理解。</p>
<p>没错，我就TM想给保险公司赚这个钱，我不想以后你们得个重病，我挣扎都无法挣扎，所以我花钱，跟保险公司做对赌。</p>
<p>要说服对商业保险已有比较严重偏见的父母是很有难度的事情，母亲常跟我讲，我们已经买了200多的社保了，你给我和老爸买的保险就没必要了，那么贵。</p>
<p>此前，母亲在我面前说这话的频率并不高，直到她腰部出了问题，去住院后，想起我有这个保险，寻思着可以弄一下，省一笔钱，可结果是被拒保了。</p>
<p>原因其实也简单，因为这个病在投保前就存在了，所以你买的保险无法生效了。</p>
<p>但其实我在投保前，我母亲身体是很健康的，至少在电子病历上，问题出在治病时，母亲想要医生意识到自己的问题挺严重的，希望他认真的治一下，就特意说，腰痛了很久了，医生这样一记，电子病历就显示你这个病有很长时间了，而商业保险不会理会你主观倾诉，只看数据这些客观条件，它此时就会判断你在购买它之前已经患有这个病，是不能被报销的。</p>
<p>这事之后，父母愈发觉得这玩意骗钱，让我费了点脑子。最后使出大绝招，我的钱怎么花，花谁身上是我个人的事情，你们要做的就是提供个人信息配合一下我花钱，而且这个钱本质上来说不是为你们花的，是为我自己花的，避免你们生病了，我产生严重的财务危机。</p>
<p>此外，跟父母交流的一个技巧就是用他们熟悉的东西来举例子，比如我跟父亲说，你买那些乱七八糟的股票都知道要弄个对冲，买个车子，都要上这个保险那个保险，到最重要的身体上，你就觉得这个不行那个骗人，你觉得身体和股票车子这些哪个重要？</p>
<p>有这样的情况并不奇怪，我个人就是从怀疑商业保险被「洗脑」成相信商业保险的，想被「洗脑」？去看本专门讲保险的书就好了，了解其盈利原理，了解其大致种类，了解保险经纪人这个物种等等，大致的了解后，对商业保险妖魔化的感觉就会清淡很多。</p>
<p>但就算看完一些相关的书籍，我也不建议你自己去选保险，选择保险还是需要专业人士的，毕竟品种那么多，差异那么细。</p>
<p>另外一个误解就是觉得，商业保险我想买就能买。实话说，我想给我父亲上重疾已经没有较高性价比的产品给我选择了，最终只给他老人家上了百万医疗险，而我母亲年轻一些，可以选的产品比较多，我就将重疾和医疗险都上了。</p>
<p>总结而言，我买了一些保险，要连续交个10年左右，花个十几万，在这段时间，父母不幸患了病，如果满足保险要求，就有一定的缓冲。</p>
<p>你可能会问，那不满足呢？又花了保险钱，到头来还是要花那多钱治病？</p>
<p>如果这种最惨情况发生了，只能认。我对保险做的所有事情都是降低出现重大风险的概率，而无法杜绝它，我一直都明白，成年人的世界难有十全十美的方法，选个「较好的」就行了。</p>
<p>希望这篇文章可以让你思考一下保险，思考一下风险控制，我们现在也老大不小了，除了游戏外，是得掌握点其他东西了。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>利用pygame开发一款游戏:「跳跳兔」(完结篇)</title>
    <url>/blog/2019/11/18/%E5%88%A9%E7%94%A8pygame%E5%BC%80%E5%8F%91%E4%B8%80%E6%AC%BE%E6%B8%B8%E6%88%8F-%E3%80%8C%E8%B7%B3%E8%B7%B3%E5%85%94%E3%80%8D-%E5%AE%8C%E7%BB%93%E7%AF%87/</url>
    <content><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>通过前面九篇文章的编写，「跳跳兔」游戏基本已经被编写出来了，本节在此基础上进一步完善它，并添加上云彩背景。</p>
<h2 id="添加云彩背景"><a class="markdownIt-Anchor" href="#添加云彩背景"></a> 添加云彩背景</h2>
<p>添加云彩背景的大致步骤如下。</p>
<ul>
<li>1.编写云彩类</li>
<li>2.载入云彩图片</li>
<li>3.随机生成云彩</li>
<li>4.云彩同步移动</li>
</ul>
<p>一步步来编写，首先是创建云彩类，代码如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sprites.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cloud</span><span class="params">(pg.sprite.Sprite)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, game)</span>:</span></span><br><span class="line">        self._layer = CLOUD_LAYER</span><br><span class="line">        self.groups = game.all_sprites, game.clouds</span><br><span class="line">        pg.sprite.Sprite.__init__(self, self.groups)</span><br><span class="line">        self.game = game</span><br><span class="line">        self.image = random.choice(self.game.cloud_images)</span><br><span class="line">        self.image.set_colorkey(BLACK)</span><br><span class="line">        self.rect = self.image.get_rect()</span><br><span class="line">        <span class="comment"># 随机出现位置</span></span><br><span class="line">        scale = random.randrange(<span class="number">50</span>, <span class="number">101</span>) / <span class="number">100</span></span><br><span class="line">        self.image = pg.transform.scale(self.image, (int(self.rect.width * scale),</span><br><span class="line">                                                     int(self.rect.height * scale)))</span><br><span class="line">        self.rect.x = random.randrange(WIDTH - self.rect.width)</span><br><span class="line">        self.rect.y = random.randrange(<span class="number">-500</span>, <span class="number">-50</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 云朵大于2倍高度，就被消除</span></span><br><span class="line">        <span class="keyword">if</span> self.rect.top &gt; HEIGHT * <span class="number">2</span>:</span><br><span class="line">            self.kill()</span><br></pre></td></tr></table></figure>
<p>代码内容与此前内容非常类似，不再详细分析。</p>
<p>但你仔细观察，你会发现，Cloud类的__init__()方法中创建了 self._layer，并通过如下形式将其加入到相应的groups中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.groups = game.all_sprites, game.clouds</span><br><span class="line">pg.sprite.Sprite.__init__(self, self.groups)</span><br></pre></td></tr></table></figure>
<p>这是一个优化点，后文再讨论。</p>
<p>构建了Cloud类后，接着要做的就是载入图片、随机生成以及同步移动了，轻车熟路。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py/Game</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">(self)</span>:</span> <span class="comment"># 加载数据</span></span><br><span class="line">        <span class="comment"># ... 省略无关代码</span></span><br><span class="line">        <span class="comment"># 加载云彩图片</span></span><br><span class="line">        self.cloud_images = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">            self.cloud_images.append(pg.image.load(os.path.join(img_dir, <span class="string">'cloud&#123;&#125;.png'</span>.format(i))).convert())</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.score = <span class="number">0</span></span><br><span class="line">        <span class="comment"># ... 省略无关代码</span></span><br><span class="line">        <span class="comment"># 创建云彩</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">            c = Cloud(self)</span><br><span class="line">            c.rect.y += <span class="number">500</span></span><br><span class="line">        self.run()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">         <span class="comment"># 玩家到达游戏框 1/4 处时（注意，游戏框，头部为0，底部为游戏框长度，到到游戏框的1/4处，表示已经到达了顶部一部分了）</span></span><br><span class="line">        <span class="keyword">if</span> self.player.rect.top &lt;= HEIGHT / <span class="number">4</span>:</span><br><span class="line">            <span class="comment"># 玩家位置移动（往下移动）</span></span><br><span class="line">            self.player.pos.y += max(abs(self.player.vel.y), <span class="number">2</span>)</span><br><span class="line">            <span class="comment"># 随机生成新云朵</span></span><br><span class="line">            <span class="keyword">if</span> random.randrange(<span class="number">100</span>) &lt; <span class="number">10</span>:</span><br><span class="line">                Cloud(self)</span><br><span class="line">            <span class="comment"># 云彩同步移动</span></span><br><span class="line">            <span class="keyword">for</span> cloud <span class="keyword">in</span> self.clouds:</span><br><span class="line">                cloud.rect.y += max(abs(self.player.vel.y / <span class="number">2</span>), <span class="number">2</span>)</span><br><span class="line">            <span class="comment"># 敌人位置同步往下移动</span></span><br><span class="line">            <span class="keyword">for</span> mob <span class="keyword">in</span> self.mobs:</span><br><span class="line">                mob.rect.y += max(abs(self.player.vel.y), <span class="number">2</span>)</span><br><span class="line">            <span class="comment"># 平台在游戏框外时，将其注销，避免资源浪费</span></span><br><span class="line">            <span class="keyword">for</span> plat <span class="keyword">in</span> self.platforms:</span><br><span class="line">                <span class="comment"># 平台移动位置（往下移动，移动的距离与玩家相同，这样玩家才能依旧站立在原本的平台上）</span></span><br><span class="line">                plat.rect.y += max(abs(self.player.vel.y), <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">if</span> plat.rect.top &gt;= HEIGHT: </span><br><span class="line">                    plat.kill()</span><br><span class="line">                    <span class="comment"># 分数增加 - 平台销毁，分数相加</span></span><br><span class="line">                    self.score += <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>woo~，搞定，如果有疑惑，可以拉下github代码对照着看。</p>
<h2 id="优化"><a class="markdownIt-Anchor" href="#优化"></a> 优化</h2>
<p>云彩类添加完了，接着来进行一些优化。</p>
<p>首先，对碰撞检测的优化，如果你仔细观察，你会发现，玩家对象与敌人对象的本体还没有接触到，就触发了碰撞检测，游戏就结束了，造成这种现象的原因是，玩家也好、敌人也好，游戏中的任何元素都是一个对应大小的长方形，碰撞检测默认形式就是对这两个方块进行检测，此时两个元素本身可能没有接触，但对应的方块接触到了，所以触发了碰撞检测。</p>
<p>为了避免这种情况，可以利用pygame的蒙版机制mask，为Player、Mob都创建相应的蒙版，具体做法如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sprites.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span><span class="params">(pg.sprite.Sprite)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">animate</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># ... 省略无关代码</span></span><br><span class="line">        self.mask = pg.mask.from_surface(self.image) <span class="comment"># 创建蒙版</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mob</span><span class="params">(pg.sprite.Sprite)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># ... 省略无关代码</span></span><br><span class="line">        self.rect = self.image.get_rect()</span><br><span class="line">        self.mask = pg.mask.from_surface(self.image) <span class="comment"># 创建蒙版</span></span><br><span class="line">        self.rect.center = center</span><br><span class="line">        <span class="comment"># ... 省略无关代码</span></span><br></pre></td></tr></table></figure>
<p>检测时，加上pygame.sprite.collide_mask回调则可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># ... 省略无关代码</span></span><br><span class="line">        <span class="comment"># 碰撞检测 - 如果碰撞到了敌人，游戏结束</span></span><br><span class="line">        mob_hits = pg.sprite.spritecollide(self.player, self.mobs, <span class="literal">False</span>, pg.sprite.collide_mask)</span><br><span class="line">        <span class="keyword">if</span> mob_hits:</span><br><span class="line">            self.playing = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>此外还有个需要优化的问题，就是元素图层关系，增加云彩对象后，图层关系的问题显得明显，云彩作为背景却会遮挡玩家对象、敌人对象、平台对象等，这是不合理的，不同元素应该在不同图层，从而合理的显示出来。</p>
<p>首先定义好不同元素要出现的图层。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># settings.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同元素在不同层</span></span><br><span class="line">PLAYER_LAYER = <span class="number">2</span> <span class="comment"># 玩家</span></span><br><span class="line">PLATFORM_LAYER = <span class="number">1</span> <span class="comment"># 平台</span></span><br><span class="line">POW_LAYER = <span class="number">1</span> <span class="comment"># 道具</span></span><br><span class="line">MOB_LAYER = <span class="number">2</span> <span class="comment"># 敌人</span></span><br><span class="line">CLOUD_LAYER = <span class="number">0</span> <span class="comment"># 云</span></span><br></pre></td></tr></table></figure>
<p>然后为不同的元素对象都添加上设置图层的逻辑</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Sprite.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span><span class="params">(pg.sprite.Sprite)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, game)</span>:</span></span><br><span class="line">        self._layer = PLAYER_LAYER <span class="comment"># 对应的图层</span></span><br><span class="line">        self.groups = game.all_sprites <span class="comment"># 所在的组</span></span><br><span class="line">        pg.sprite.Sprite.__init__(self, self.groups) <span class="comment"># 添加、实例化</span></span><br><span class="line">        <span class="comment"># ... 省略无关代码</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Platform</span><span class="params">(pg.sprite.Sprite)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, game, x, y)</span>:</span></span><br><span class="line">        self._layer = PLATFORM_LAYER <span class="comment"># 对应的图层</span></span><br><span class="line">        self.groups = game.all_sprites, game.platforms <span class="comment"># 所在的组</span></span><br><span class="line">        pg.sprite.Sprite.__init__(self, self.groups) <span class="comment"># 添加、实例化</span></span><br><span class="line">        <span class="comment"># ... 省略无关代码</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pow</span><span class="params">(pg.sprite.Sprite)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, game, plat)</span>:</span></span><br><span class="line">        self._layer = POW_LAYER</span><br><span class="line">        self.groups = game.all_sprites, game.powerups</span><br><span class="line">        pg.sprite.Sprite.__init__(self, self.groups)</span><br><span class="line">        <span class="comment"># ... 省略无关代码</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mob</span><span class="params">(pg.sprite.Sprite)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, game)</span>:</span></span><br><span class="line">        self._layer = MOB_LAYER</span><br><span class="line">        self.groups = game.all_sprites, game.mobs</span><br><span class="line">        pg.sprite.Sprite.__init__(self, self.groups)</span><br><span class="line">        <span class="comment"># ... 省略无关代码</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cloud</span><span class="params">(pg.sprite.Sprite)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, game)</span>:</span></span><br><span class="line">        self._layer = CLOUD_LAYER</span><br><span class="line">        self.groups = game.all_sprites, game.clouds</span><br><span class="line">        pg.sprite.Sprite.__init__(self, self.groups)</span><br><span class="line">        <span class="comment"># ... 省略无关代码</span></span><br></pre></td></tr></table></figure>
<p>优化后，再修改一个Game类的new()方法，使用pygame.sprite.LayeredUpdates()来实例化all_sprites对象。</p>
<p>LayeredUpdates（分层更新）是一个精灵组，它可以处理图层并顺序绘制元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.score = <span class="number">0</span></span><br><span class="line">        <span class="comment"># self.all_sprites = pg.sprite.Group()</span></span><br><span class="line">        <span class="comment"># 层次添加，避免元素重叠显示(如背景云遮挡住平台与玩家)</span></span><br><span class="line">        self.all_sprites = pg.sprite.LayeredUpdates()</span><br><span class="line">        self.platforms = pg.sprite.Group()</span><br><span class="line">        self.powerups = pg.sprite.Group() <span class="comment"># 急速飞跃道具</span></span><br><span class="line">        self.mobs = pg.sprite.Group() <span class="comment"># 敌人对象</span></span><br><span class="line">        self.clouds = pg.sprite.Group() <span class="comment"># 云彩对象</span></span><br><span class="line">        self.player = Player(self)</span><br><span class="line">        self.all_sprites.add(self.player)</span><br><span class="line">        <span class="keyword">for</span> plat <span class="keyword">in</span> PLATFORM_LIST:</span><br><span class="line">            p = Platform(self, *plat)</span><br><span class="line">            <span class="comment"># self.all_sprites.add(p)</span></span><br><span class="line">            <span class="comment"># self.platforms.add(p)</span></span><br><span class="line">        self.mob_timer = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 游戏的背景音乐</span></span><br><span class="line">        pg.mixer.music.load(os.path.join(self.snd_dir, <span class="string">'Happy Tune.ogg'</span>))</span><br><span class="line">        <span class="comment"># 创建云彩</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">            c = Cloud(self)</span><br><span class="line">            c.rect.y += <span class="number">500</span></span><br><span class="line">        self.run()</span><br></pre></td></tr></table></figure>
<p>最终效果如下。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191115121354.png" alt="" /></p>
<h2 id="尾"><a class="markdownIt-Anchor" href="#尾"></a> 尾</h2>
<p>「跳跳兔」至此开发完啦，Pygame系列的文章也暂时告一段落啦。</p>
<p>「跳跳兔」代码github：<a href="https://github.com/ayuLiao/jumprabbit" target="_blank" rel="noopener">https://github.com/ayuLiao/jumprabbit</a></p>
<p>Pygame还有很多有趣的功能在「跳跳兔」游戏中并没有体现出来。</p>
<p>正如本系列第一篇文章所说，这些文章只是学习笔记，此外还有下面两个游戏的学习笔记，一个是打飞机、一个是RPG打僵尸游戏。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191115122050.png" alt="" /></p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191115122131.png" alt="" /></p>
<p>如果大家感兴趣，记得告诉我，我才有动力继续分享，后面按个人计划应该会以漫画形式分享算法、计算机基础方面的东西，希望喜欢。</p>
<p>最后，再次声明一下，学习内容来自：<a href="http://kidscancode.org/%EF%BC%8C%E6%B8%B8%E6%88%8F%E5%B9%B6%E4%B8%8D%E6%98%AF%E8%87%AA%E4%B8%BB%E5%8E%9F%E5%88%9B%E7%9A%84%E3%80%82" target="_blank" rel="noopener">http://kidscancode.org/，游戏并不是自主原创的。</a></p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>利用pygame开发一款游戏:「跳跳兔」(九)</title>
    <url>/blog/2019/11/18/%E5%88%A9%E7%94%A8pygame%E5%BC%80%E5%8F%91%E4%B8%80%E6%AC%BE%E6%B8%B8%E6%88%8F-%E3%80%8C%E8%B7%B3%E8%B7%B3%E5%85%94%E3%80%8D-%E4%B9%9D/</url>
    <content><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>在上一节中，我们对「跳跳兔」进行了简单的优化，然后为游戏中不同的状态添加不同的音乐。</p>
<p>这一节，为游戏添加道具与敌人，触碰到道具，玩家可以急速飞跃，触碰到敌人，玩家将会死亡，游戏结束</p>
<h2 id="添加道具"><a class="markdownIt-Anchor" href="#添加道具"></a> 添加道具</h2>
<p>先整理一下添加道具其整体思路。</p>
<ul>
<li>1.加载道具图片</li>
<li>2.加载触发道具时的音效</li>
<li>3.让道具随机出现到平台上</li>
<li>4.碰撞检测 - 触碰到道具后会有的效果</li>
</ul>
<p>想要的效果，道具随机出现在不同的平台上，玩家触碰到，会飞速向上飞跃。</p>
<p>一步步来实现。</p>
<p>首先构建一个新的类来表示这个道具。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sprites.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pow</span><span class="params">(pg.sprite.Sprite)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, game, plat)</span>:</span></span><br><span class="line">        self.groups = game.all_sprites, game.powerups</span><br><span class="line">        pg.sprite.Sprite.__init__(self, self.groups)</span><br><span class="line">        self.game = game <span class="comment"># 整个游戏对象</span></span><br><span class="line">        self.plat = plat <span class="comment"># 平台对象</span></span><br><span class="line">        self.type = random.choice([<span class="string">'boost'</span>])</span><br><span class="line">        <span class="comment"># 加载道具图片</span></span><br><span class="line">        self.image = self.game.spritesheet.get_image(<span class="number">820</span>, <span class="number">1805</span>, <span class="number">71</span>, <span class="number">70</span>)</span><br><span class="line">        self.image.set_colorkey(BLACK)</span><br><span class="line">        self.rect = self.image.get_rect()</span><br><span class="line">        <span class="comment"># 道具出现在平台中间的上方</span></span><br><span class="line">        self.rect.centerx = self.plat.rect.centerx</span><br><span class="line">        self.rect.bottom = self.plat.rect.top - <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>代码关键部分有相应的注释，不再详细分析。</p>
<p>然后在平台实例化时，随机实例化道具对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Platform</span><span class="params">(pg.sprite.Sprite)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, game, x, y)</span>:</span></span><br><span class="line">        <span class="comment">#... 省略无关代码</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 随机在平台上初始化道具</span></span><br><span class="line">        <span class="keyword">if</span> random.randrange(<span class="number">100</span>) &lt; POW_SPAWN_PCT:</span><br><span class="line">            Pow(self.game, self)</span><br></pre></td></tr></table></figure>
<p>这样，道具实例化就完成了。</p>
<p>接着添加音效。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">(self)</span>:</span> <span class="comment"># 加载数据</span></span><br><span class="line">        <span class="comment"># ... 省略无关代码</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 加载音乐</span></span><br><span class="line">        self.snd_dir = os.path.join(self.dir, <span class="string">'snd'</span>)</span><br><span class="line">        <span class="comment"># 跳跃时音效</span></span><br><span class="line">        self.jump_sound = pg.mixer.Sound(os.path.join(self.snd_dir, <span class="string">'Jump33.wav'</span>))</span><br><span class="line">        <span class="comment"># 使用道具时音效</span></span><br><span class="line">        self.boost_sound = pg.mixer.Sound(os.path.join(self.snd_dir, <span class="string">'Boost16.wav'</span>))</span><br></pre></td></tr></table></figure>
<p>至此，只剩道具碰撞检测逻辑未完成了。来搞一搞</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py/Game</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># ... 省略无关代码</span></span><br><span class="line">        <span class="comment"># 碰撞检测 - 玩家碰撞到急速飞跃道具</span></span><br><span class="line">        pow_hits = pg.sprite.spritecollide(self.player, self.powerups, <span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">for</span> pow <span class="keyword">in</span> pow_hits:</span><br><span class="line">            <span class="comment"># 道具类型 - 不同道具可以实现不同的效果</span></span><br><span class="line">            <span class="keyword">if</span> pow.type == <span class="string">'boost'</span>:</span><br><span class="line">                self.boost_sound.play() <span class="comment"># 播放相应的音效</span></span><br><span class="line">                self.player.vel.y = -BOOST_POWER <span class="comment"># 快递移动的距离</span></span><br><span class="line">                self.player.jumping = <span class="literal">False</span> <span class="comment"># 此时不为跳跃状态</span></span><br></pre></td></tr></table></figure>
<p>此时如果直接运行，会发现，玩家移动时，道具也会同步移动，原因是这部分代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py/Game</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 调用所有元素的update()方法</span></span><br><span class="line">        self.all_sprites.update()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># ... 省略无关代码</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 玩家到达游戏框 1/4 处时（注意，游戏框，头部为0，底部为游戏框长度，到到游戏框的1/4处，表示已经到达了顶部一部分了）</span></span><br><span class="line">        <span class="keyword">if</span> self.player.rect.top &lt;= HEIGHT / <span class="number">4</span>:</span><br><span class="line">            <span class="comment"># 玩家位置移动（往下移动）</span></span><br><span class="line">            self.player.pos.y += abs(self.player.vel.y)</span><br><span class="line">            <span class="comment"># 平台在游戏框外时，将其注销，避免资源浪费</span></span><br><span class="line">            <span class="keyword">for</span> plat <span class="keyword">in</span> self.platforms:</span><br><span class="line">                <span class="comment"># 平台移动位置（往下移动，移动的距离与玩家相同，这样玩家才能依旧站立在原本的平台上）</span></span><br><span class="line">                plat.rect.y += abs(self.player.vel.y)</span><br><span class="line">                <span class="keyword">if</span> plat.rect.top &gt;= HEIGHT: </span><br><span class="line">                    plat.kill()</span><br><span class="line">                    <span class="comment"># 分数增加 - 平台销毁，分数相加</span></span><br><span class="line">                    self.score += <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>此时为了避免道具同步移动，在Pow类中创建update()方法，实现如下逻辑。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 道具对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pow</span><span class="params">(pg.sprite.Sprite)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, game, plat)</span>:</span></span><br><span class="line">        <span class="comment"># ... 省略无关代码</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 更新时，避免道具一同移动</span></span><br><span class="line">        self.rect.bottom = self.plat.rect.top - <span class="number">5</span></span><br><span class="line">        <span class="comment"># 如果道具对应的平台已经被消除，那么道具也要被消除</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.game.platforms.has(self.plat):</span><br><span class="line">            self.kill() <span class="comment"># 消除道具</span></span><br></pre></td></tr></table></figure>
<p>最终效果如下。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191114112553.png" alt="" /></p>
<h2 id="添加敌人"><a class="markdownIt-Anchor" href="#添加敌人"></a> 添加敌人</h2>
<p>在实现前，依旧先整理一下实现的整体逻辑。</p>
<ul>
<li>1.构建敌人类</li>
<li>2.敌人移动效果</li>
<li>3.敌人随机出现效果</li>
<li>4.敌人碰撞检测</li>
<li>5.敌人不与跳跳兔同步移动</li>
</ul>
<p>首先来构建敌人类，代码如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sprites.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mob</span><span class="params">(pg.sprite.Sprite)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, game)</span>:</span></span><br><span class="line">        self.groups = game.all_sprites, game.mobs</span><br><span class="line">        pg.sprite.Sprite.__init__(self, self.groups)</span><br><span class="line">        self.game = game</span><br><span class="line">        <span class="comment"># 加载不同状态的图片</span></span><br><span class="line">        self.image_up = self.game.spritesheet.get_image(<span class="number">566</span>, <span class="number">510</span>, <span class="number">122</span>, <span class="number">139</span>)</span><br><span class="line">        self.image_up.set_colorkey(BLACK)</span><br><span class="line">        self.image_down = self.game.spritesheet.get_image(<span class="number">568</span>, <span class="number">1534</span>, <span class="number">122</span>, <span class="number">135</span>)</span><br><span class="line">        self.image_down.set_colorkey(BLACK)</span><br><span class="line">        self.image = self.image_up <span class="comment"># 默认为向上的图片</span></span><br><span class="line">        self.rect = self.image.get_rect()</span><br><span class="line">        <span class="comment"># x轴中心位置随机选择</span></span><br><span class="line">        self.rect.centerx = random.choice([<span class="number">-100</span>, WIDTH + <span class="number">100</span>])</span><br><span class="line">        <span class="comment"># 随机x轴速度</span></span><br><span class="line">        self.vx = random.randrange(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">if</span> self.rect.centerx &gt; WIDTH:</span><br><span class="line">            self.vx *= <span class="number">-1</span></span><br><span class="line">        <span class="comment"># 随机敌人y轴位置</span></span><br><span class="line">        self.rect.y = random.randrange(HEIGHT / <span class="number">2</span>)</span><br><span class="line">        self.vy = <span class="number">0</span> <span class="comment"># y轴速度默认为0</span></span><br><span class="line">        self.dy = <span class="number">0.5</span></span><br></pre></td></tr></table></figure>
<p>__init__()方法中，为敌人添加了不同状态的两种图片并随机敌人初始centerx、x轴速度与y轴位置。</p>
<p>接着实现敌人移动效果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sprites.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mob</span><span class="params">(pg.sprite.Sprite)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, game)</span>:</span></span><br><span class="line">        <span class="comment"># ... 省略</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.rect.x += self.vx <span class="comment"># x轴位置移动</span></span><br><span class="line">        self.vy += self.dy</span><br><span class="line">        <span class="comment"># 实现上下抖动移动的效果</span></span><br><span class="line">        <span class="keyword">if</span> self.vy &gt; <span class="number">3</span> <span class="keyword">or</span> self.vy &lt; <span class="number">-3</span>: </span><br><span class="line">            self.dy *= <span class="number">-1</span></span><br><span class="line">        center = self.rect.center</span><br><span class="line">        <span class="comment"># 上下移动方向不同，使用不同的图片</span></span><br><span class="line">        <span class="keyword">if</span> self.dy &lt; <span class="number">0</span>:</span><br><span class="line">            self.image = self.image_up</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.image = self.image_down</span><br><span class="line">        self.rect = self.image.get_rect()</span><br><span class="line">        self.rect.center = center</span><br><span class="line">        <span class="comment"># y轴具体的移动</span></span><br><span class="line">        self.rect.y += self.vy</span><br><span class="line">        <span class="comment"># 超过屏幕范围，删除敌人</span></span><br><span class="line">        <span class="keyword">if</span> self.rect.left &gt; WIDTH + <span class="number">100</span> <span class="keyword">or</span> self.rect.right &lt; <span class="number">-100</span>:</span><br><span class="line">            self.kill()</span><br></pre></td></tr></table></figure>
<p>看注释就可明白代码的含义，不再详细分析。</p>
<p>接着实现产生敌人与碰撞检测相关逻辑，代码如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py/Game</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.score = <span class="number">0</span></span><br><span class="line">        <span class="comment"># ... 省略无关代码</span></span><br><span class="line">        self.powerups = pg.sprite.Group() <span class="comment"># 急速飞跃道具</span></span><br><span class="line">        self.mobs = pg.sprite.Group() <span class="comment"># 敌人对象</span></span><br><span class="line">        <span class="comment"># ... 省略无关代码</span></span><br><span class="line">        self.mob_timer = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.all_sprites.update()</span><br><span class="line">        <span class="comment"># 产生敌人</span></span><br><span class="line">        now = pg.time.get_ticks()</span><br><span class="line">        <span class="comment"># 通过时间间隔来判断是否要产生敌人</span></span><br><span class="line">        <span class="keyword">if</span> now - self.mob_timer &gt; <span class="number">5000</span> + random.choice([<span class="number">-1000</span>, <span class="number">-500</span>, <span class="number">0</span>, <span class="number">500</span>, <span class="number">1000</span>]):</span><br><span class="line">            self.mob_timer = now</span><br><span class="line">            Mob(self)</span><br><span class="line">        <span class="comment"># 碰撞检测 - 如果碰撞到了敌人，游戏结束</span></span><br><span class="line">        mob_hits = pg.sprite.spritecollide(self.player, self.mobs, <span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">if</span> mob_hits:</span><br><span class="line">            self.playing = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>通过时间间隔的形式随机产生敌人，至于碰撞检测…一样的逻辑。</p>
<p>最后，为了避免敌人元素跟随跳跳兔一同移动，需要添加如下逻辑。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># 玩家到达游戏框 1/4 处时（注意，游戏框，头部为0，底部为游戏框长度，到到游戏框的1/4处，表示已经到达了顶部一部分了）</span></span><br><span class="line">    <span class="keyword">if</span> self.player.rect.top &lt;= HEIGHT / <span class="number">4</span>:</span><br><span class="line">        <span class="comment"># 玩家位置移动（往下移动）</span></span><br><span class="line">        self.player.pos.y += abs(self.player.vel.y)</span><br><span class="line">        <span class="comment"># 平台在游戏框外时，将其注销，避免资源浪费</span></span><br><span class="line">        <span class="keyword">for</span> plat <span class="keyword">in</span> self.platforms:</span><br><span class="line">            <span class="comment"># 平台移动位置（往下移动，移动的距离与玩家相同，这样玩家才能依旧站立在原本的平台上）</span></span><br><span class="line">            plat.rect.y += abs(self.player.vel.y)</span><br><span class="line">            <span class="keyword">if</span> plat.rect.top &gt;= HEIGHT: </span><br><span class="line">                plat.kill()</span><br><span class="line">                <span class="comment"># 分数增加 - 平台销毁，分数相加</span></span><br><span class="line">                self.score += <span class="number">10</span></span><br><span class="line">        <span class="comment"># 敌人位置同步往下移动</span></span><br><span class="line">        <span class="keyword">for</span> mob <span class="keyword">in</span> self.mobs:</span><br><span class="line">            mob.rect.y += max(abs(self.player.vel.y), <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>最终效果如下。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191114105226.png" alt="" /></p>
<h2 id="尾"><a class="markdownIt-Anchor" href="#尾"></a> 尾</h2>
<p>在本节中，我们对「跳跳兔」做了道具与敌人的添加，增加了「跳跳兔游戏的趣味性」。</p>
<p>因为考虑到篇幅，文中没有给出完整的代码，但为了方便大家理解，我将相应的代码上传到了github，图片资源与音乐资源也在github上。</p>
<p><a href="https://github.com/ayuLiao/jumprabbit" target="_blank" rel="noopener">https://github.com/ayuLiao/jumprabbit</a></p>
<p>如果文章对你有帮助或你觉得有点意思，点击「在看」支持作者一波。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>利用pygame开发一款游戏:「跳跳兔」(八)</title>
    <url>/blog/2019/11/18/%E5%88%A9%E7%94%A8pygame%E5%BC%80%E5%8F%91%E4%B8%80%E6%AC%BE%E6%B8%B8%E6%88%8F-%E3%80%8C%E8%B7%B3%E8%B7%B3%E5%85%94%E3%80%8D-%E5%85%AB/</url>
    <content><![CDATA[<p>处理私事，拖更许久，抱歉抱歉。</p>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>在第七节中，实现了玩家对象的动画效果以及平台的图片化。</p>
<p>本节将细节优化一下，然后加上相应的配音。</p>
<h2 id="细节优化"><a class="markdownIt-Anchor" href="#细节优化"></a> 细节优化</h2>
<p>如果你有仔细的试玩第七节实现的跳跳兔，会发现一些瑕疵，这里简单修改一下。</p>
<p>瑕疵1：跳跳兔会平移。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191113223629.png" alt="" /></p>
<p>造成该现象的代码如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py/Game</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.all_sprites.update()</span><br><span class="line">        <span class="comment"># # 玩家在界面中时(y&gt;0)，进行碰撞检测，检测玩家是否碰撞到平台</span></span><br><span class="line">        <span class="keyword">if</span> self.player.vel.y &gt; <span class="number">0</span>:</span><br><span class="line">            hits = pg.sprite.spritecollide(self.player, self.platforms, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 会产生平移效果</span></span><br><span class="line">            <span class="keyword">if</span> hits:</span><br><span class="line">                self.player.pos.y = hits[<span class="number">0</span>].rect.top</span><br><span class="line">                self.player.vel.y = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">...<span class="comment"># 省略其他无关代码</span></span><br></pre></td></tr></table></figure>
<p>在update()方法检查碰撞检测时，如果发生了碰撞，就直接将hits列表中第一个元素赋值给player玩家对象，从而造成了跳跳兔本身没有跳跃，只是碰到了平台周围，就瞬移到上一个平台的效果。</p>
<p>代码进行如下修改。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py/Game</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.all_sprites.update()</span><br><span class="line">        <span class="comment"># # 玩家在界面中时(y&gt;0)，进行碰撞检测，检测玩家是否碰撞到平台</span></span><br><span class="line">        <span class="keyword">if</span> self.player.vel.y &gt; <span class="number">0</span>:</span><br><span class="line">            hits = pg.sprite.spritecollide(self.player, self.platforms, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> hits:</span><br><span class="line">                lowest = hits[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">for</span> hit <span class="keyword">in</span> hits:</span><br><span class="line">                    <span class="keyword">if</span> hit.rect.bottom &gt; lowest.rect.bottom:</span><br><span class="line">                        lowest = hit <span class="comment"># 保存最小的值</span></span><br><span class="line">                    <span class="comment"># 避免平移效果 - 兔子最底部没有小于碰撞检测中的最小值，则不算跳跃到平台上</span></span><br><span class="line">                    <span class="keyword">if</span> self.player.pos.y &lt; lowest.rect.centery:</span><br><span class="line">                        self.player.pos.y = lowest.rect.top</span><br><span class="line">                        self.player.vel.y = <span class="number">0</span></span><br><span class="line">                        self.player.jumping = <span class="literal">False</span></span><br><span class="line">                        </span><br><span class="line">...<span class="comment"># 省略其他无关代码</span></span><br></pre></td></tr></table></figure>
<p>发送碰撞时，要进一步判断，先获得碰撞时，碰撞对象hit底部的最小值，然后判断此时玩家对象的位置y轴坐标是否要小于lowest对象的中心位置，如果小于，则说明玩家对象在lowest之上，此时才移动玩家对象。</p>
<p>瑕疵2：跳跃太高，可玩性低</p>
<p>简单点击空格，跳跳兔就可以跳很高，让游戏变得简单无趣，这里加多些逻辑，实现短跳与长跳。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sprites.py/Player</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 短跳</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump_cut</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.jumping:</span><br><span class="line">            <span class="keyword">if</span> self.vel.y &lt; <span class="number">-3</span>:</span><br><span class="line">                self.vel.y = <span class="number">-3</span></span><br><span class="line">                </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 跳跃到其他平台 - 玩家对象x加减1，为了做碰撞检测，只有站立在平台上，才能实现跳跃</span></span><br><span class="line">        self.rect.y += <span class="number">2</span></span><br><span class="line">        hits = pg.sprite.spritecollide(self, self.game.platforms, <span class="literal">False</span>)</span><br><span class="line">        self.rect.y -= <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> hits <span class="keyword">and</span> <span class="keyword">not</span> self.jumping:</span><br><span class="line">            self.jumping = <span class="literal">True</span></span><br><span class="line">            self.vel.y = <span class="number">-20</span></span><br></pre></td></tr></table></figure>
<p>通过self.jumping判断当前是否在跳跃状态，如果在跳跃状态，就将y轴速度砍到3。此外jump()方法也做了修改，通过y轴来判断是否产生碰撞检测，如果发生了碰撞而且又是没有跳跃的状态，这说明跳跳兔在平台上，可以进行跳跃，将self.jumping跳跃标志设为True。</p>
<p>你可能会疑惑，不慌，结合下面代码一起看。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py/Game</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 事件处理</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">events</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> event <span class="keyword">in</span> pg.event.get():</span><br><span class="line">            <span class="comment"># 关闭</span></span><br><span class="line">            <span class="keyword">if</span> event.type == pg.QUIT:</span><br><span class="line">                <span class="keyword">if</span> self.playing:</span><br><span class="line">                    self.playing = <span class="literal">False</span></span><br><span class="line">                self.running = <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 跳跃</span></span><br><span class="line">            <span class="keyword">if</span> event.type == pg.KEYDOWN:</span><br><span class="line">                <span class="keyword">if</span> event.key == pg.K_SPACE:</span><br><span class="line">                    self.player.jump()</span><br><span class="line">            <span class="comment"># 按钮抬起，减小跳跃速度，从而实现，快速点击，短跳，长按，长跳的效果</span></span><br><span class="line">            <span class="keyword">if</span> event.type == pg.KEYUP:</span><br><span class="line">                <span class="keyword">if</span> event.key == pg.K_SPACE:</span><br><span class="line">                    self.player.jump_cut()</span><br></pre></td></tr></table></figure>
<p>简单而言，如果长按空格键进行跳跃，就只会有jump()方法的效果，跳跃快结束时，才松开空格，此时jump_cut()方法已经没有明显的作用了。</p>
<p>如果简单快击空格键，此时跳跃还未完成，jump_cut()又被调用，跳跳兔y轴速度会被减弱，从而实现短跳的效果。</p>
<h2 id="增加背景音乐"><a class="markdownIt-Anchor" href="#增加背景音乐"></a> 增加背景音乐</h2>
<p>在pygame中，操作音乐是非常简单的，无论多大的音乐文件都可以被pygame以流的形式读入并播放。</p>
<p>跳跳兔游戏在不同的状态要播放不同状态的音乐。</p>
<p>在Game/load_data()方法中加载音频文件夹。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py/Game</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">(self)</span>:</span> <span class="comment"># 加载数据</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># 加载精灵图片</span></span><br><span class="line">        self.spritesheet = Spritesheet(os.path.join(img_dir, SPRITESHEET))</span><br><span class="line">        <span class="comment"># 加载音乐</span></span><br><span class="line">        self.snd_dir = os.path.join(self.dir, <span class="string">'snd'</span>)</span><br><span class="line">        self.jump_sound = pg.mixer.Sound(os.path.join(self.snd_dir, <span class="string">'Jump33.wav'</span>)) <span class="comment"># 玩家对象跳跃时的音乐</span></span><br></pre></td></tr></table></figure>
<p>新建游戏时，加载游戏初始音乐，此外游戏结束时，也使用同样的音乐，逻辑如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py/Game</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始游戏的钩子函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_start_screen</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 加载音乐</span></span><br><span class="line">        pg.mixer.music.load(os.path.join(self.snd_dir, <span class="string">'Yippee.ogg'</span>))</span><br><span class="line">        <span class="comment"># 重复播放</span></span><br><span class="line">        pg.mixer.music.play(loops=<span class="number">-1</span>)</span><br><span class="line">        ... <span class="comment"># 其他逻辑，省略</span></span><br><span class="line">        <span class="comment"># 退出音乐</span></span><br><span class="line">        pg.mixer.music.fadeout(<span class="number">500</span>)</span><br></pre></td></tr></table></figure>
<p>通过pygame.mixer.music.load()方法可以将音乐加载到磁盘中，然后调用play()方法播放，其中loops参数用于指定循环播放次数，-1表示一直循环播放，当需要退出音乐时，滴啊用fadeout()方法，退出音乐，fadeout(time)设置音乐淡出的时间，该方法会阻塞到音乐消失。</p>
<p>游戏结束方法逻辑与show_start_screen()一致，不再展示代码分析。</p>
<p>游戏的过程中以同样的方式加载音乐作为游戏的背景音乐</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">(self)</span>:</span></span><br><span class="line">       ...</span><br><span class="line">        <span class="comment"># 游戏初始时音乐</span></span><br><span class="line">        pg.mixer.music.load(os.path.join(self.snd_dir, <span class="string">'Happy Tune.ogg'</span>))</span><br><span class="line">        self.run()</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># loops表示循环次数，-1表示音乐将无限播放下去</span></span><br><span class="line">        pg.mixer.music.play(loops=<span class="number">-1</span>)</span><br><span class="line">        self.playing = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> self.playing:</span><br><span class="line">            self.clock.tick(FPS)</span><br><span class="line">            self.events()</span><br><span class="line">            self.update()</span><br><span class="line">            self.draw()</span><br><span class="line">        <span class="comment"># 退出后停止音乐，fadeout(time)设置音乐淡出的时间，该方法会阻塞到音乐消失</span></span><br><span class="line">        pg.mixer.music.fadeout(<span class="number">500</span>)</span><br></pre></td></tr></table></figure>
<p>最后，为跳跃动作加上相应的音乐。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sprites.py/Player</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 跳跃到其他平台 - 玩家对象x加减1，为了做碰撞检测，只有站立在平台上，才能实现跳跃</span></span><br><span class="line">        self.rect.y += <span class="number">2</span></span><br><span class="line">        hits = pg.sprite.spritecollide(self, self.game.platforms, <span class="literal">False</span>)</span><br><span class="line">        self.rect.y -= <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> hits <span class="keyword">and</span> <span class="keyword">not</span> self.jumping:</span><br><span class="line">            self.game.jump_sound.play() <span class="comment"># 播放跳跃的声音</span></span><br><span class="line">            self.jumping = <span class="literal">True</span></span><br><span class="line">            self.vel.y = <span class="number">-20</span></span><br></pre></td></tr></table></figure>
<h2 id="尾"><a class="markdownIt-Anchor" href="#尾"></a> 尾</h2>
<p>在本节中，我们对「跳跳兔」进行了简单的优化，然后为游戏中不同的状态添加不同的音乐。</p>
<p>因为考虑到篇幅，文中没有给出完整的代码，但为了方便大家理解，我将相应的代码上传到了github，图片资源与音乐资源也在github上。</p>
<p><a href="https://github.com/ayuLiao/jumprabbit" target="_blank" rel="noopener">https://github.com/ayuLiao/jumprabbit</a></p>
<p>如果文章对你有帮助或你觉得有点意思，点击「在看」支持作者一波。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>利用pygame开发一款游戏:「跳跳兔」(七)</title>
    <url>/blog/2019/11/18/%E5%88%A9%E7%94%A8pygame%E5%BC%80%E5%8F%91%E4%B8%80%E6%AC%BE%E6%B8%B8%E6%88%8F-%E3%80%8C%E8%B7%B3%E8%B7%B3%E5%85%94%E3%80%8D-%E4%B8%83/</url>
    <content><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>在第6节内容中，实现了游戏结束逻辑与玩家图片化，但跳跳兔只是一张简单的图片，显得比较呆板，本节会为跳跳兔添加上相应的动画效果，并将平台替换成相应的图片。</p>
<h2 id="添加动画"><a class="markdownIt-Anchor" href="#添加动画"></a> 添加动画</h2>
<p>跳跳兔在站立时，希望有上下蹲的动画，在走动时，希望有左右走动的动画，在跳跃时，希望有跳跃动画。</p>
<p>动画的本质就是不同图片间的切换，在pygame中要实现动画，只需要在不同帧使用不同的图片则可。</p>
<p>在Player的__init__()方法中定义多个变量用于记录不同的状态，代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sprites.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span><span class="params">(pg.sprite.Sprite)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, game)</span>:</span></span><br><span class="line">        pg.sprite.Sprite.__init__(self)</span><br><span class="line">        self.game = game</span><br><span class="line">        <span class="comment"># 不同的状态</span></span><br><span class="line">        self.walking = <span class="literal">False</span></span><br><span class="line">        self.jumping = <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 当前帧(用于判断当前要执行哪个动画)</span></span><br><span class="line">        self.current_frame = <span class="number">0</span></span><br><span class="line">        self.last_update = <span class="number">0</span></span><br><span class="line">        self.load_images() <span class="comment"># 加载图片</span></span><br><span class="line">        self.image = self.standing_frames[<span class="number">0</span>]</span><br><span class="line">        self.rect = self.image.get_rect()</span><br><span class="line">        self.rect.center = (WIDTH / <span class="number">2</span>, HEIGHT / <span class="number">2</span>)</span><br><span class="line">        self.pos = vec(WIDTH / <span class="number">2</span>, HEIGHT / <span class="number">2</span>)</span><br><span class="line">        self.vel = vec(<span class="number">0</span>, <span class="number">0</span>) <span class="comment"># 速度</span></span><br><span class="line">        self.acc = vec(<span class="number">0</span>, <span class="number">0</span>) <span class="comment"># 加速度</span></span><br></pre></td></tr></table></figure>
<p>在__init__()方法中，定义了self.walking与self.jumping状态，用于表示玩家对象是在行走状态还是跳跃状态，接着定义了self.current_frame用于表示当前帧，定义了self.last_update用于记录上一次的时间点，随后，编调用了load_images()方法来载入图片，该方法代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sprites.py/Player</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_images</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 站立状态</span></span><br><span class="line">        self.standing_frames = [self.game.spritesheet.get_image(<span class="number">614</span>, <span class="number">1063</span>, <span class="number">120</span>, <span class="number">191</span>),</span><br><span class="line">                                self.game.spritesheet.get_image(<span class="number">690</span>, <span class="number">406</span>, <span class="number">120</span>, <span class="number">201</span>)]</span><br><span class="line">        <span class="keyword">for</span> frame <span class="keyword">in</span> self.standing_frames:</span><br><span class="line">            frame.set_colorkey(BLACK) <span class="comment"># 将图像矩阵中除图像外周围的元素都设置为透明的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 走动状态</span></span><br><span class="line">        self.walk_frames_r = [self.game.spritesheet.get_image(<span class="number">678</span>, <span class="number">860</span>, <span class="number">120</span>, <span class="number">201</span>),</span><br><span class="line">                              self.game.spritesheet.get_image(<span class="number">692</span>, <span class="number">1458</span>, <span class="number">120</span>, <span class="number">207</span>)]</span><br><span class="line">        self.walk_frames_l = []</span><br><span class="line">        <span class="keyword">for</span> frame <span class="keyword">in</span> self.walk_frames_r:</span><br><span class="line">            frame.set_colorkey(BLACK)</span><br><span class="line">            <span class="comment"># 水平翻转</span></span><br><span class="line">            self.walk_frames_l.append(pg.transform.flip(frame, <span class="literal">True</span>, <span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 跳跃状态</span></span><br><span class="line">        self.jump_frame = self.game.spritesheet.get_image(<span class="number">382</span>, <span class="number">763</span>, <span class="number">150</span>, <span class="number">181</span>)</span><br><span class="line">        self.jump_frame.set_colorkey(BLACK)</span><br></pre></td></tr></table></figure>
<p>在load_images()方法中，为不同的状态载入了不同的图片，其中，走动状态的图片还做了水平翻转处理，这是因为原始的大图中，走动的图片只有一个方向的，而走动可以往左走也可以往右走，所以需要将图片水平翻转一下。</p>
<p>调用pygame.transform.flip(Surface, xbool, ybool)用于翻转，xbool =&gt; True 为水平翻转，ybool =&gt; True 为垂直翻转。</p>
<p>图片准备好后，动画效果的基本素材就准备好了，在Player类的update()方法中调用动画方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sprites.py/Player</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># 动画</span></span><br><span class="line">    self.animate()</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">animate</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 获得当前过了多少毫秒</span></span><br><span class="line">        now = pg.time.get_ticks()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.vel.x != <span class="number">0</span>: <span class="comment"># 判断速度在x轴方向是否为0，从而判断玩家对象是否移动</span></span><br><span class="line">            self.walking = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.walking = <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 走动状态下的动画</span></span><br><span class="line">        <span class="keyword">if</span> self.walking:</span><br><span class="line">            <span class="comment"># 当前时间 - 上次时间 大于 180，即间隔时间大于180时</span></span><br><span class="line">            <span class="keyword">if</span> now - self.last_update &gt; <span class="number">180</span>:</span><br><span class="line">                self.last_update = now</span><br><span class="line">                <span class="comment"># 当前帧 加一 与 walk_frames_l 长度取余，从而得到当前要做哪个东西</span></span><br><span class="line">                self.current_frame = (self.current_frame + <span class="number">1</span>) % len(self.walk_frames_l)</span><br><span class="line">                bottom = self.rect.bottom</span><br><span class="line">                <span class="comment"># 向左走还是向右走</span></span><br><span class="line">                <span class="keyword">if</span> self.vel.x &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 当前帧要做的动作</span></span><br><span class="line">                    self.image = self.walk_frames_r[self.current_frame]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.image = self.walk_frames_l[self.current_frame]</span><br><span class="line">                self.rect = self.image.get_rect()</span><br><span class="line">                self.rect.bottom = bottom</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 站立状态下的动画</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.jumping <span class="keyword">and</span> <span class="keyword">not</span> self.walking:</span><br><span class="line">            <span class="keyword">if</span> now - self.last_update &gt; <span class="number">350</span>:</span><br><span class="line">                self.last_update = now</span><br><span class="line">                self.current_frame = (self.current_frame + <span class="number">1</span>) % len(self.standing_frames)</span><br><span class="line">                bottom = self.rect.bottom</span><br><span class="line">                self.image = self.standing_frames[self.current_frame]</span><br><span class="line">                self.rect = self.image.get_rect()</span><br><span class="line">                self.rect.bottom = bottom</span><br></pre></td></tr></table></figure>
<p>在pygame 中的时间是以毫秒（千分之一秒）表示的，通过 pygame.time.get_ticks 函数可以获得 pygame.init 后经过的时间的毫秒数。</p>
<p>随后的逻辑通过注释可以比较简单的理解。判断当前时间与上一层记录时间的间隔，如果满足条件，则只需图片的切换逻辑，注意，时间都是毫秒级的。</p>
<p>切换图片的核心逻辑就是当前帧与图片列表长度取余，获得下标，通过下标去取列表中的图片。</p>
<p>走动时效果如下：</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191108181503.png" alt="" /></p>
<p>有个细节需要注意，在判断玩家对象是否是走动状态时，利用了速度变量的x轴是否为0来判断</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> self.vel.x != <span class="number">0</span>: <span class="comment"># 判断速度在x轴方向是否为0，从而判断玩家对象是否移动</span></span><br><span class="line">    self.walking = <span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    self.walking = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>但self.vel.x通常不会为0，所以需要处理一下，修改一下update()方法中的逻辑，代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># 动画</span></span><br><span class="line">    self.animate()</span><br><span class="line">    self.acc = vec(<span class="number">0</span>, PLAYER_GRAV)</span><br><span class="line">    keys = pg.key.get_pressed()</span><br><span class="line">    <span class="keyword">if</span> keys[pg.K_LEFT]:</span><br><span class="line">        self.acc.x = -PLAYER_ACC</span><br><span class="line">    <span class="keyword">if</span> keys[pg.K_RIGHT]:</span><br><span class="line">        self.acc.x = PLAYER_ACC</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获得加速度</span></span><br><span class="line">    self.acc.x += self.vel.x * PLAYER_FRICTION</span><br><span class="line">    <span class="comment"># 速度与加速度</span></span><br><span class="line">    self.vel += self.acc</span><br><span class="line">    <span class="comment"># 如果速度小于0.1，则速度为0（比如这样设置，不然速度永远无法0）</span></span><br><span class="line">    <span class="keyword">if</span> abs(self.vel.x) &lt; <span class="number">0.1</span>:</span><br><span class="line">        self.vel.x = <span class="number">0</span></span><br><span class="line">    self.pos += self.vel + <span class="number">0.5</span> * self.acc</span><br><span class="line">    <span class="comment"># wrap around the sides of the screen</span></span><br><span class="line">    <span class="keyword">if</span> self.pos.x &gt; WIDTH:</span><br><span class="line">        self.pos.x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> self.pos.x &lt; <span class="number">0</span>:</span><br><span class="line">        self.pos.x = WIDTH</span><br><span class="line"></span><br><span class="line">    self.rect.midbottom = self.pos</span><br></pre></td></tr></table></figure>
<p>如果self.vel.x的绝对值小于0.1，则让self.vel.x为0。</p>
<h2 id="平台图片化"><a class="markdownIt-Anchor" href="#平台图片化"></a> 平台图片化</h2>
<p>跳跳兔要跳跃到相应的平台上，现在平依旧是方块，这里以相同的方式将平台替换成相应的图片。</p>
<p>在Platform的__init__()中，实现载入图片的逻辑，代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Platform</span><span class="params">(pg.sprite.Sprite)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, game, x, y)</span>:</span></span><br><span class="line">        pg.sprite.Sprite.__init__(self)</span><br><span class="line">        self.game = game</span><br><span class="line">        <span class="comment"># 载入图片</span></span><br><span class="line">        images = [self.game.spritesheet.get_image(<span class="number">0</span>, <span class="number">288</span>, <span class="number">380</span>, <span class="number">94</span>),</span><br><span class="line">                  self.game.spritesheet.get_image(<span class="number">213</span>, <span class="number">1662</span>, <span class="number">201</span>, <span class="number">100</span>)]</span><br><span class="line">        <span class="comment"># 随机选择一种</span></span><br><span class="line">        self.image = random.choice(images)</span><br><span class="line">        self.image.set_colorkey(BLACK)</span><br><span class="line">        self.rect = self.image.get_rect()</span><br><span class="line">        self.rect.x = x</span><br><span class="line">        self.rect.y = y</span><br></pre></td></tr></table></figure>
<p>载入完图片，随机选择一个图片作为样式，需要注意，我们修改了__init__()的参数，此时该方法只需要获得(x,y)坐标以及game实例则可。</p>
<p>因为__init__()被修改了，所以实例化逻辑也要修改一下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#setting.py</span></span><br><span class="line"><span class="comment"># 起始平台</span></span><br><span class="line">PLATFORM_LIST = [(<span class="number">0</span>, HEIGHT - <span class="number">60</span>),</span><br><span class="line">                 (WIDTH / <span class="number">2</span> - <span class="number">50</span>, HEIGHT * <span class="number">3</span> / <span class="number">4</span> - <span class="number">50</span>),</span><br><span class="line">                 (<span class="number">125</span>, HEIGHT - <span class="number">350</span>),</span><br><span class="line">                 (<span class="number">350</span>, <span class="number">200</span>),</span><br><span class="line">                 (<span class="number">175</span>, <span class="number">100</span>)]</span><br><span class="line">                 </span><br><span class="line"><span class="comment"># main.py/Game</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.score = <span class="number">0</span></span><br><span class="line">    self.all_sprites = pg.sprite.Group()</span><br><span class="line">    self.platforms = pg.sprite.Group()</span><br><span class="line">    self.player = Player(self)</span><br><span class="line">    self.all_sprites.add(self.player)</span><br><span class="line">    <span class="keyword">for</span> plat <span class="keyword">in</span> PLATFORM_LIST:</span><br><span class="line">     p = Platform(self, *plat)</span><br><span class="line">     self.all_sprites.add(p)</span><br><span class="line">     self.platforms.add(p)</span><br><span class="line">    self.run()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="comment"># 判断平台数，产生新的平台</span></span><br><span class="line">    <span class="keyword">while</span> len(self.platforms) &lt; <span class="number">6</span>:</span><br><span class="line">        width = random.randrange(<span class="number">50</span>, <span class="number">100</span>)</span><br><span class="line">        <span class="comment"># 平台虽然是随机生成的，但会生成在某一个范围内</span></span><br><span class="line">        p = Platform(self, random.randrange(<span class="number">0</span>, WIDTH - width),</span><br><span class="line">                  random.randrange(<span class="number">-75</span>, <span class="number">-30</span>))</span><br><span class="line">        self.platforms.add(p)</span><br><span class="line">        self.all_sprites.add(p)</span><br></pre></td></tr></table></figure>
<p>最终效果如下</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191108183414.png" alt="" /></p>
<h2 id="尾"><a class="markdownIt-Anchor" href="#尾"></a> 尾</h2>
<p>在本节中，我们实现了玩家对象的动画效果以及平台的图片化。</p>
<p>因为考虑到篇幅，文中没有给出完整的代码，但为了方便大家理解，我将相应的代码上传到了github</p>
<p><a href="https://github.com/ayuLiao/jumprabbit" target="_blank" rel="noopener">https://github.com/ayuLiao/jumprabbit</a></p>
<p>如果文章对你有帮助或你觉得有点意思，点击「在看」支持作者一波。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>利用pygame开发一款游戏:「跳跳兔」(六)</title>
    <url>/blog/2019/11/18/%E5%88%A9%E7%94%A8pygame%E5%BC%80%E5%8F%91%E4%B8%80%E6%AC%BE%E6%B8%B8%E6%88%8F-%E3%80%8C%E8%B7%B3%E8%B7%B3%E5%85%94%E3%80%8D-%E5%85%AD/</url>
    <content><![CDATA[<p>HackPython改名为「懒编程」，纯粹是因为我有另外一个写杂文的号叫「懒写作」，此外，感觉「懒编程」比HackPython好记。</p>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>在第5节内容中，实现了积分机制、玩家死亡逻辑以及游戏开始界面逻辑，本节继续完善游戏，来实现游戏结束逻辑与玩家图片化，不再使用方块。</p>
<h2 id="游戏结束逻辑"><a class="markdownIt-Anchor" href="#游戏结束逻辑"></a> 游戏结束逻辑</h2>
<p>回忆一下整体逻辑：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = Game()</span><br><span class="line">g.show_start_screen()</span><br><span class="line"><span class="keyword">while</span> g.running:</span><br><span class="line">    g.new()</span><br><span class="line">    g.show_go_screen()</span><br><span class="line"></span><br><span class="line">pg.quit()</span><br></pre></td></tr></table></figure>
<p>可以通过show_go_screen()方法实现游戏结束逻辑，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py/Game</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每轮游戏结束后，都会调用该方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_go_screen</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># game over/continue</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.running: <span class="comment"># 是否在运行</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.screen.fill(BGCOLOR) <span class="comment"># 游戏框背景颜色填充</span></span><br><span class="line">        <span class="comment"># 绘制文字</span></span><br><span class="line">        self.draw_text(<span class="string">"GAME OVER"</span>, <span class="number">48</span>, WHITE, WIDTH / <span class="number">2</span>, HEIGHT / <span class="number">4</span>)</span><br><span class="line">        self.draw_text(<span class="string">"Score: "</span> + str(self.score), <span class="number">22</span>, WHITE, WIDTH / <span class="number">2</span>, HEIGHT / <span class="number">2</span>)</span><br><span class="line">        self.draw_text(<span class="string">"Press a key to play again"</span>, <span class="number">22</span>, WHITE, WIDTH / <span class="number">2</span>, HEIGHT * <span class="number">3</span> / <span class="number">4</span>)</span><br><span class="line">        <span class="comment"># 判断分数</span></span><br><span class="line">        <span class="keyword">if</span> self.score &gt; self.highscore:</span><br><span class="line">            self.highscore = self.score</span><br><span class="line">            self.draw_text(<span class="string">"NEW HIGH SCORE!"</span>, <span class="number">22</span>, WHITE, WIDTH / <span class="number">2</span>, HEIGHT / <span class="number">2</span> + <span class="number">40</span>)</span><br><span class="line">            <span class="comment"># 记录新的最高分到文件中 - 持久化</span></span><br><span class="line">            <span class="keyword">with</span> open(os.path.join(self.dir, HS_FILE), <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(str(self.score))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.draw_text(<span class="string">"High Score: "</span> + str(self.highscore), <span class="number">22</span>, WHITE, WIDTH / <span class="number">2</span>, HEIGHT / <span class="number">2</span> + <span class="number">40</span>)</span><br><span class="line">        <span class="comment"># 翻转</span></span><br><span class="line">        pg.display.flip()</span><br><span class="line">        <span class="comment"># 等待敲击任意键，重新开始新的一轮游戏</span></span><br><span class="line">        self.wait_for_key()</span><br></pre></td></tr></table></figure>
<p>show_go_screen()方法逻辑可以阅读详细的注释，不再赘述。</p>
<p>show_go_screen()通过文件的方式来记录最高的分数，所以在游戏一开始，就需要从文件中读取此前的分数，好为这部分逻辑做判断，逻辑如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="comment"># 加载最高分数</span></span><br><span class="line">        self.load_data()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.dir = os.path.dirname(__file__)</span><br><span class="line">        filepath = os.path.join(self.dir, HS_FILE)</span><br><span class="line">        <span class="keyword">with</span> open(filepath, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.highscore = int(f.read())</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                self.highscore = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="玩家图片化"><a class="markdownIt-Anchor" href="#玩家图片化"></a> 玩家图片化</h2>
<p>一个正常的游戏，肯定要有相应的图片素材的，图片素材是否精美也是影响他人是否要玩你游戏的重要因素。</p>
<p>通常，一个游戏，会有多张大图，多个同类元素都放在这张大的png图片中，而不是每个元素都是一个png元素，通过这种方式，让整个游戏包更小。</p>
<p>如下，一张完整的图</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191106180439.png" alt="" /></p>
<p>与其对应的就是图中不同元素其坐标位置(x,y)以及元素图片大小</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191106180501.png" alt="" /></p>
<p>写一段从完整图片中获取对应元素的逻辑，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sprites.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载与解析精灵图片</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spritesheet</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename)</span>:</span></span><br><span class="line">        <span class="comment"># 主要要使用convert()进行优化， convert()方法会 改变图片的像素格式</span></span><br><span class="line">        <span class="comment"># 这里加载了整张图片</span></span><br><span class="line">        self.spritesheet = pg.image.load(filename).convert()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从比较大的精灵表中，通过相应的xml位置，抓取中出需要的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_image</span><span class="params">(self, x, y, width, height)</span>:</span></span><br><span class="line">        <span class="comment"># 创建Surface对象(画板对象)</span></span><br><span class="line">        image = pg.Surface((width, height))</span><br><span class="line">        <span class="comment"># blit — 画一个图像到另一个</span></span><br><span class="line">        <span class="comment"># 将整张图片中，对应位置(x,y)对应大小(width,height)中的图片画到画板中</span></span><br><span class="line">        image.blit(self.spritesheet, (<span class="number">0</span>, <span class="number">0</span>), (x, y, width, height))</span><br><span class="line">        <span class="comment">#  pygame.transform.scale 缩放的大小</span></span><br><span class="line">        <span class="comment"># 这里将图片缩放为原来的一半</span></span><br><span class="line">        image = pg.transform.scale(image, (width // <span class="number">2</span>, height // <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure>
<p>在__init__()中，通过pygame.image.load()方法加载完整的图片，记得使用convert()方法进行优化，随后定义了get_image()方法，该方法的逻辑也很直接，先实例化Surface类，获得与图片大小相同的面板对象，然后，通过blit()方法将完整图片中对应位置与大小的元素剥离出来。</p>
<p>经过实践，原本图片元素太大，所以通过pygame.transform.scale()方法将图片元素缩小2倍。</p>
<p>编写完Spritesheet类后，在Game类的load_data()方法中实例化一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py/Game</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">(self)</span>:</span> <span class="comment"># 加载数据</span></span><br><span class="line">        self.dir = os.path.dirname(__file__)</span><br><span class="line">        filepath = os.path.join(self.dir, HS_FILE)</span><br><span class="line">        <span class="keyword">with</span> open(filepath, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.highscore = int(f.read())</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                self.highscore = <span class="number">0</span></span><br><span class="line">        img_dir = os.path.join(self.dir, <span class="string">'img'</span>)</span><br><span class="line">        <span class="comment"># 加载精灵图片</span></span><br><span class="line">        self.spritesheet = Spritesheet(os.path.join(img_dir, SPRITESHEET))</span><br></pre></td></tr></table></figure>
<p>做完这些后，在Player类初始化时调用其中的get_image()方法就大功告成了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span><span class="params">(pg.sprite.Sprite)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, game)</span>:</span></span><br><span class="line">        pg.sprite.Sprite.__init__(self)</span><br><span class="line">        self.game = game</span><br><span class="line">        <span class="comment"># 加载 bunny1_ready状态的兔子图片， xml文件中给出的(x,y)与(width,height)</span></span><br><span class="line">        self.image = self.game.spritesheet.get_image(<span class="number">614</span>, <span class="number">1063</span>, <span class="number">120</span>, <span class="number">191</span>)</span><br><span class="line">        self.image.set_colorkey(BLACK)</span><br><span class="line">        self.rect = self.image.get_rect()</span><br><span class="line">        self.rect.center = (WIDTH / <span class="number">2</span>, HEIGHT / <span class="number">2</span>)</span><br><span class="line">        self.pos = vec(WIDTH / <span class="number">2</span>, HEIGHT / <span class="number">2</span>)</span><br><span class="line">        self.vel = vec(<span class="number">0</span>, <span class="number">0</span>) <span class="comment"># 速度</span></span><br><span class="line">        self.acc = vec(<span class="number">0</span>, <span class="number">0</span>) <span class="comment"># 加速度</span></span><br></pre></td></tr></table></figure>
<p>为了整体美观，修改了一下，游戏框整体的背景颜色，具体通过self.screen.fill(BGCOLOR)方法。</p>
<p>最后，效果如下：</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191106182337.png" alt="" /></p>
<h2 id="结尾"><a class="markdownIt-Anchor" href="#结尾"></a> 结尾</h2>
<p>在本节中，我们实现了游戏结束界面以及使用了玩家元素，后面，会进一步优化玩家元素，让玩家在左右移动时，是不同的图片，从而让整个游戏显得更加灵动。</p>
<p>因为考虑到篇幅，文中没有给出完整的代码，但为了方便大家理解，我将相应的代码上传到了github</p>
<p><a href="https://github.com/ayuLiao/jumprabbit" target="_blank" rel="noopener">https://github.com/ayuLiao/jumprabbit</a></p>
<p>如果文章对你有帮助或你觉得有点意思，点击「在看」支持作者一波。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>利用pygame开发一款游戏:「跳跳兔」(五)</title>
    <url>/blog/2019/11/18/%E5%88%A9%E7%94%A8pygame%E5%BC%80%E5%8F%91%E4%B8%80%E6%AC%BE%E6%B8%B8%E6%88%8F-%E3%80%8C%E8%B7%B3%E8%B7%B3%E5%85%94%E3%80%8D-%E4%BA%94/</url>
    <content><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>本节会增加计分机制，即跳跃了多少个平台，有多少积分，此外如果玩家掉落在游戏框外，玩家死亡，开始新的一局游戏。</p>
<h2 id="增加积分机制"><a class="markdownIt-Anchor" href="#增加积分机制"></a> 增加积分机制</h2>
<p>积分机制的原理其实很简单，通过pygame在游戏框中绘制相应的文字，当玩家跳跃到新平台时，积分发生相应的变更，en…逻辑太简单了，直接看代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py/Game</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始新游戏时</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 初始化积分</span></span><br><span class="line">        self.score = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 玩家到达游戏框 1/4 处时（注意，游戏框，头部为0，底部为游戏框长度，到到游戏框的1/4处，表示已经到达了顶部一部分了）</span></span><br><span class="line">        <span class="keyword">if</span> self.player.rect.top &lt;= HEIGHT / <span class="number">4</span>:</span><br><span class="line">            <span class="comment"># 玩家位置移动（往下移动）</span></span><br><span class="line">            self.player.pos.y += abs(self.player.vel.y)</span><br><span class="line">            <span class="comment"># 平台在游戏框外时，将其注销，避免资源浪费</span></span><br><span class="line">            <span class="keyword">for</span> plat <span class="keyword">in</span> self.platforms:</span><br><span class="line">                <span class="comment"># 平台移动位置（往下移动，移动的距离与玩家相同，这样玩家才能依旧站立在原本的平台上）</span></span><br><span class="line">                plat.rect.y += abs(self.player.vel.y)</span><br><span class="line">                <span class="keyword">if</span> plat.rect.top &gt;= HEIGHT: </span><br><span class="line">                    plat.kill()</span><br><span class="line">                    <span class="comment"># 分数增加 - 平台销毁，分数相加</span></span><br><span class="line">                    self.score += <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>在new()方法中，初始化了积分对象，然后在update()方法中更新。这里的计分方式不是玩家跳跃到一个新的平台就积分，而是旧的平台被销毁后，再计分。这就能避免玩家不向上跳跃，而一直在原地跳跃就能获得积分的情况。</p>
<p>接着就是绘制积分文字的逻辑，将其放置在draw()方法中实现.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py/Game</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(self)</span>:</span></span><br><span class="line">   <span class="comment"># 绘制</span></span><br><span class="line">   self.screen.fill(BLACK)</span><br><span class="line">   self.all_sprites.draw(self.screen)</span><br><span class="line">   <span class="comment"># 绘制文字 - 具体的分数</span></span><br><span class="line">   self.draw_text(str(self.score), <span class="number">22</span>, WHITE, WIDTH / <span class="number">2</span>, <span class="number">15</span>)</span><br><span class="line">   <span class="comment"># 翻转</span></span><br><span class="line">   pg.display.flip()</span><br></pre></td></tr></table></figure>
<p>在draw()方法中，调用了self.draw_text()方法进行文字的显示，该方法代码如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py/Game</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="comment"># 设置绘制时使用的字体，你也可以直接使用系统本身的字体</span></span><br><span class="line">        self.font_name = pg.font.match_font(FONT_NAME)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 绘制文字</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw_text</span><span class="params">(self, text, size, color, x, y)</span>:</span></span><br><span class="line">        font = pg.font.Font(self.font_name, size) <span class="comment"># 设置字体与大小</span></span><br><span class="line">        text_surface = font.render(text, <span class="literal">True</span>, color) <span class="comment"># 设置颜色</span></span><br><span class="line">        text_rect = text_surface.get_rect() <span class="comment"># 获得字体对象</span></span><br><span class="line">        text_rect.midtop = (x, y) <span class="comment"># 定义位置</span></span><br><span class="line">        self.screen.blit(text_surface, text_rect) <span class="comment"># 在屏幕中绘制字体</span></span><br></pre></td></tr></table></figure>
<p>代码中给出了详细的注释，不再赘述。</p>
<p>增加了上面的代码，运行游戏，就会有相应的积分效果</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191105123441.png" alt="" /></p>
<h2 id="玩家死亡"><a class="markdownIt-Anchor" href="#玩家死亡"></a> 玩家死亡</h2>
<p>如果玩家这个方块位于游戏框范围外，该玩家就死亡了，将这个逻辑实现到Game类的update()方法中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#main.py/Game</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 死亡 - 玩家底部大于游戏框高度</span></span><br><span class="line">        <span class="keyword">if</span> self.player.rect.bottom &gt; HEIGHT:</span><br><span class="line">            <span class="keyword">for</span> sprite <span class="keyword">in</span> self.all_sprites:</span><br><span class="line">                sprite.rect.y -= max(self.player.vel.y, <span class="number">10</span>)</span><br><span class="line">                <span class="comment"># 元素底部小于0 - 说明在游戏框外面，将其删除</span></span><br><span class="line">                <span class="keyword">if</span> sprite.rect.bottom &lt; <span class="number">0</span>:</span><br><span class="line">                    sprite.kill()</span><br></pre></td></tr></table></figure>
<p>一开始判断玩家对象方块的底部是否大于游戏框高度了，如果大于，说明玩家已经在游戏框最底部了，而且有一部分已经在游戏框外了，此时玩家死亡，游戏结束。</p>
<h2 id="绘制游戏开始界面"><a class="markdownIt-Anchor" href="#绘制游戏开始界面"></a> 绘制游戏开始界面</h2>
<p>你是否还记得第二节中给出的整体结构，其中包括了show_start_screen()方法与show_go_screen()方法，因为整体的运行逻辑如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = Game()</span><br><span class="line">g.show_start_screen() <span class="comment"># 游戏开始前会执行的逻辑</span></span><br><span class="line"><span class="keyword">while</span> g.running:</span><br><span class="line">    g.new()</span><br><span class="line">    g.show_go_screen() <span class="comment"># 一轮游戏结束后会执行的逻辑</span></span><br><span class="line"></span><br><span class="line">pg.quit()</span><br></pre></td></tr></table></figure>
<p>可以将游戏开始界面的绘制逻辑写到show_start_screen()方法中，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py/Game</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始游戏的钩子函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_start_screen</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.screen.fill(BGCOLOR) <span class="comment"># 填充颜色</span></span><br><span class="line">        self.draw_text(TITLE, <span class="number">48</span>, WHITE, WIDTH / <span class="number">2</span>, HEIGHT / <span class="number">4</span>)</span><br><span class="line">        <span class="comment"># 绘制文字</span></span><br><span class="line">        self.draw_text(<span class="string">"Left and right button move, space bar jump"</span>, <span class="number">22</span>, WHITE, WIDTH / <span class="number">2</span>, HEIGHT / <span class="number">2</span>)</span><br><span class="line">        self.draw_text(<span class="string">"Press any key to start the game"</span>, <span class="number">22</span>, WHITE, WIDTH / <span class="number">2</span>, HEIGHT * <span class="number">3</span> / <span class="number">4</span>)</span><br><span class="line">        <span class="comment"># 画布翻转</span></span><br><span class="line">        pg.display.flip()</span><br><span class="line">        self.wait_for_key() <span class="comment"># 等待用户敲击键盘中的仍以位置</span></span><br></pre></td></tr></table></figure>
<p>在show_start_screen()方法中，一开会先填充了整个背景颜色，然后调用了draw_text()方法绘制文字，这里如果使用中文是无法显示的，pygame中要显示中文，需要指定对应的系统字体，如系统中的「宋体」、「黑体」等，最后调用了wait_for_key()方法进行等待，该方法逻辑如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py/Game</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait_for_key</span><span class="params">(self)</span>:</span></span><br><span class="line">        waiting = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> waiting:</span><br><span class="line">            self.clock.tick(FPS)</span><br><span class="line">            <span class="keyword">for</span> event <span class="keyword">in</span> pg.event.get():</span><br><span class="line">                <span class="keyword">if</span> event.type == pg.QUIT: <span class="comment"># 点击退出，结束等待循环</span></span><br><span class="line">                    waiting = <span class="literal">False</span></span><br><span class="line">                    self.running = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> event.type == pg.KEYUP: <span class="comment"># 按下键盘，结束等待循环</span></span><br><span class="line">                    waiting = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>wait_for_key()方法的逻辑就是一个无限循环，只有用户点击关闭按钮或敲击键盘中的任意键才能退出这个循环。</p>
<p>退出循环后，才能进入真正的游戏循环开始游戏。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191105124405.png" alt="" /></p>
<h2 id="结尾"><a class="markdownIt-Anchor" href="#结尾"></a> 结尾</h2>
<p>在本节中，我们实现了计分逻辑、死亡逻辑以及游戏启动时简单欢迎界面逻辑。</p>
<p>因为考虑到篇幅，文中没有给出完整的代码，但为了方便大家理解，我将相应的代码上传到了github</p>
<p><a href="https://github.com/ayuLiao/jumprabbit" target="_blank" rel="noopener">https://github.com/ayuLiao/jumprabbit</a></p>
<p>如果文章对你有帮助或你觉得有点意思，点击「在看」支持作者一波。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>利用pygame开发一款游戏：「跳跳兔」(四)</title>
    <url>/blog/2019/11/18/%E5%88%A9%E7%94%A8pygame%E5%BC%80%E5%8F%91%E4%B8%80%E6%AC%BE%E6%B8%B8%E6%88%8F%EF%BC%9A%E3%80%8C%E8%B7%B3%E8%B7%B3%E5%85%94%E3%80%8D-%E5%9B%9B/</url>
    <content><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>「跳跳兔」小游戏中的玩家当然要有跳跃能力，本节就来实现玩家类的跳跃以及整个游戏框界面的更新，当玩家跳跃时，游戏背景要往后移动，要有新的平台产生，让玩家可以继续跳跃，本节就来实现这样的功能。</p>
<h2 id="赋予玩家跳跃功能"><a class="markdownIt-Anchor" href="#赋予玩家跳跃功能"></a> 赋予玩家跳跃功能</h2>
<p>为了让界面有多个元素，在一开始初始化游戏框时，就初始化多个平台元素，效果如下：</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191104201221.png" alt="" /></p>
<p>代码如下，为了方便理解，没有展示无关代码，将多个文件的代码一同显示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># settings.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 平台列表</span></span><br><span class="line">PLATFORM_LIST = [(<span class="number">0</span>, HEIGHT - <span class="number">40</span>, WIDTH, <span class="number">40</span>),</span><br><span class="line">                 (WIDTH / <span class="number">2</span> - <span class="number">50</span>, HEIGHT * <span class="number">3</span> / <span class="number">4</span>, <span class="number">100</span>, <span class="number">20</span>),</span><br><span class="line">                 (<span class="number">125</span>, HEIGHT - <span class="number">350</span>, <span class="number">100</span>, <span class="number">20</span>),</span><br><span class="line">                 (<span class="number">350</span>, <span class="number">200</span>, <span class="number">100</span>, <span class="number">20</span>),</span><br><span class="line">                 (<span class="number">175</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">20</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># main.py/Game</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># start a new game</span></span><br><span class="line">        self.all_sprites = pg.sprite.Group()</span><br><span class="line">        self.platforms = pg.sprite.Group()</span><br><span class="line">        self.player = Player(self)</span><br><span class="line">        self.all_sprites.add(self.player)</span><br><span class="line">        <span class="comment"># 实例化一系列平台，并添加到所有元素组与平台元素组中</span></span><br><span class="line">        <span class="keyword">for</span> plat <span class="keyword">in</span> PLATFORM_LIST:</span><br><span class="line">            p = Platform(*plat)</span><br><span class="line">            self.all_sprites.add(p)</span><br><span class="line">            self.platforms.add(p)</span><br><span class="line">        self.run()</span><br></pre></td></tr></table></figure>
<p>上述逻辑就是在开始新游戏时，for迭代创建PLATFORM_LIST列表中给定位位置与大小的平台。</p>
<p>接着就来实现跳跃逻辑。</p>
<p>为了代码直观，将监控跳跃相关的逻辑写到events()方法中(该方法负责事件处理)，我们希望点击空格键，玩家元素跳跃，其具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py/Game</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">events</span><span class="params">(self)</span>:</span></span><br><span class="line">   <span class="keyword">for</span> event <span class="keyword">in</span> pg.event.get():</span><br><span class="line">       <span class="keyword">if</span> event.type == pg.QUIT:</span><br><span class="line">           <span class="keyword">if</span> self.playing:</span><br><span class="line">               self.playing = <span class="literal">False</span></span><br><span class="line">           self.running = <span class="literal">False</span></span><br><span class="line">       <span class="comment"># 玩家跳跃</span></span><br><span class="line">       <span class="keyword">if</span> event.type == pg.KEYDOWN:</span><br><span class="line">           <span class="keyword">if</span> event.key == pg.K_SPACE:</span><br><span class="line">               self.player.jump() <span class="comment"># 调用玩家跳跃方法</span></span><br></pre></td></tr></table></figure>
<p>简单而言，就是监控键盘敲击事件，然后判断敲击的按键为空格键(K_SPACE)，最后调用玩家对象的jump()方法实现跳跃。</p>
<p>看一下jump()方法的具体逻辑。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sprites.py/Player</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 跳跃</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self)</span>:</span></span><br><span class="line">   <span class="comment"># 对x轴进行加一减一操作，玩家只有站立在平台上，才能跳跃成功。</span></span><br><span class="line">   self.rect.x += <span class="number">1</span></span><br><span class="line">   hits = pg.sprite.spritecollide(self, self.game.platforms, <span class="literal">False</span>)</span><br><span class="line">   self.rect.x -= <span class="number">1</span></span><br><span class="line">   <span class="keyword">if</span> hits: <span class="comment"># 碰撞检测成功，站立在了平台上</span></span><br><span class="line">       self.vel.y = <span class="number">-20</span> <span class="comment"># 跳跃</span></span><br></pre></td></tr></table></figure>
<p>对player玩家对象的x走了加一减一并进行碰撞检测的操作，通过这种方式，就可以判断当前玩家对象是否站立与平台上，只有在平台上，才能让其跳跃，在空中是不允许玩家跳跃的(无法二段跳).</p>
<p>跳跃的本质是让玩家对象向上移动，这里就是-20，之所以是负数，是因为最上传y轴坐标为0，最下方y轴坐标为游戏框的高度，-20就是让玩家对象向上移动，如下图：</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191104214402.png" alt="" /></p>
<p>但这里跟新的只是self.vel速度属性，真正移动玩家对象的方法依旧是update()方法，其逻辑如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sprites.py/Player</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 有初始的加速度 - 玩家没有在平台上就会掉落</span></span><br><span class="line">        self.acc = vec(<span class="number">0</span>, PLAYER_GRAV)</span><br><span class="line">        keys = pg.key.get_pressed()</span><br><span class="line">        <span class="keyword">if</span> keys[pg.K_LEFT]:</span><br><span class="line">            self.acc.x = -PLAYER_ACC</span><br><span class="line">        <span class="keyword">if</span> keys[pg.K_RIGHT]:</span><br><span class="line">            self.acc.x = PLAYER_ACC</span><br><span class="line"></span><br><span class="line">        self.acc.x += self.vel.x * PLAYER_FRICTION</span><br><span class="line">        self.vel += self.acc</span><br><span class="line">        self.pos += self.vel + <span class="number">0.5</span> * self.acc</span><br><span class="line">        <span class="keyword">if</span> self.pos.x &gt; WIDTH:</span><br><span class="line">            self.pos.x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> self.pos.x &lt; <span class="number">0</span>:</span><br><span class="line">            self.pos.x = WIDTH</span><br><span class="line">        <span class="comment"># 赋值给底部 - 碰撞检测相关</span></span><br><span class="line">        self.rect.midbottom = self.pos</span><br></pre></td></tr></table></figure>
<p>update()方法逻辑与上节内容相同，不再赘述。</p>
<p>至此，就完成了玩家的跳跃。</p>
<h2 id="背景移动效果"><a class="markdownIt-Anchor" href="#背景移动效果"></a> 背景移动效果</h2>
<p>但玩家对象光跳跃是不够的，整个游戏界面不移动，玩家跳两下就没有平台可以跳跃了，所以接着来实现游戏界面整体移动的效果。</p>
<p>在开始写之前，需要理清一个概念，要实现移动效果，并不是游戏界面整体向下移动了，而是游戏框中的元素整体向后移动的，具体而言就是玩家类向下移动了一部分具体，对应的平台元素也向下移动了一段距离。</p>
<p>要实现这个效果，可以通过Game游戏类的update()方法来实现，该方法主要用于更新游戏的整体状态，其具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py/Game</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.all_sprites.update()</span><br><span class="line">        <span class="comment"># # 玩家在界面中时(y&gt;0)，进行碰撞检测，检测玩家是否碰撞到平台</span></span><br><span class="line">        <span class="keyword">if</span> self.player.vel.y &gt; <span class="number">0</span>:</span><br><span class="line">            hits = pg.sprite.spritecollide(self.player, self.platforms, <span class="literal">False</span>)</span><br><span class="line">            <span class="keyword">if</span> hits:</span><br><span class="line">                self.player.pos.y = hits[<span class="number">0</span>].rect.top</span><br><span class="line">                self.player.vel.y = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 玩家到达游戏框 1/4 处时（注意，游戏框，头部为0，底部为游戏框长度，到到游戏框的1/4处，表示已经到达了顶部一部分了）</span></span><br><span class="line">        <span class="keyword">if</span> self.player.rect.top &lt;= HEIGHT / <span class="number">4</span>:</span><br><span class="line">            <span class="comment"># 玩家位置移动（往下移动）</span></span><br><span class="line">            self.player.pos.y += abs(self.player.vel.y)</span><br><span class="line">            <span class="comment"># 平台在游戏框外时，将其注销，避免资源浪费</span></span><br><span class="line">            <span class="keyword">for</span> plat <span class="keyword">in</span> self.platforms:</span><br><span class="line">                <span class="comment"># 平台移动位置（往下移动，移动的距离与玩家相同，这样玩家才能依旧站立在原本的平台上）</span></span><br><span class="line">                plat.rect.y += abs(self.player.vel.y)</span><br><span class="line">                <span class="keyword">if</span> plat.rect.top &gt;= HEIGHT: </span><br><span class="line">                    plat.kill()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断平台数，产生新的平台</span></span><br><span class="line">        <span class="keyword">while</span> len(self.platforms) &lt; <span class="number">6</span>:</span><br><span class="line">            width = random.randrange(<span class="number">50</span>, <span class="number">100</span>)</span><br><span class="line">            <span class="comment"># 随机生成平台</span></span><br><span class="line">            p = Platform(random.randrange(<span class="number">0</span>, WIDTH - width),</span><br><span class="line">                         random.randrange(<span class="number">-75</span>, <span class="number">-30</span>),</span><br><span class="line">                         width, <span class="number">20</span>)</span><br><span class="line">            self.platforms.add(p)</span><br><span class="line">            self.all_sprites.add(p)</span><br></pre></td></tr></table></figure>
<p>Game类的update()方法中，主要新增了两段逻辑。</p>
<p>当玩家到达游戏框的1/4时，此时玩家对象已经在高位，此时要做的就是移动玩家对象以及通过for迭代移动所有的平台对象，让玩家对象与平台对象向下移动相同的距离实现整个游戏框界面向下移动的效果。此外还会判断平台对象的顶部是否大于游戏框高度，如果大于，说明当前的平台对象依旧完全在游戏框外了，调用kill()方法将其注销，避免占用额外的内存。</p>
<p>接着通过while循环当前平台对象的个数，通过此前的逻辑，我们消除了在游戏框外的平台对象，为了让平台对象个数总是为6，这里会随机创建相应个数的平台对象作为补充，通过random来实现平台位置的随机，让游戏不至于太过无聊。</p>
<h2 id="结尾"><a class="markdownIt-Anchor" href="#结尾"></a> 结尾</h2>
<p>因为考虑到篇幅，文中没有给出完整的代码，但为了方便大家理解，我将相应的代码上传到了github</p>
<p><a href="https://github.com/ayuLiao/jumprabbit" target="_blank" rel="noopener">https://github.com/ayuLiao/jumprabbit</a></p>
<p>如果文章对你有帮助或你觉得有点意思，点击「在看」支持作者一波。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>利用pygame开发一款游戏:「跳跳兔」(三)</title>
    <url>/blog/2019/11/18/%E5%88%A9%E7%94%A8pygame%E5%BC%80%E5%8F%91%E4%B8%80%E6%AC%BE%E6%B8%B8%E6%88%8F-%E3%80%8C%E8%B7%B3%E8%B7%B3%E5%85%94%E3%80%8D-%E4%B8%89/</url>
    <content><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>pygame如何通过键盘来控制游戏中的元素呢？元素之间是如何进行碰撞检测的呢？</p>
<p>阅读完本节你就很清晰了，此外本文还会整理出pygame开发游戏的通用整体结构，该系列后续的内容都以这个结构来编写。</p>
<h2 id="整体结构"><a class="markdownIt-Anchor" href="#整体结构"></a> 整体结构</h2>
<p>随着游戏项目的复杂化，有必要整理一下代码，形成一个统一的风格。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame <span class="keyword">as</span> pg</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span>:</span></span><br><span class="line">    <span class="comment"># 初始化窗口、计数器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 开启新的游戏</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 游戏中的大循环</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 事件</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">events</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 绘制界面</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 游戏启动 / 开始画面的钩子函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_start_screen</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># game splash/start screen</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 游戏结束 / 继续的钩子函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_go_screen</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 入口逻辑       </span></span><br><span class="line">g = Game()</span><br><span class="line">g.show_start_screen()</span><br><span class="line"><span class="keyword">while</span> g.running:</span><br><span class="line">    g.new()</span><br><span class="line">    g.show_go_screen()</span><br><span class="line"></span><br><span class="line">pg.quit()</span><br></pre></td></tr></table></figure>
<p>将不同的步骤封成不同的方法，这样让Game类会简单直观很多，不同方法的细节如下</p>
<p>在<code>__init__</code>中，初始化各种基本对象，如pygame对象、计数器对象等待</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py/Game</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># 初始化窗口、计数器</span></span><br><span class="line">    pg.init()</span><br><span class="line">    pg.mixer.init()</span><br><span class="line">    self.screen = pg.display.set_mode((WIDTH, HEIGHT))</span><br><span class="line">    pg.display.set_caption(TITLE)</span><br><span class="line">    self.clock = pg.time.Clock()</span><br><span class="line">    self.running = <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>在new()方法中，新游戏开始时，进行元素的初始化，并调用run()方法，运行游戏的主循环。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py/Game</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启新的游戏</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">(self)</span>:</span></span><br><span class="line">   self.all_sprites = pg.sprite.Group()</span><br><span class="line">   self.player = Player()</span><br><span class="line">   self.all_sprites.add(self.player)</span><br><span class="line">   self.run()</span><br></pre></td></tr></table></figure>
<p>run()方法就很简单了，主要就是调用相应的方法设置帧率、处理事件输入、更新状态与绘制渲染游戏等，代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py/Game</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 游戏中的大循环</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">   self.playing = <span class="literal">True</span></span><br><span class="line">   <span class="keyword">while</span> self.playing:</span><br><span class="line">       self.clock.tick(FPS) <span class="comment"># 设置帧率</span></span><br><span class="line">       self.events() <span class="comment"># 事件输入处理</span></span><br><span class="line">       self.update() <span class="comment"># 状态更新</span></span><br><span class="line">       self.draw() <span class="comment"># 绘制</span></span><br></pre></td></tr></table></figure>
<p>对应方法代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 更新所有元素的状态</span></span><br><span class="line">        self.all_sprites.update()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">events</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># 获得事件输入</span></span><br><span class="line">    <span class="keyword">for</span> event <span class="keyword">in</span> pg.event.get():</span><br><span class="line">         <span class="comment"># 判断是否是退出事件</span></span><br><span class="line">         <span class="keyword">if</span> event.type == pg.QUIT:</span><br><span class="line">               <span class="keyword">if</span> self.playing:</span><br><span class="line">                   self.playing = <span class="literal">False</span></span><br><span class="line">               self.running = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># 绘制与渲染游戏背景</span></span><br><span class="line">    self.screen.fill(BLACK)</span><br><span class="line">    self.all_sprites.draw(self.screen) <span class="comment"># 绘制所有元素到界面中</span></span><br><span class="line">    pg.display.flip()</span><br></pre></td></tr></table></figure>
<p>代码内容在前面文章中介绍过，不再赘述。</p>
<h2 id="控制玩家元素"><a class="markdownIt-Anchor" href="#控制玩家元素"></a> 控制玩家元素</h2>
<p>控制玩家元素其实非常简单，核心就是利用<code>pg.key.get_pressed()</code>方法获得键盘的输入，然后判断敲击的键位是不是需要的键位，如果是，则移动元素。</p>
<p>但还需要考虑的是如何移动元素？想此前简单的对元素x轴或y轴方向添加位移距离是不适合的，比如我就敲了一下左键，元素就一直往左移动，不会停下来，这不符合常规，应该要实现，只有一直按着左键，元素才能一直向左移动。</p>
<p>为了实现上述的效果，就需要引入摩擦系数，模仿现实世界，我们之所以走一步不会一直滑下去就是因为存在摩擦力，这里我们使用摩擦系数来模拟这个过程。</p>
<p>下面通过代码来实现一下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame <span class="keyword">as</span> pg</span><br><span class="line"><span class="keyword">from</span> settings <span class="keyword">import</span> *</span><br><span class="line">vec = pg.math.Vector2 <span class="comment"># 二维变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在settings.py中，为了方便理解，贴一下</span></span><br><span class="line"><span class="comment"># PLAYER_ACC = 0.5 # 加速度 </span></span><br><span class="line"><span class="comment"># PLAYER_FRICTION = -0.12 # 摩擦系数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span><span class="params">(pg.sprite.Sprite)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        pg.sprite.Sprite.__init__(self)</span><br><span class="line">        <span class="comment"># 创建一个黄色方块作为玩家元素</span></span><br><span class="line">        self.image = pg.Surface((<span class="number">30</span>, <span class="number">40</span>))</span><br><span class="line">        self.image.fill(YELLOW)</span><br><span class="line">        self.rect = self.image.get_rect()</span><br><span class="line">        <span class="comment"># 初始化在游戏框中心</span></span><br><span class="line">        self.rect.center = (WIDTH / <span class="number">2</span>, HEIGHT / <span class="number">2</span>)</span><br><span class="line">        self.pos = vec(WIDTH / <span class="number">2</span>, HEIGHT / <span class="number">2</span>) <span class="comment"># 创建一个二维变量并将其初始化为游戏框的中心位置</span></span><br><span class="line">        self.vel = vec(<span class="number">0</span>, <span class="number">0</span>) <span class="comment"># 记录速度</span></span><br><span class="line">        self.acc = vec(<span class="number">0</span>, <span class="number">0</span>) <span class="comment"># 记录加速度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.acc = vec(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        keys = pg.key.get_pressed() <span class="comment"># 获得键盘输入</span></span><br><span class="line">        <span class="keyword">if</span> keys[pg.K_LEFT]: <span class="comment"># 按左</span></span><br><span class="line">            self.acc.x = -PLAYER_ACC <span class="comment"># 加速度，正负号表示方向</span></span><br><span class="line">        <span class="keyword">if</span> keys[pg.K_RIGHT]: <span class="comment"># 按右</span></span><br><span class="line">            self.acc.x = PLAYER_ACC</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算加速度 </span></span><br><span class="line">        <span class="comment"># 当前加速度 = (上一帧的速度 * 摩擦系数) + 上一帧加速度</span></span><br><span class="line">        self.acc += self.vel * PLAYER_FRICTION</span><br><span class="line">        <span class="comment"># 当前速度 = 当前加速度 + 上一帧的速度</span></span><br><span class="line">        self.vel += self.acc</span><br><span class="line">        <span class="comment"># 有了当前速度与加速度，就可以计算移动距离了</span></span><br><span class="line">        self.pos += self.vel + <span class="number">0.5</span> * self.acc</span><br><span class="line">        <span class="comment"># 跑马灯效果</span></span><br><span class="line">        <span class="keyword">if</span> self.pos.x &gt; WIDTH:</span><br><span class="line">            self.pos.x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> self.pos.x &lt; <span class="number">0</span>:</span><br><span class="line">            self.pos.x = WIDTH</span><br><span class="line">        <span class="comment"># 移动玩家元素</span></span><br><span class="line">        self.rect.center = self.pos</span><br></pre></td></tr></table></figure>
<p><code>__init__()</code>方法中，除了初始化玩家元素为一个黄色长方形外，还利用pg.math.Vector2初始化了多个二维变量，pygame的math模块还支持三维变量的初始化。</p>
<p>初始化多个二维变量的目的在于计算当前帧的移动距离，其基本物理公式可以参考下图。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191103094304.png" alt="" /></p>
<p>再看到update()方法，计算移动距离其实就是套用了上图红色框中的公式，只是时间t为1。时间t之所以可以为1，是因为我们每一帧都在这部分逻辑，将每一帧时间作为1则可。</p>
<p>其余的具体逻辑，请阅读详细的注释，注释比文字好理解。</p>
<p>最后，将计算出来的新位置self.pos赋值给玩家元素的中心点，从而实现玩家元素的移动，玩家中心点的理解可以参考下图。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191103094654.png" alt="" /></p>
<h2 id="碰撞检测"><a class="markdownIt-Anchor" href="#碰撞检测"></a> 碰撞检测</h2>
<p>通过上两节的代码，已经可以实现通过键盘空中游戏框中黄色方块的效果，但感觉有点单调，是否可以让元素在某个平台上运行呢？</p>
<p>具体而言就是实现下面的效果，黄色的玩家元素在绿色的平台上站立移动，如果超出绿色小平台的范围，会自动的落下到下面的绿色大平台。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191103100017.png" alt="" /></p>
<p>wow，跟「跳跳兔」游戏有点关系了。</p>
<p>首先，绿色平台本身也是一个元素，所以在开始新游戏时，需要初始化好这个元素，具体逻辑写到new()方法中则可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py/Game</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始新的游戏</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">(self)</span>:</span></span><br><span class="line">   self.all_sprites = pg.sprite.Group() <span class="comment"># 所有元素组</span></span><br><span class="line">   self.platforms = pg.sprite.Group() <span class="comment"># 平台元素组</span></span><br><span class="line">   self.player = Player() <span class="comment"># 实例化玩家对象</span></span><br><span class="line">   self.all_sprites.add(self.player) <span class="comment"># 添加到所有元素组</span></span><br><span class="line">   p1 = Platform(<span class="number">0</span>, HEIGHT - <span class="number">40</span>, WIDTH, <span class="number">40</span>) <span class="comment"># 实例化平台元素， 绿色小平台</span></span><br><span class="line">   self.all_sprites.add(p1) <span class="comment"># 添加到所有元素组</span></span><br><span class="line">   self.platforms.add(p1) <span class="comment"># 添加到平台元素组</span></span><br><span class="line">   p2 = Platform(WIDTH / <span class="number">2</span> - <span class="number">50</span>, HEIGHT * <span class="number">3</span> / <span class="number">4</span>, <span class="number">100</span>, <span class="number">20</span>) <span class="comment"># 绿色大平台</span></span><br><span class="line">   self.all_sprites.add(p2)</span><br><span class="line">   self.platforms.add(p2)</span><br><span class="line">   self.run() <span class="comment"># 运行</span></span><br><span class="line">   </span><br><span class="line"><span class="comment"># 为了方便，展示一下Platform类对应的代码</span></span><br><span class="line"><span class="comment"># sprites.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Platform</span><span class="params">(pg.sprite.Sprite)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y, w, h)</span>:</span></span><br><span class="line">        pg.sprite.Sprite.__init__(self)</span><br><span class="line">        self.image = pg.Surface((w, h))</span><br><span class="line">        self.image.fill(GREEN)</span><br><span class="line">        self.rect = self.image.get_rect()</span><br><span class="line">        self.rect.x = x</span><br><span class="line">        self.rect.y = y</span><br></pre></td></tr></table></figure>
<p>代码中有详细的注释，你可能对创建一个平台元素组的做法带有疑惑，平台对象为什么既要添加到所有元素组中又有添加到平台元素组中？</p>
<p>这是为了方便做碰撞检测。</p>
<p>通常，碰撞检测的逻辑会写到游戏中元素状态更新后，判断更新后的状态是否发生了碰撞，所谓碰撞就是不同的两个元素某部分接触到了，在pygame中使用pg.sprite.spritecollide()方法就可以判断出来了。</p>
<p>看一下具体的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py/Game</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">   self.all_sprites.update()</span><br><span class="line">   <span class="comment"># 碰撞检测，检测玩家对象self.player 与 平台元素组中的所有平台对象是否发生碰撞</span></span><br><span class="line">   hits = pg.sprite.spritecollide(self.player, self.platforms, <span class="literal">False</span>)</span><br><span class="line">   <span class="keyword">if</span> hits: <span class="comment"># 发生碰撞</span></span><br><span class="line">       <span class="comment"># 玩家对象的y轴位置等于碰撞对象的顶部</span></span><br><span class="line">       self.player.pos.y = hits[<span class="number">0</span>].rect.top</span><br><span class="line">       <span class="comment"># 玩家对象y轴速度为0，即不再移动</span></span><br><span class="line">       self.player.vel.y = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>看到碰撞检测的相关逻辑，玩家对象要与所有的平台对象进行碰撞检测，利用平台元素组就可以轻松搞定，这也是new()中平台对象既要添加到所有元素组中又有添加到平台元素组中的原因。</p>
<p>如果发生了碰撞，则玩家对象的y轴位置等于碰撞对象的顶部，玩家对象y轴速度为0，即不再移动。</p>
<p>为了让效果正常，我们还需要修改一下玩家类的update()方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spirtes.py/Player</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">   self.acc = vec(<span class="number">0</span>, <span class="number">0.5</span>) <span class="comment"># x轴没有加速度，而y轴有初始加速度，让物体可以自由落下</span></span><br><span class="line">   keys = pg.key.get_pressed()</span><br><span class="line">   <span class="keyword">if</span> keys[pg.K_LEFT]:</span><br><span class="line">       self.acc.x = -PLAYER_ACC</span><br><span class="line">   <span class="keyword">if</span> keys[pg.K_RIGHT]:</span><br><span class="line">       self.acc.x = PLAYER_ACC</span><br><span class="line"></span><br><span class="line">   self.acc.x += self.vel.x * PLAYER_FRICTION</span><br><span class="line">   self.vel += self.acc</span><br><span class="line">   self.pos += self.vel + <span class="number">0.5</span> * self.acc</span><br><span class="line">   <span class="keyword">if</span> self.pos.x &gt; WIDTH:</span><br><span class="line">       self.pos.x = <span class="number">0</span></span><br><span class="line">   <span class="keyword">if</span> self.pos.x &lt; <span class="number">0</span>:</span><br><span class="line">       self.pos.x = WIDTH</span><br><span class="line">   <span class="comment"># 移动时，以元素底部为基准 - 与碰撞检测那里相互呼应</span></span><br><span class="line">   self.rect.midbottom = self.pos</span><br></pre></td></tr></table></figure>
<p>通过下面的图来辅助理解。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191103101102.png" alt="" /></p>
<p>速度分为x轴方向与y轴方向，因为y轴方向需要做碰撞检测，如果self.pos赋值给玩家元素的中心，即center，那么就会出现穿透现象。(在碰撞检测时，操作的是pos与val属性，而此时又将pos赋值给玩家元素的center，必然会出现穿透现象。)</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191103102634.png" alt="" /></p>
<h2 id="尾"><a class="markdownIt-Anchor" href="#尾"></a> 尾</h2>
<p>本节给出了比较多的内容，讨论元素的控制，基本运动的实现逻辑以及碰撞检测等，至此已经构建出了「跳跳兔」最基本的原型。</p>
<p>如果你觉得文章还不错，点击「在看」支持一下作者。</p>
<p>今天一日一题不弄了，花点时间准备录「动态规划」的视频。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>利用pygame开发一款游戏:「跳跳兔」(二)</title>
    <url>/blog/2019/11/18/%E5%88%A9%E7%94%A8pygame%E5%BC%80%E5%8F%91%E4%B8%80%E6%AC%BE%E6%B8%B8%E6%88%8F-%E3%80%8C%E8%B7%B3%E8%B7%B3%E5%85%94%E3%80%8D-%E4%BA%8C/</url>
    <content><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>本节来看一下如何创建一个玩家对象并让其在游戏框中运动。</p>
<h2 id="玩家类"><a class="markdownIt-Anchor" href="#玩家类"></a> 玩家类</h2>
<p>从简到难，先通过一个简单的方块来表示一个玩家。</p>
<p>在pygame中，所有的对象都称为元素，玩家是一个元素，游戏中的怪物也是一个元素，而所有的元素都要通过<code>pygame.sprite.Sprite</code>来控制，下面就来创建一个简单的玩家类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span><span class="params">(pygame.sprite.Sprite)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        pygame.sprite.Sprite.__init__(self)</span><br><span class="line">        self.image = pygame.Surface((<span class="number">50</span>, <span class="number">50</span>)) <span class="comment"># self.image表示元素本身</span></span><br><span class="line">        self.image.fill(GREEN) <span class="comment"># 元素本身填充为绿色</span></span><br><span class="line">        self.rect = self.image.get_rect() <span class="comment"># 获得该元素对应的方块</span></span><br><span class="line">        self.rect.center = (WIDTH /<span class="number">2</span>, HEIGHT / <span class="number">2</span>) <span class="comment"># 将该元素放置在窗口中间(方块代表这元素)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新角色 - 移动</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.rect.x += <span class="number">5</span></span><br><span class="line">        <span class="keyword">if</span> self.rect.left &gt; WIDTH:</span><br><span class="line">            self.rect.right = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>我们定义了Player类，它继承于pygame.sprite.Sprite，在<code>__init__()</code>初始化方法中，调用了pygame.sprite.Sprite中的初始化方法，完成基本的初始化。</p>
<p>随后，调用了pygame.Surface()方法创建了一个50x50的正方形，然后将其填充为绿色。最后就是将Player类这个绿色的方法放在游戏框的正中间。</p>
<p>除了定义<code>__init__()</code>方法，Player类中还定义了update()方法，该方法就是让绿色方块沿x轴平移，当绿色方块的left超出游戏框时，就将right置为0，这样就会达到走马灯的效果。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191102111153.png" alt="" /></p>
<h2 id="让玩家运动起来"><a class="markdownIt-Anchor" href="#让玩家运动起来"></a> 让玩家运动起来</h2>
<p>光定义玩家类是无法让玩家元素平移运动的，回顾一下第一篇pygame文章，游戏本质就是循环，每次循环都要处理相应的逻辑，循环中逻辑的不同，造成了不同的游戏，所以为了让玩家元素可以移动，还需要实现这个循环。</p>
<p>首先，依旧是初始化相关的对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pygame.init() <span class="comment"># pygame初始化</span></span><br><span class="line">pygame.mixer.init() <span class="comment"># mixer在pygame中用于处理一切音频相关的东西</span></span><br><span class="line">screen = pygame.display.set_mode((WIDTH, HEIGHT)) <span class="comment"># 初始化窗口</span></span><br><span class="line">pygame.display.set_caption(<span class="string">'My Game'</span>) <span class="comment"># 标题名</span></span><br><span class="line">clock = pygame.time.Clock() <span class="comment"># 计时器，主要用于控制界面刷新的频率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在一个游戏中，通过一个元素组来表示该游戏中所有的角色</span></span><br><span class="line">all_sprites = pygame.sprite.Group()</span><br><span class="line">player = Player()</span><br><span class="line">all_sprites.add(player) <span class="comment"># 添加到元素组中</span></span><br></pre></td></tr></table></figure>
<p>与此前不同，因为多了玩家元素，所以需要初始化pygame.sprite.Group()，然后将玩家对象添加到元素组中，pygame要求我们通过元素组的方式来操作不同的元素。</p>
<p>初始化完成后，直接一个无限循环，代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 所有游戏都是一个循环, 循环中通常由三个部分组成，事件输入、元素状态更新、绘制</span></span><br><span class="line">running = <span class="literal">True</span></span><br><span class="line"><span class="keyword">while</span> running:</span><br><span class="line">    <span class="comment"># 帧率</span></span><br><span class="line">    clock.tick(FPS)</span><br><span class="line">    <span class="comment"># 处理事件输入</span></span><br><span class="line">    <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">        <span class="keyword">if</span> event.type == pygame.QUIT: <span class="comment">#如果点击 x 按钮，游戏退出，即跳出循环</span></span><br><span class="line">            running = <span class="literal">False</span></span><br><span class="line">    all_sprites.update() <span class="comment"># 更新角色</span></span><br><span class="line">    <span class="comment"># 绘制与渲染(依旧是黑色背景)</span></span><br><span class="line">    screen.fill(BLACK)</span><br><span class="line">    all_sprites.draw(screen) <span class="comment">#绘制所有元素到界面中</span></span><br><span class="line">    <span class="comment"># 翻转绘画板，更新界面，绘制任何内容，都需要这个步骤，不然绘制的内容在背面，玩家是不可见的</span></span><br><span class="line">    pygame.display.flip()</span><br></pre></td></tr></table></figure>
<p>为了方便大家理解，代码中我依旧给出了详细的注释，唯一不同就是多了事件输入的处理逻辑以及角色更新的逻辑。</p>
<p>通过pygame.event.get()可以获得pygame可以接收到的所有事件，在这个循环中，判断了事件类型，如果点击了窗口关闭按钮，就将running设置为False，结束无限循环。</p>
<p>此外，调用了元素组中的update()方法，对所有元素的状态进行更新，而当下元素组中只有玩家对象，所有玩家对象的状态被更新了，简单而言，玩家此时沿x轴移动了5个像素。随后的代码都与第一篇相同，不再赘述。</p>
<p>此时运行整个完整的代码，绿色方块就会在游戏屏幕中移动，实现跑马灯效果了。</p>
<h2 id="更进一步"><a class="markdownIt-Anchor" href="#更进一步"></a> 更进一步</h2>
<p>玩家类是一个绿色方块显得太过简陋，这里将其替换为一张图片，此外让玩家可以上下跳动，修改后，玩家类代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span><span class="params">(pygame.sprite.Sprite)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        pygame.sprite.Sprite.__init__(self)</span><br><span class="line">        <span class="comment"># pygame加载图像元素时，记得要使用convert()方法将图像转为pygame容易操控的对象，否则整个游戏加载会变慢</span></span><br><span class="line">        self.image = pygame.image.load(os.path.join(img_folder, <span class="string">'p1_jump.png'</span>)).convert()</span><br><span class="line">        self.image.set_colorkey(BLACK) <span class="comment"># 将图像矩阵中除图像外周围的元素都设置为透明的</span></span><br><span class="line">        self.rect = self.image.get_rect() <span class="comment"># 获得该元素对应的方块</span></span><br><span class="line">        self.rect.center = (WIDTH /<span class="number">2</span>, HEIGHT / <span class="number">2</span>) <span class="comment"># 将该元素放置在窗口中间(方块代表这元素)</span></span><br><span class="line">        self.y_speed = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新玩家状态</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.rect.x += <span class="number">5</span></span><br><span class="line">        self.rect.y += self.y_speed</span><br><span class="line">        <span class="keyword">if</span> self.rect.bottom &gt; HEIGHT - <span class="number">200</span>:</span><br><span class="line">            self.y_speed = <span class="number">-5</span></span><br><span class="line">        <span class="keyword">if</span> self.rect.top &lt; <span class="number">200</span>:</span><br><span class="line">            self.y_speed = <span class="number">5</span></span><br><span class="line">        <span class="keyword">if</span> self.rect.left &gt; WIDTH:</span><br><span class="line">            self.rect.right = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>上述代码中，利用pygame.image.load()方法实现图像元素的加载，需要注意，加载完后，一定要使用convert()方法将其转为pygame容易操作的对象(这是个Ticks)，接着还需要使用set_colorkey()方法将图像元素外的其他元素都设置为透明，不然显示在pygame游戏框中就会是一个正方形，正方形中有张图片，非常的丑。</p>
<p>此外，update()方法也走了一些逻辑修改，让玩家元素除了在x轴移动外，还实现其在y轴移动，移动的方式是上下跳动的形式，最终效果如下。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191102113547.png" alt="" /></p>
<h2 id="尾"><a class="markdownIt-Anchor" href="#尾"></a> 尾</h2>
<p>本节介绍了pygame怎么样去管理元素，在下一节中，将介绍pygame如何控制元素移动，即通过键盘控制游戏框中元素的移动。</p>
<p>如果文章对你有所帮助，请点「在看」给作者一点鼓励，叩谢豪恩。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>利用pygame开发一款游戏:「跳跳兔」(一)</title>
    <url>/blog/2019/11/18/%E5%88%A9%E7%94%A8pygame%E5%BC%80%E5%8F%91%E4%B8%80%E6%AC%BE%E6%B8%B8%E6%88%8F-%E3%80%8C%E8%B7%B3%E8%B7%B3%E5%85%94%E3%80%8D-%E4%B8%80/</url>
    <content><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>Python是否可以开发简单的游戏？明显是可以的。</p>
<p>在Python中可以利用pygame来开发一款游戏，有了pygame，就不需要我们自己去实现很低层的逻辑，如界面的刷新，物体的碰撞检测等等。</p>
<p>这一系列文章是我个人此前学习笔记加以整理而成(学习内容来自：<a href="http://kidscancode.org/" target="_blank" rel="noopener">http://kidscancode.org/</a>)，所以开发的游戏并不是我个人原创的，本系列文章会开发一款「跳跳兔」，比互联网上随处可见的飞机大战有趣一些，其最终效果如下。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/WX20191101-190016.png" alt="" /></p>
<p>跳跳兔🐰可以左右移动以及上下跳动，如果获得了蓝色火箭卡片，就可以跳跃比较远的距离，如果碰到了飞行敌人，就会死亡，当然，没有跳动平台上也会死亡。</p>
<p>下面我们就分多篇文章来理解，如何利用pygame来开发这一款麻雀虽小五脏俱全的小游戏。</p>
<p>本系列使用MacOS+Python3.6来讲解。</p>
<p>本篇先从pygame基本使用开会讲解。</p>
<h2 id="pygame安装与介绍"><a class="markdownIt-Anchor" href="#pygame安装与介绍"></a> pygame安装与介绍</h2>
<p>Pygame 是跨平台 Python 模块，专为 电子游戏设计。包含图像、声音。创建在 SDL 基础上，允许实时 电子游戏研发而无需被低级语言，如 C 语言或是更低级的汇编语言束缚。</p>
<p>Pygame 应用程序能够在 Android 手机和平板运行，采用 Pygame 对于 Andorid 的子集 (pgs4a)。支持 Android 的声音，振动，键盘和加速。但缺点是没有办法在 iOS 上运行 Pygame 应用程序。</p>
<p>pgs4a 的主要限制是缺乏对于多点触控的支持， 这使得双指缩放，以及旋转无法使用。另一个 Pygame 在 Android 子集的替代方案是 Kivy，它包含了多点触控及 iOS 的支持。</p>
<p>pygame的安装非常简单，直接pip安装则可</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> pygame</span><br></pre></td></tr></table></figure>
<h2 id="pyweek游戏制作竞赛"><a class="markdownIt-Anchor" href="#pyweek游戏制作竞赛"></a> PyWeek游戏制作竞赛</h2>
<p>PyWeek 是一个用 Python 语言开发游戏的竞赛，早期多利用 Pygame 作游戏引擎，后来也有很多不同的参赛者使用 Pyglet。这项竞赛开始于 2005 年 6 月，所有游戏必须开放源代码和媒体文件，作者持有版权并以 自由软件的协议发布。</p>
<p>​如果使用者使用第三方的资源来发布游戏，必须确定第三方的资源为公开的 public domain 协议发放。因为开放源代码的特殊性，被众多游戏媒体所忽视。<br />
​<br />
因为开放源码，PyWeek 上有很多优秀的游戏代码以及游戏资源供我们参考与下载。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191101193015.png" alt="" /></p>
<p>点开其中的游戏，可以看到提供的资源文件，我们可以将其下载到本地加以学习与使用。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191101193058.png" alt="" /></p>
<h2 id="pygame基本使用"><a class="markdownIt-Anchor" href="#pygame基本使用"></a> pygame基本使用</h2>
<p>开发一款游戏，本质就是利用计算机不停的刷新屏幕(帧率)并同时判断物体方块之间有没有发生碰撞，我们游戏中的各种元素本质都是一个方块，方块的移动、碰撞就可以实现游戏元素的各种效果。</p>
<p>使用一下pygame</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">WIDTH = <span class="number">360</span></span><br><span class="line">HEIGHT = <span class="number">400</span></span><br><span class="line">FPS = <span class="number">30</span> <span class="comment"># 帧率，一秒刷新多少次</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># define colors</span></span><br><span class="line">WHITE = (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>)</span><br><span class="line">BLACK = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">RED = (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">GREEN = (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line">BLUE = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>)</span><br><span class="line"></span><br><span class="line">pygame.init() <span class="comment"># pygame初始化</span></span><br><span class="line">pygame.mixer.init() <span class="comment"># mixer在pygame中用于处理一切音频相关的东西</span></span><br><span class="line">screen = pygame.display.set_mode((WIDTH, HEIGHT)) <span class="comment"># 初始化窗口</span></span><br><span class="line">pygame.display.set_caption(<span class="string">'My Game'</span>) <span class="comment"># 标题名</span></span><br><span class="line">clock = pygame.time.Clock() <span class="comment"># 计时器，主要用于控制界面刷新的频率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在一个游戏中，通过一个元素组来表示该游戏中所有的角色</span></span><br><span class="line">all_sprites = pygame.sprite.Group()</span><br></pre></td></tr></table></figure>
<p>在代码中，我给出的了详细的注释，都是一些初始化的逻辑。我们初始化了pygame，然后初始化了mixer来处理音频相关的内容，初始化了窗口并设置了标题名，初始化了计时器，计数器主要用于控制界面刷新的频率，刷新界面的频率也称为帧率。</p>
<p>普通人在传统的显示器上 75HZ 一下就会感觉到闪烁，85Hz 以上才可以。理论上人眼有一个 0.1 秒的视觉延迟，所以通常每秒刷新 10 次以上就可以了，但实际情况是每秒刷新 24 次以上时人眼才会分辨不出来。这里我们使用了30作为帧率，在这个帧率上，人眼看见的内容就会是连贯的。</p>
<p>初始化完成后，还需要知道游戏开发的一个背景知识。</p>
<p>所有的游戏其实都是一个循环，循环中通常由三个部分组成，这三个部分分别是：事件输入、元素状态更新、绘制，不同游戏之所以不同，只是对这三个事件的处理有所不同，下面我来实现最简单的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Game loop 所有游戏都是一个循环, 循环中通常由三个部分组成，事件输入、元素状态更新、绘制</span></span><br><span class="line">running = <span class="literal">True</span></span><br><span class="line"><span class="keyword">while</span> running:</span><br><span class="line">    <span class="comment"># 让循环以正确的速度运行 - 即以正确的帧率运行</span></span><br><span class="line">    clock.tick(FPS)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># some code</span></span><br><span class="line">    <span class="comment"># 处理事件输入并实现各种相应的逻辑。</span></span><br><span class="line">    <span class="comment"># some code</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">        <span class="keyword">if</span> event.type == pygame.QUIT: <span class="comment">#如果点击 x 按钮，游戏退出，即跳出循环</span></span><br><span class="line">            running = <span class="literal">False</span></span><br><span class="line">    all_sprites.update() <span class="comment"># 更新角色</span></span><br><span class="line">    <span class="comment"># 绘制 / 渲染</span></span><br><span class="line">    screen.fill(BLACK)</span><br><span class="line">    <span class="comment"># 翻转绘画板，更新界面，绘制任何内容，都需要这个步骤，不然绘制的内容在背面，玩家是不可见的</span></span><br><span class="line">    pygame.display.flip()</span><br></pre></td></tr></table></figure>
<p>代码中有详细的注释，唯一需要解释的就是：为何需要使用「pygame.display.flip()」实现绘画的反转，为什么要以这种方式来更新界面？</p>
<p>这是为了避免界面卡顿与界面元素混乱等现象。</p>
<p>可以将屏幕想象成一张卡片，卡片的正面是我们观察到的界面，此时pygame会将下一帧要绘制/渲染的内容生成到卡片的背面，当要展示时，再将卡片翻转，此时正面变为背面，背面变为正面，pygame会将背面内容清除，然后再重新绘制。</p>
<p>运行上述代码，获得如下效果。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191101212611.png" alt="" /></p>
<h2 id="尾"><a class="markdownIt-Anchor" href="#尾"></a> 尾</h2>
<p>本节简单的介绍了Pygame相关的一些内容，此外也介绍了开发游戏的基本思路。</p>
<p>在下一篇文章中，我们将引入玩家类，看一下pygame是如何操作元素的。</p>
<p>如果文章对你有所帮助，请点「在看」给作者一点鼓励，叩谢豪恩。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>PyConChina 2019 深圳之行</title>
    <url>/blog/2019/10/21/PyConChina-2019-%E6%B7%B1%E5%9C%B3%E4%B9%8B%E8%A1%8C/</url>
    <content><![CDATA[<p>重要提示，本文只会提供关键名词，不会涉及太多技术细节，技术细节自己去深挖吧。</p>
<h3 id="在-python-中加快文件传输和文件复制-giampaolo-rodola"><a class="markdownIt-Anchor" href="#在-python-中加快文件传输和文件复制-giampaolo-rodola"></a> 在 Python 中加快文件传输和文件复制 - Giampaolo Rodola</h3>
<p>第一位上台的是来自意大利的Giampaolo Rodola，一位Python核心开发者，本来想上去尬聊的，但限于自己的英语水平，就作罢了，在这场会议上并不是每个单词都懂，但就是大致知道他在分享什么。</p>
<p>他的分享分为两大块。</p>
<p>第一部分讲了Python3.8中拷贝的底层使用了os.sendfile()或socket.sendfile()方法实现文件的拷贝，相比于旧的拷贝方式，这种方式会更快。</p>
<p>操作系统分为用户态与内核态，旧的复制文件方式会多次在用户态与内核态之间切换执行，而os.sendfile()会在内核态完成所有的操作，所以更快。</p>
<p>第二部分主要介绍了psutil，通过psutil可以实现对计算机大部分状态的监控，如cpu、内存、磁盘、进程、网络等各种状态，利用psutil其实就可以构建出一个计算机状态监控器了。</p>
<h3 id="google-sre-体系核心基础解读-刘征"><a class="markdownIt-Anchor" href="#google-sre-体系核心基础解读-刘征"></a> Google SRE 体系核心基础解读 —— 刘征</h3>
<p>第二位上台的是刘征老师(Elastic的广告)，主要讲了Google的SRE(网站可靠性工程)，SRE主要有3个东西，分别是SLA、SLO、SLI，在边听会议的时候，简单查了一下，个人感觉，这种东西更偏向于一种工作方式，感兴趣的可以搜索了解一下</p>
<h3 id="从-python-开始钱赚钱-邝泽徽"><a class="markdownIt-Anchor" href="#从-python-开始钱赚钱-邝泽徽"></a> 从 Python 开始钱赚钱 —— 邝泽徽</h3>
<p>邝泽徽老师主要分享他个人的业余项目，如何利用Python抄虚拟货币赚钱，对于做过一段时间量化的我来说，这个分享没有特别强的逻辑支持，主要使用网格策略，这种策略理论上在大波动的市场中会有比较好的效果，而虚拟货币就是一个大波动的市场，网格策略的核心逻辑就是利用波动做买入与卖出，下跌时买入，上涨是卖出，做到多次下跌买入时的平均价格小于多次上涨卖出的平均价格减去交易手续费的平均价格则可。</p>
<p>这位老师分享的项目比较随意，感觉有一些点是逻辑非自洽的，但这个分享的关键其实并不是项目本身，而是知行合一的理念，知行合一出自王阳明的阳明心学，王阳明受挫后在龙场悟道，提出了知行合一这种心学。(王阳明的书籍值得一看，我被之前棋盘公司技术经理拉坑看完了)。</p>
<h3 id="一行代码加速科学计算-解超"><a class="markdownIt-Anchor" href="#一行代码加速科学计算-解超"></a> 一行代码加速科学计算 —— 解超</h3>
<p>解超老师是位年轻人，声音洪亮的分享了Modin这个库，它可以通过一行代码加速pandas，怎么个一行法？</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">改为</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> modin.pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<p>Modin以及实现了70%的Pandas API，使用方式与Pandas完全相同。</p>
<p>Pandas之所以慢，是因为Pandas只能使用CPU的单核，Pandas不是C实现的吗？没错，但人家没有实现支持多核使用的逻辑，Modin的主要改进就是可以利用设备中所有的CPU资源，从而实现速度上的极大提升。</p>
<p>但Modin的社区是否完善？社区不完善遇到坑可是非常非常痛苦的。</p>
<p>感兴趣的可以看一下，Modin 项目仓库地址：</p>
<p><a href="https://github.com/modin-project/modin" target="_blank" rel="noopener">https://github.com/modin-project/modin</a></p>
<h3 id="数字货币交易系统架构和-python-实现-黄毅"><a class="markdownIt-Anchor" href="#数字货币交易系统架构和-python-实现-黄毅"></a> 数字货币交易系统架构和 Python 实现 —— 黄毅</h3>
<p>黄毅老师功力深厚，会议结束后，我特意找他尬聊了一会，因为没有深入研究过Redis，所以很多东西都是知识范围外的。</p>
<p>黄毅老师分享了自己构建的数字货币交易系统的架构，与传统Web系统架构不同的是，交易系统撮合的功能必须在全局顺序执行，所谓撮合就是找到卖方的最低价与买方最高价，让双方进行交易。</p>
<p>这就需要找到整个系统中的买方，然后找到整个系统的卖方，然后按顺序进行交易，这部分是无法实现并发的，即没办法多笔交易同时进行，因为每一笔交易都会影响到下一笔交易。</p>
<p>这让系统存在理论上的承载上限，无法以增加机器构建集群的方式来扩展系统。(我非常好奇A股交易系统、美股交易系统是怎么解决这问题的？)</p>
<p>黄毅老师的解决方式是使用Redis Module实现新的Redis数据类型，来满足业务逻辑，让业务逻辑全部在内存中完成。当然，数据会持久化的记录于关系型数据库中(Ticks：拼接成批量操作的SQL，增加插入数据速度)。</p>
<p>交易系统依托于Redis Module与Redis Stream(Redis 5.0以上才支持，类似与Kafka)，可以实现单核每秒十万笔交易的程度(大喊666)。</p>
<p>大佬分享了他们的流计算开源作品：<a href="https://github.com/cryptorelay/redis-aggregation" target="_blank" rel="noopener">https://github.com/cryptorelay/redis-aggregation</a></p>
<p>他们公司 Crypto 还有招聘，薪资不是一般的高，Python开发：50k-100k(经验：5-10年)。</p>
<h3 id="python-的人工智能开发在微软云中的应用-卢建晖"><a class="markdownIt-Anchor" href="#python-的人工智能开发在微软云中的应用-卢建晖"></a> Python 的人工智能开发在微软云中的应用 —— 卢建晖</h3>
<p>卢建晖老师-微软最有价值专家</p>
<p>可能是老师深藏不漏，我没有Get到演讲的神韵，虽然分享题目是人工智能这块的内容，而且大部分介绍Azure，即广告。</p>
<p>因为我做过一段时间的NLP，大致知道情况，深度学习目前对个人玩家并不友好，目前知名模型训练需要耗费巨大的算力，算力等于钱，需要上集群，这种云上免费训练，只能做一些简单模型。</p>
<p>当然我们可以利用迁移学习来使用他人已经训练好的模型，但这与分享的东西就没啥联系了。</p>
<p>此外，一个比较有意思的就是VS Code支持了Jupyter插件，可以直接在VS Code中使用Jupyter，而且更加智能方便。</p>
<p>VS Code使用Electron开发，本身又开源，其代码很值得学习，推荐一个来自淘宝前端大佬的博客，他此前一段时间的工作就是魔改VS Code，形成淘宝自己的开发工具，名为Editor，其博客如下：</p>
<p><a href="https://www.barretlee.com/blog/2019/08/03/vscode-source-code-reading-notes/" target="_blank" rel="noopener">https://www.barretlee.com/blog/2019/08/03/vscode-source-code-reading-notes/</a></p>
<h3 id="fpga-助力-python-加速计算-陈志勇"><a class="markdownIt-Anchor" href="#fpga-助力-python-加速计算-陈志勇"></a> FPGA 助力 Python 加速计算 —— 陈志勇</h3>
<p>陈志勇老师主要分享了FPGA这种可以半定制的电路，利用FPGA+编程可以实现一些有趣的效果。</p>
<p>一开始主要介绍FPGA硬件上的知识，硬件上的并行就是利用多个电子元件实现的，而单个电子元件只能实现并发的效果。</p>
<p>此外还提了函数式编程语言，陈志勇老师说在硬件上编写程序一定要有函数式编程思维，因为我只用过Erlang这一种函数式编程语言做游戏开发，所以并不太理解这句话。</p>
<p>这个分享唯一与Python相关的地方就是PYNQ库，利用PYNQ的API可以编写在该公司硬件上使用的程序，运行速度很快，原因在于PYNQ会将相应的Python语言映射为硬件设备上RTL代码，从而实现极快的运算速度。</p>
<p>除了可以使用Python编写外，还可以使用C来编写，利用Vivado HLS这个工具，可以将C语言转为RTL代码，转换的过程应该是利用了编译原理相关的知识，但转换效果没有利用PYNQ这种映射成RTL的方式好，原因在于编写的C语言没有使用硬件开发的思路来写代码，此时转为的RTL代码其实写的不好，导致效率不高，而PYNQ这种方式，以丧失灵活性的方式来实现映射后RTL代码的规范性。</p>
<p>其实很多工具代码转换的方式都会有各种各样的问题，如Unity开发游戏转为H5，H5确实可以运行，但卡的不行，手机上完全不能玩，此外Debug等各种问题也是坑。</p>
<h3 id="pipenv-和-python-包管理-明希"><a class="markdownIt-Anchor" href="#pipenv-和-python-包管理-明希"></a> Pipenv 和 Python 包管理 —— 明希</h3>
<p>明希老师主要分享了Python虚拟环境以及包管理的一些内容，内容很细，一开始主要分享了安装包的正确方法以及各种各样的坑。</p>
<p>随后介绍了Pipenv，简单说了依赖解析问题与相应的解决方法。</p>
<p>最后说了一下为了Python包管理未来可能出现的方式，涉及了PEP517、PEP518草案，说的其实就是Node.js利用npm管理包那套，像npm那样，你可以选择将依赖库安装全局也可以安装到当前项目的目录下，安装在当前项目目录，只会被当前项目使用，利用这种方式就不用理会虚拟环境的问题了。</p>
<p>然后介绍了PyFlow这一个工具，可以实现PEP517、PEP518草案的效果，地址为：</p>
<p><a href="https://github.com/David-OConnor/pyflow" target="_blank" rel="noopener">https://github.com/David-OConnor/pyflow</a></p>
<p>但npm本身也有各种问题，在2019的JSconfEU上提出了Tink下一代包管理器技术，意在取代npm。</p>
<h3 id="闪电演讲"><a class="markdownIt-Anchor" href="#闪电演讲"></a> 闪电演讲</h3>
<p>每个演讲大概10分钟</p>
<h4 id="python-c-拓展在各平台的打包与发布-赵丰"><a class="markdownIt-Anchor" href="#python-c-拓展在各平台的打包与发布-赵丰"></a> Python C 拓展在各平台的打包与发布 —— 赵丰</h4>
<p>赵丰老师介绍了在CI(Continuous Integration，持续集成)环境自动打包Python C拓展库的方法。</p>
<p>构建Python C拓展包与构建纯Python包不同，需要涉及到编译的流程。在Linux中，随便编译的C拓展库是无法上传到官方的，这里Python官方给出了一个centos6.1环境的Docker，必须在这个Docker的Linux下打的包才能上传。</p>
<h4 id="为-python-function-自动生成-web-ui-彭未康"><a class="markdownIt-Anchor" href="#为-python-function-自动生成-web-ui-彭未康"></a> 为 Python Function 自动生成 Web UI —— 彭未康</h4>
<p>彭未康老师介绍了自己开发的工具Touch-Callable，构建于Flask之上，可以快速的通过一个方法构建出一个web界面，方便测试人员使用，比较简单，效果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># examply.py</span></span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 开关<span class="params">(Enum)</span>:</span></span><br><span class="line">  开 = <span class="string">'开'</span></span><br><span class="line">  关 = <span class="string">'关'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> 饮水机<span class="params">(口令: str, 制热: 开关=None, 制冷: 开关=开关<span class="params">(<span class="string">'开'</span>)</span>)</span>:</span></span><br><span class="line">  <span class="string">"""这是 20618 的！"""</span></span><br><span class="line">  <span class="keyword">if</span> 口令 != <span class="string">'多喝热水'</span>:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">'你是谁，我不认识你'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 省略具体逻辑</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191021153506.png" alt="" /></p>
<p>github：<a href="https://github.com/pengwk/touch-callable" target="_blank" rel="noopener">https://github.com/pengwk/touch-callable</a></p>
<h4 id="数字货币交易系统-python-实践-代少飞"><a class="markdownIt-Anchor" href="#数字货币交易系统-python-实践-代少飞"></a> 数字货币交易系统 Python 实践 —— 代少飞</h4>
<p>介绍了开发交易系统时会遇到的问题以及给出的解决方法，这些解决方法出乎意料的朴素简单，并没有涉及什么高深技术。</p>
<p>此外还介绍了APScheduler这一个定时任务库(因为他们的系统中使用了)，这个库有比较多的概念，有兴趣可以看一下：</p>
<p><a href="https://github.com/agronholm/apscheduler" target="_blank" rel="noopener">https://github.com/agronholm/apscheduler</a></p>
<p>但如果只是单纯的定时任务，其实并不建议使用apscheduler，它会增大系统的复杂度，直接使用crontab简单粗暴。</p>
<h4 id="django-实现后端低代码开发平台-jeff"><a class="markdownIt-Anchor" href="#django-实现后端低代码开发平台-jeff"></a> Django 实现后端低代码开发平台 —— Jeff</h4>
<p>low-code(低代码)，简单而言就是通过不写或少写代码的方式来构建一个系统，jeff老师将其分为3个阶段，第一个就是像 Django Admin那样，写少量代码，实现web功能，第二个阶段就是通过配置文件来构建web系统，例如通过JSON文件构建一个web系统，第三个阶段，就是通过界面配置来构建一个web系统。</p>
<p>但我个人觉得，第三阶段应该是以可拖动式的方式来构建一个web系统。因为通过界面配置其实本质依旧是生成一个JSON文件，如果逻辑要变动，还是需要手写逻辑，不够灵活，而目前我知道的商用low-code平台是利用类似逻辑图的结构来构建无代码构建web平台的目的(很多量化平台其实也有类似的东西，如bigquant)。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191021153451.png" alt="" /></p>
<p>通过界面拖动的方式，会更加灵活，可以自己构建各种逻辑，但操作复杂度也变大，很多时候构建一个web，如构建后台，通过配置来构建更佳，因为大多数时候都是增删改查，没有什么特别的逻辑。</p>
<h2 id="尾"><a class="markdownIt-Anchor" href="#尾"></a> 尾</h2>
<p>这其实是我第一次参数这种会议，因为此前自己粗浅的认为，会议没有什么意义，一天能学什么？所以都没有怎么参加，但这次参加感觉很不错，认识了几位新朋友，开阔了一下眼界，这就是会议的意义。</p>
<p>最后，感谢你的阅读，如果内容对你有点帮助，麻烦点一下「好看」，那是可以点击的，谢谢。</p>
]]></content>
      <tags>
        <tag>Python,随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>如果我来做个「ZAO」换脸app，全网最硬核换脸技术简析(万字长文)</title>
    <url>/blog/2019/10/21/%E5%A6%82%E6%9E%9C%E6%88%91%E6%9D%A5%E5%81%9A%E4%B8%AA%E3%80%8CZAO%E3%80%8D%E6%8D%A2%E8%84%B8app%EF%BC%8C%E5%85%A8%E7%BD%91%E6%9C%80%E7%A1%AC%E6%A0%B8%E6%8D%A2%E8%84%B8%E6%8A%80%E6%9C%AF%E7%AE%80%E6%9E%90-%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87/</url>
    <content><![CDATA[<h1 id="如果我来做个zao换脸app全网最硬核换脸技术简析万字长文"><a class="markdownIt-Anchor" href="#如果我来做个zao换脸app全网最硬核换脸技术简析万字长文"></a> 如果我来做个「ZAO」换脸app，全网最硬核换脸技术简析(万字长文)</h1>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>最近，一款名为「ZAO」的AI换脸应用火爆了起来，在各大网站和朋友圈都看见它的身影，它可以通过用户上传的一张带有人脸的照片替换到视频的人脸中，效果非常逼真，引起轰动。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902162753.png" alt="" /></p>
<p>因为「ZAO」团队并没有公开该软件使用的技术，所以我无法确切的判断「ZAO」使用了什么具体的技术，而本篇文章的重点不是剖析「ZAO」应用的技术，而是介绍如何通过已知的技术实现一个自己的「ZAO」，简而言之，就是分析当前的换脸技术。</p>
<p>本篇文章会尝试使用最简单的语句让大家理解其中的关键概念，会从最基本的神经网络开始介绍，让没有任何概念的朋友可以轻易食用。</p>
<p>大致内容：</p>
<ul>
<li>(1)什么是神经网络？</li>
<li>(2)怎么训练神经网络？</li>
<li>(3)使用卷积神经网络识别图像</li>
<li>(4)MTCNN人脸检测技术</li>
<li>(5)VAE与GAN简介
<ul>
<li>变分自动编码器VAE简介</li>
<li>生成对抗网络GAN简介</li>
</ul>
</li>
<li>(6)Pix2Pix替换人脸</li>
<li>(7)CycleGAN替换人脸</li>
<li>(8)Faceswap-GAN换脸应用</li>
<li>(9)一张图像实现视频换脸</li>
<li>(10)这种技术带来的威胁</li>
<li>(11)AI对AI，识破假视频
<ul>
<li>使用循环神经网络识别视频</li>
<li>通过眨眼生理信号识别视频</li>
<li>通过肖像中的生物信息识别视频</li>
</ul>
</li>
<li>(12)结尾</li>
<li>(13)参考</li>
</ul>
<p>别慌，你是可以懂的。</p>
<p>文章前半部分的内容都是用于铺垫，从而让你有背景知识可以明白换脸究竟是怎么回事。</p>
<p>注意文章标题，使用「简析」，即只能简单的分析，因为细节之多，一文难以全部叙述完，这里尽量不涉及太多细节与公式推导，但这也会带来一定的「知识失真」。</p>
<p>文章的图像、训练数据、代码、Paper等，都会在最后一节参考中给出。</p>
<h2 id="1什么是神经网络"><a class="markdownIt-Anchor" href="#1什么是神经网络"></a> 1.什么是神经网络？</h2>
<p>神经网络(Neural Network,NN)是一种数据模型，更具体而言，就是一个函数。</p>
<p>在20世纪，心理学家McCulloch和数学家Pitts受生物神经元结构的启发提出了MP模型。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190901212730.png" alt="" /></p>
<p>MP模型抽象简化了生物神经元结构的细节，它的出现为神经网络打下了一个基础。</p>
<p>生物神经元会接收到其他神经元的电信号输入，在进行简单的处理后，会将处理后的信息传递给其他生物神经元，而MP模型也一样，它会接受到其他模型的信号<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_1,...,x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，然后与权重相乘，并通过某个函数运算后获得新的信号<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>O</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">O_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，最后将其传递给下一个神经元，公式如下：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>o</mi><mi>j</mi></msub><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">o_j = f(\sum_{i=0}^n(w_{ij}x_i)) 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p>
<p>MP模型可以算是最初的开始，但与现在的神经网络有非常大的差异，现在的神经网络中通常会涉及神经元、层与权重的概念，一个简单神经网络模型如下：</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190901214156.png" alt="" /></p>
<p>图中的每个圆，可以看做是一个「神经元」，每个神经元本身可以看做是一个函数，神经元被多个带箭头的线连接，这些线表示着数据流向，即函数的输入数据与输出数据的流向。</p>
<p>从图中也可以看出，多个神经元会组成列，每一列中的神经元是没有被带箭头的线相连接的，这其实就构成了「层」。</p>
<p>通常，不同的「层」会因功能不同而叫法不同，如神经网络的第一层，通常称为「输入层」，因为第一层要负责接收外面数据的输入，而神经网络中的最后一层，通常称为「输出层」，因为会将整个神经网络处理后的数据输出，而「输入层」与「输出层」之间的层，就称为「隐藏层」。</p>
<p>权重，就是带箭头线上的值，某个神经元输出的内容会与对应的权重做运算，运算的结果会作为下一层中某个神经元的输入。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190901215558.png" alt="" /></p>
<h2 id="2怎么训练神经网络"><a class="markdownIt-Anchor" href="#2怎么训练神经网络"></a> 2.怎么训练神经网络？</h2>
<p>简单明白了神经网络的结构后，接着要思考的问题是，人们常说的训练神经网络是什么？要怎么才能训练神经网络？</p>
<p>训练神经网络分为大体可以分为2大阶段，第一个阶段，称为「前向传播」，第二阶段称为「反向传播」。</p>
<p>在前向传播阶段中，数据会从输入层一直向下一层传递，直到传递到输出层，然后输出一个结果，前向传播的本质就是矩阵运算，依旧是该图。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190901215558.png" alt="" /></p>
<p>从图中可以看出，该神经网络具有一个输入层，由3个神经元组成，有一个隐藏层，由4个神经元组成，最后就是输出层，由2个神经元组成。</p>
<p>首先输入层会接收到要输入神经网络的数据，输入层会对其进行预处理，使输入数据成为3维的列向量，因为输入层只有3个神经元。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>O</mi><mn>0</mn></msub><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O_0 = f(x) 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>为输入层的数据预处理函数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>O</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">O_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为输入层预处理后得到的3维列向量。</p>
<p>随后，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>O</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">O_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>会与权重矩阵相乘，其结果传递给相应的激活函数，获得结果。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>O</mi><mn>1</mn></msub><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>W</mi><mn>1</mn></msub><mo>∗</mo><msub><mi>O</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O_1 = f(W_1 * O_0) 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>这里的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>函数表示的是隐藏层的激活函数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>O</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">O_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是输入层的输出数据，这里作为隐藏层的输入数据传入，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>W</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">W_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是隐藏层的权重矩阵，公式运算的结果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>O</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">O_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>就是隐藏层的输出。从上面的神经网络结构图可以看出权重矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>W</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">W_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是一个4*3的矩阵。</p>
<p>最后，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>O</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">O_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>会作为输出层的输入，经过类似的运算获得该神经网络的最终输出结果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>O</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">O_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>O</mi><mn>2</mn></msub><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>W</mi><mn>2</mn></msub><mo>∗</mo><msub><mi>O</mi><mn>1</mn></msub><mo>+</mo><msub><mi>b</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O_2 = f(W_2 * O_1 + b_2) 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>W</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">W_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为输出层的权重矩阵，从上图可以看出它是一个2*4的矩阵。</p>
<p>可以总结出前向传播算法普遍公式：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>O</mi><mi>i</mi></msub><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>W</mi><mi>i</mi></msub><mo>∗</mo><msub><mi>O</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>b</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O_i = f(W_i * O_{i-1} + b_i) 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>当前向传播阶段的矩阵计算完成后，神经网络会输出一个结果，这个结果并不一定是正确的结果，这是当前神经网络输出的结果，比如，输入的数据是一张人手写的数字1时，我们希望神经网络可以输出数字1作为结果，但神经网络并不一定会按我们的期望输出1，它更大的概率是输出其他的内容。</p>
<p>为了让神经网络输出正确结果，就要量化的表示出当前的输出结果与正确结果之间的差距，这种差距通常称为损失，比如，正确结果是数字1，而神经网络输出的数字9，此时数字1与数字9之间就有一个损失，定义损失的方式有很多种，会涉及不同的损失函数，比较常见的有均方差损失(MSE)、交叉熵损失等。</p>
<p>有了损失后，就需要进行反向传播，所谓反向传播其实就是损失反向传递到神经网络的神经元中，调整带线箭头中的权重，这样的调整最终会影响到神经网络的输出。</p>
<p>在反向传播的过程中，有分为2大步骤，第一步是利用反向传播算法去计算每个神经元对最终损失的贡献度，这个贡献度通常被称为「梯度」，第二步就是通过梯度下降算法将「梯度」运用到不同神经元上，从而实现对其权重的修改。</p>
<p>这里需要强调一下，反向传播算法仅指计算梯度的方法，而随机梯度下降才是使用梯度进行学习的，这点很多博客与书籍都混淆了。如有疑问，请阅读Lan Goodfellow等人著的经典书籍《Deep Learning》的「6.5 反向传播和其他的微分算法」章节内容。</p>
<p>因为反向传播过程涉及较多微积分(偏导数、方向导数等)概念，本文不再深究。</p>
<p>简单总结，神经网络的输入层会接收到输入的数据，然后通过「前向传播」的过程获得一个输出值，将输出值与标准答案进行「损失」的计算，接着将计算出的损失通过「反向传播」的过程作用到神经网络的神经元上，改变神经网络中的结构，我们可以将神经网络整体看成一个函数f，改变其中神经元的权重，相当于改变了函数f的参数，一个函数的参数被改变了，其输出的结果当然也会跟着改变，而这种改变是有方向性的，每次的改变是为了让神经网络输出的值更接近与正确值，通过成千上万次的训练，每次都会通过相同的方式去修正神经网络的参数，最终获得一个可以输出正确值的神经网络模型，这个过程就是完整的训练过程。</p>
<p>需注意，文中的「反向传播」指的是一个过程，包含使用「反向传播算法」与「梯度下降算法」的过程，而不是指「反向传播算法」。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190901230104.png" alt="" /></p>
<p>注意，本节谈及的「训练」只指有监督学习中的训练。</p>
<h2 id="3使用卷积神经网络识别图像"><a class="markdownIt-Anchor" href="#3使用卷积神经网络识别图像"></a> 3.使用卷积神经网络识别图像</h2>
<p>卷积神经网络(Convolutional Neural Network, CNN)是一种擅长处理图形数据的神经网络结构，深度学习中很多图像识别、图像处理相关的应用都有CNN的影子。</p>
<p>对于一张图像，我们人类可以很快的识别出图像中的东西，但对于于计算机来说，它们看到的只是一堆数字，根本不能直观的理解这些数学背后表示的图像。要让计算机可以识别图像，第一步要做的就是让计算机可以理解代表图像的这些数字，如下图，我们可以很快的看出图中有三只短腿小狗，而计算机却不能。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190901235119.png" alt="" /></p>
<p>解决这个问题的灵感也来自于生物本身，生物是怎么「理解」看见世界的？对生物而言，它们看到的只是光线照射到某个物体上带来的像素信息，这些信息并没有告诉我们图中有3只小狗。</p>
<p>其中的关键在于，生物可以很轻松的通过很底层的基础信息获得这些信息背后的抽象认知，如人类看见小狗的图像其实就是对大量像素信息这一类底层信息抽象得到图中小狗的。</p>
<p>而卷积神经网络(CNN)原理其实也是这样，将信息抽象成更高的信息，然后更高的信息再进一步抽象。</p>
<p>简单而言就是通过一种叫做过滤器的矩阵(本质就是一个二维数组)与图像中的数据进行运算，获得抽象层，抽象层中的信息就是更高一层的信息，然后以同样的方式再通过过滤器与当前抽象层进行运算，获得下一个更高信息维度的抽象层。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190901235818.png" alt="" /></p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190901235830.png" alt="" /></p>
<p>这样，一层层的将信息抽取出来，最终获得可以判断当前物体是什么的信息。</p>
<p>例如，要「看见」图像中的建筑，一开始输入的建筑图像对计算机而言只是一堆看似无用的数字，然后通过一层层的抽象，如第一层抽象，从无用的数字中过滤出了线条，然后再抽象，从线条这个抽象层中抽象出了矩形，然后再抽象，获得长方体，最终获得建筑的轮廓。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902000404.png" alt="" /></p>
<p>具体怎么做到的？</p>
<p>比如要判断图中是否存在老鼠，首先定义出一个过滤器矩阵，它可以从原始图像数据中判断出曲线。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902000543.png" alt="" /></p>
<p>接着让过滤器扫描老鼠图像。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902000634.png" alt="" /></p>
<p>如果曲线过滤器在图像中遇到了曲线，则进行矩阵点积运算时，会获得一个比较大的值，作为下一层中某个神经元的输入。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902000709.png" alt="" /></p>
<p>如果曲线过滤器遇到其他形状，此时矩阵点积运算时，会获得一个较小的值。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902000827.png" alt="" /></p>
<p>通过曲线过滤器完整扫描完老鼠图像后，就获得曲线的抽象层了，上面只演示了一种过滤器的情况，一般会有多个基本的过滤器去扫描图像，从而获得不同的特征(卷积层的深度就是过滤器的个数x过滤器的深度)。</p>
<p>这里只是提及了卷积神经网络的大致原理，要深入理解，还需要理解卷积层、池化层/采样层、步数、填充等概念。</p>
<h2 id="4mtcnn人脸检测技术"><a class="markdownIt-Anchor" href="#4mtcnn人脸检测技术"></a> 4.MTCNN人脸检测技术</h2>
<p>要实现换脸，通常第一步就要检测出图像中人脸的位置，而视频中人脸的检测与在图像中检测的原理是相同的，只是视频需要逐帧去检测。</p>
<p>人脸检测的方式有多种，这里主要介绍MTCNN，主要是因为Faceswap-GAN这款开源的换脸应用使用了MTCNN，其基础就是CNN识别图像中的数据。</p>
<p>MTCNN(Multi-task Cascaded Convolutional Networks)是2016年提出的人脸检测模型，它由3个CNN构成，3个不同的CNN负责不同的功能，实现对图像中的人脸进行检测和特征点的识别。</p>
<p>这3个CNN在MTCNN的论文中分别被称为P-Net、R-Net与O-Net。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902095153.png" alt="" /></p>
<p>上图表明了MTCNN的大致流程：</p>
<p>(1)构成图像金字塔(Image Pyramid):重塑输入的图像，获得不同尺寸的图像，将不同尺寸的图像从大到小的堆叠在一起，类似于金子塔形状，这一步相当于数据的预处理，将原始的图像数据处理成图像金字塔，再使用该数据进行训练。</p>
<p>(2)第一步：使用提案网络(Proposal NetWork, P-Net)获取图像中所有可能含有人脸的部分，即绘制出候选边界框(Proposal Bounding boxes，直译为提案边界框，为了方便理解，这里使用候选边界框，两者含义相同)，这些边界框由相应的算法完整扫描完图像后产生，通常会产生非常多的边界框，这是为了避免图像中人脸很小或者人脸没有完全显示等各种情况以及这样可以增强神经网络的鲁棒性，接着使用了NMS(非极大值抑制算法)或Bounding-box regression(边框回归)去除多余的框，从而得到初步的人脸检测候选边界框。这一步是MTCNN中最耗时的，也是MTCNN慢的原因。</p>
<p>(3)第二步：将P-Net获得的人脸图像输入到精细网络(Refinement NetWork, R-Net)中，R-Net会进一步去除多余的框，从而得到更加精细准确而且冗余更少的候选框。</p>
<p>(4)第三步：将R-Net获得的人脸图像输入到输出网络(Output Network, O-Net)中，O-Net进一步对人脸候选框进行细化，并且绘制出人脸中的5个关键点(左眼、右眼、鼻子、左嘴角、右嘴角)对应的坐标。</p>
<p>MTCNN训练时，第一步会消耗大约整个训练过程中3/4的时间，是非常耗时的，其原因在于：</p>
<ul>
<li>1.要生产图像金字塔，这需要扫描完整的图像，然后逐个运算生产；</li>
<li>2.生产图像金子塔后，每种不同尺寸的图像都要输入模型进行训练，这相当于一张原始图像要进行多次模型的推断；</li>
</ul>
<p>已经有一些方法被提出，尝试改善训练的耗时。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902111637.png" alt="" /></p>
<p>上图总结了几种多尺度对象提案网络(Multi-scale Object Proposal Network)的方式，MTCNN第一步使用的就是其中的(a)。</p>
<p>目标检测的本质其实就是图像目标区域内容的特征与学习模板权重这两个矩阵之间的点积运算，如果学习模板的尺寸与目标区域的尺寸匹配，就会有比较高的识别率。</p>
<p>而上图中的(a)，构成图像金字塔，目的是通过图像的多次缩放，实现训练单个分类器可以匹配所有不同尺寸大小的图像，这种策略需要在多个图像尺寸间进行特征计算，运算量大，导致运行慢。</p>
<p>所以就有另一种方法，即使用多个分类器应用于单个输入的图像，如上图中的(b)，这种方式避免了重复的特征计算，但检测效果并不好。</p>
<p>随后就有综合(a)、(b)两种方法的©，即减少图像缩放的次数以及增加分类器的个数。</p>
<p>更进一步，如上图中的(d)，先进行少量的缩放，然后自行插入缺失的特征映射，这种方式相当大程度的加快了运行速度并且也可以获得适度的精确度。</p>
<p>上图中还有多种方法，感兴趣可以阅读参考小结中的「论文2」。</p>
<p>MTCNN的训练方式与第二节中介绍的训练方式一样，MTCNN人脸检测网络主要使用了WIDERFace开源人脸检查数据，该数据提供了不同类别的人脸图像数据，这些图像中的人脸都被标注出了正确位置，这并不是指，图像中存在绿色人脸标记框，而是每张图像有对应标签，标签中包含了当前图像中，人脸标记框的左上角坐标以及标记框的宽与高，通过标签中的这些数据可以绘制出标记框。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902103043.png" alt="" /></p>
<p>MTCNN训练时，会获取WIDERFace中的人脸图像数据，然后尝试给出图像中人脸的标记框，接着计算这个标记框的位置与当前输入图像对应标签中真实标记框的位置的损失，通过损失来完善MTCNN模型，直到MTCNN可以标记出人脸的位置。</p>
<p>MTCNN除了可以标记人脸，还可以获得人脸中的5个关键点，它使用了CNN_FacePoint数据集中的人脸数据。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902104910.png" alt="" /></p>
<p>训练原理是相同的。</p>
<p>3个CNN的大致结构如下(有相关经验的人可以明白其大致网络结构，不明白的跳过则可)</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902132140.png" alt="" /></p>
<h2 id="5vae与gan的简介"><a class="markdownIt-Anchor" href="#5vae与gan的简介"></a> 5.VAE与GAN的简介</h2>
<p>了解了人脸检测后，接着就是人脸生成了，更广义的说，其实就是图像生成，而变分自编码器(Variational Auto-Encoder，VAE)与生成对抗网络(Generative Adversarial Network，GAN)是这一领域的好手。</p>
<h3 id="变分自编码器vae简介"><a class="markdownIt-Anchor" href="#变分自编码器vae简介"></a> 变分自编码器VAE简介</h3>
<p>先从VAE开始，要理解VAE，有必要理解AE(Auto-Encoder，自编码器)，所谓Auto-Encoder其实很好理解，它的本质依旧是一个神经网络，只是这个神经网络有编码器(Encoder)、Bottleneck(瓶口)与解码器(Decoder)构成。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902133904.png" alt="" /></p>
<p>输入真实的图像数据给编码器Encoder进行编码操作，所谓编码操作可以理解成抽取图像数据中的特征信息，相当于做了一个压缩的过程，这些特征信息的数据量会明显少于原始图像的数据量，抽取出的特征数据会放在Bottleneck中。</p>
<p>Bootleneck并不会做什么处理，只是用于存储特征数据的网络结构，它会将数据直接传递给解码器Decoder，解码器就会尝试利用这些特征信息还原会图像数据，即从少量关键数据中还原出原始的图像(这个过程也被称为重构)。</p>
<p>自编码器的训练过程也很好理解，一开始整个自编码器网络还原出的数据会与原本传入的真实数据存在较大的差距，这就是损失，通过「反向传播过程」去优化整个网络结构，让损失最小则可(但通常难以获得全局最优值，只是获得局部最优)。</p>
<p>这种神经网络能干什么？</p>
<p>将一个图像编码后又解码，似乎没什么作用？</p>
<p>非也，Google就尝试使用这种简单的技术来提升自己的服务质量。</p>
<p>比如，现在要看一张高清大图，服务器直接将大图数据传递过去会耗费大量的带宽，用户也需要较长时间去等待图像的加载。</p>
<p>此时就可以训练好一个自编码器，将自编码器的结构简单拆分，服务器上用编码器对原始图像进行编码获得特征信息，服务器只需要将少量的特征信息传递给用户的客户端，而客户端就可以使用解码器，通过少量的特征数据运算还原出高清大图了，虽然此图非彼图，通过这种方式，就可以减少宽带的使用。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902134719.png" alt="" /></p>
<p>其实稍微调整一下思路，就可以获得一个可以去除图像杂质或马赛克的网络，如下图：</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902134834.png" alt="" /></p>
<p>上图中，并没有直接向编码器中传入原始的正常图像数据，而是传入添加了噪音的数据，然后再通过自编码器还原数据，而还原数据直接与原始的正常图像数据做损失运算，这样训练出来的自编码器就具有去除噪音的能力了，而去除马赛克的思路是完成相同的。</p>
<p>但现实是残酷的，这种方式虽然简单，但模型的泛化能力并不好，还原后的图像还是有较大的瑕疵。</p>
<p>自编码器无法「创造」逼真的图像数据，我们训练的时候，都是给出一张图像，然后它会还原出一张图像，但是它无法「创造」，所以出现了变分自编码器。</p>
<p>变分自编码器与自编码器不同之处仅在于Bottleneck向量处，它相比自编码多了均值向量(mean vector)与标准差向量(standard deviation vector)。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902160546.png" alt="" /></p>
<p>VAE经过一定的训练后，就可以向均值向量与标准差向量定义出的样本空间进行采样，将采样获得的数据传入解码器，此时解码器就会通过解码还原数据，此时还原出的数据是真实世界中不存在的，这是因为我们传入给解码器的特性信息是从采样空间随机采样的，并不是某张真实图像的特征信息。</p>
<p>通常，在训练VAE时会约束均值向量与标准差向量构成的样本空间分布，使其服从正态分布，即均值向量为0，标准差向量为1。这一点从它的损失函数也可以看出(神经网络输出的值与真实值的损失通过某个函数来定义，这个函数被称为损失函数)。</p>
<p>VAE损失函数如下：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">L</mi><mo stretchy="false">(</mo><mi>θ</mi><mo separator="true">,</mo><mi>ϕ</mi><mo separator="true">;</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>E</mi><msub><mi>q</mi><mi>ϕ</mi></msub></msub><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><mi>g</mi><msub><mi>p</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>−</mo><msub><mi>D</mi><mrow><mi>K</mi><mi>L</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>q</mi><mi>ϕ</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><msub><mi>p</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{L}(\theta,\phi;x) = E_{q_{\phi}}[log p_{\theta}(x|z)] - D_{KL}(q_{\phi}(z|x) || p_{\theta}(z))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal">L</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">ϕ</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1030799999999998em;vertical-align:-0.35307999999999995em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139199999999997em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">ϕ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29011428571428566em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35307999999999995em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span><span class="mord mathdefault mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">ϕ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p>
<p>如果有信息论基础的朋友可以看出，VAE的损失函数由一个期望值与KL散度这两部分构成，其中KL散度的目的就是约束样本空间，使其服从正态分布。</p>
<p>对于VAE的很多细节，这里展示不去讨论。</p>
<p>有了上面的概念，就可以来讨论如何使用自编码器(AE)来替换人脸了。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902161809.png" alt="" /></p>
<p>从图中可以看出，我们需要通过两堆不同的数据训练两个AE，一个AE用于自动编码女孩照片数据，第二个AE用于自动编码尼古拉斯·凯奇(那个男孩)的照片数据，但需要注意的是，两个AE的编码器共享的部分参数，这样做会让编码器找出两堆不同数据的共同特征。</p>
<p>完成训练流程后，使用编码器对女孩的数据进行编码，获得对应的编码器特征，因为训练时，共享了部分参数，所以这些特征中包含了一些共同的特征，此时再用解码器去解码这些特征，就会获得一个换脸后的人了。</p>
<p>这样之所以可行是因为人脸有很多潜在的相同特征，如眼睛的数量位置、鼻子的数量位置等等，通过共享参数的方式，让两个AE的编码器中的部分参数共享，让其可以找到人脸图像中共同的特征数据，此时使用不同的解码器就实现了人脸的替换。</p>
<p>但AE或VAE有一个致命的缺陷就是生成的图像会比较模糊，下面来讨论一下生成对抗网络GAN。</p>
<h3 id="生成对抗网络gan简介"><a class="markdownIt-Anchor" href="#生成对抗网络gan简介"></a> 生成对抗网络GAN简介</h3>
<p>生成对抗网络(Generative Adversarial NetWork，GAN)的核心思想很简单，传统的GAN其神经网络主要有生成网络(Generator Network)与判别网络(Discriminator Network)构成，两者相互对抗、博弈，最终让生成器(生成网络的别名)可以生成逼真的图像。</p>
<p>举个具体的例子，明白其原理。</p>
<p>小吕是艺术学院的学生，廖老师是学校的老师。</p>
<p>小吕虽然考入的艺术学院，但绘画能力还比较差劲，而廖老师看过很多优秀的画作，知道优秀的画作应该具有什么特点。</p>
<p>小吕每天画一副画交个廖老师看，廖老师会更具自己的经验给出其改进意见，小吕会吸取这些经验，在明天将画画的更好，就这样，小吕一天天的进步，直到一天画出的画与廖老师印象中的名画没有明显的差异时，小吕就算出师了。</p>
<p>GAN也就是这样，其中生成器就是小吕，而判别器就是廖老师，一开始，生成器获取一堆噪音数据(即无用的随机生成的数据)去生成一张图像，生成的图像会交给判别器判别真假，即判别器会根据自己的经验判断传入的这张图像是真实存在的图像还是生成的图像。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902204659.png" alt="" /></p>
<p>一开始，判别器自己并没有「真实图像」的概念，它同样是通过训练来获得这样的概念的，具体而言就是将真实图像作为判别器的输入，让判别器输出1，通过一轮训练后，判别器此时就有了「真实图像」的简单概念了。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902204910.png" alt="" /></p>
<p>生成器的目标其实就是让自己生成的图像与真实图像相似，从而让判别器无法判别出自己生成的图像是真实图像还是生成图像。</p>
<p>GAN大致训练流程如下，以训练GAN生成图片为例</p>
<p>第一步：初始化生成器和判别器，模型结构中的参数随机生成则可<br />
第二步：在每一轮训练中，执行如下步骤：</p>
<ul>
<li>1.固定生成器的参数，训练判别器的参数，让判别器有「真实图像」的概念，具体而言
<ul>
<li>1.1 因为生成器的参数被固定了，此时生成器的参数没有收敛，生成器通过未收敛参数生成的图片就不会特别真实</li>
<li>1.2 从准备好的图片数据库中选择一组真实图片数据</li>
<li>1.3 通过上面两步操作，此时就有了两组数据，一组是生成器生成的图片数据，另一组是真实图片数据，通过这两组数据训练判别器，让其对真实图片赋予高分，给生成图片赋予低分</li>
</ul>
</li>
<li>2.固定判别器，训练生成器，让生成器在判别器的指导下优化自己，具体而言
<ul>
<li>2.1 随机生成一组噪声喂养给生成器，让生成器生成一张图片</li>
<li>2.2 将生成的图片传入判别器中，判别器会给该图片一个分数，比如0.22，生成器的目标就是使这个分数更高，生成出判别器可以赋予高分的图片</li>
</ul>
</li>
</ul>
<p>GAN简化后的训练过程如下图</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902205348.png" alt="" /></p>
<p>图中有3种线，分别是：</p>
<ul>
<li>黑线虚线：真实数据的分布。</li>
<li>蓝色虚线：判别器的判别分数</li>
<li>绿线：生成器生成的数据分布</li>
</ul>
<p>从图中可以看出，一开始(图a)，代表真实数据分布的黑虚线与代表生成数据分布的线差异较大，此时代表判别器分数的蓝虚线可以比较准确的判断出真实数据和生成数据，它给真实数据赋予了较高的分值，而给生成数据赋予较低的分值。</p>
<p>随着GAN训练次数的增加，生成器为了生成出可以让判别器赋予高分的数据，生成器生成数据的分布渐渐向真实数据的分布靠拢(图b-c)，当生成器完全学习到真实数据的分布情况时，判别器就无法分辨他们的了，也就是无论是真实数据还是生成数据都赋予相同的分数(图d)。</p>
<p>上图中，真实数据的分布是从判别器学习而来的，所以在训练GAN时要先训练判别器，让其获得真实数据的分布作为一个“标准”。</p>
<p>从数学角度来解释：</p>
<ul>
<li>1.从数据库中拿出真实数据x，将其放到判别器中D(x)，目标是让其D(x)输出的值接近1。</li>
<li>2.输入随机噪音z给生成器G(z)，生成器希望判别器给自己生成的数据输出的值接近1，D(G(z)输出接近1，而判别器希望自己给生出数据输出的值接近0，D(G(z))输出接近0。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902205511.png" alt="" /></p>
<p>通过公式表达，就可以获得GAN的公式：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>G</mi></msub><mi>m</mi><mi>a</mi><msub><mi>x</mi><mi>D</mi></msub><mi>V</mi><mo stretchy="false">(</mo><mi>D</mi><mo separator="true">,</mo><mi>G</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>E</mi><mrow><mi>x</mi><mo>∼</mo><msub><mi>P</mi><mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow></msub></mrow></msub><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>D</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>+</mo><msub><mi>E</mi><mrow><mi>z</mi><mo>∼</mo><msub><mi>P</mi><mi>z</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>D</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">min_G max_D V(D,G) = E_{x \sim P_{data}}[log D(x)] + E_{z \sim P_z(z)}[log (1-D(G(z)))]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00586em;vertical-align:-0.25586em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.55em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">∼</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25586em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="mrel mtight">∼</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span></span></p>
<p>上述公式中，将D定义为判别器，G定义为生成器。</p>
<p>将上面公式拆分来看：</p>
<p>先看前半段，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mrow><mi>x</mi><mo>∼</mo><msub><mi>P</mi><mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow></msub></mrow></msub><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>D</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">E_{x \sim P_{data}}[log D(x)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00586em;vertical-align:-0.25586em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.55em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">∼</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25586em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mrow><mi>x</mi><mo>∼</mo><msub><mi>P</mi><mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow></msub></mrow></msub></mrow><annotation encoding="application/x-tex">E_{x \sim P_{data}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93919em;vertical-align:-0.25586em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.55em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">∼</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25586em;"><span></span></span></span></span></span></span></span></span></span>表示期望x从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow></msub></mrow><annotation encoding="application/x-tex">P_{data}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>分布中获取，x表示真实数据，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow></msub></mrow><annotation encoding="application/x-tex">P_{data}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示真实数据的分布，这段公式的意思是：判别器要判别出真实数据的概率，判别器的目标就是要最大化这一项。</p>
<p>接着看后半段，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mrow><mi>z</mi><mo>∼</mo><msub><mi>P</mi><mi>z</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>D</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">E_{z \sim P_z(z)}[log (1-D(G(z)))]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="mrel mtight">∼</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mrow><mi>z</mi><mo>∼</mo><msub><mi>P</mi><mi>z</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">E_{z \sim P_z(z)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="mrel mtight">∼</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span>表示期望z从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>z</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p_z(z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span>分布中获取，z表示生成数据，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>z</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p_z(z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span>表示生成数据的分布，对判别器D而言，如果向其输入的是生成数据，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D(G(z))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，判别器的目标就是最小化<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D(G(z))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，即判别器希望最大化<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>D</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log(1-D(G(z)))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>。</p>
<p>但对生成器而言，它去希望最小化<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>D</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log(1-D(G(z)))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，这就与判别器的目标相冲突的，这也是这种神经网络被称为生成对抗网络的原因。</p>
<p>传统的GAN有较多的缺陷，如生成器与判别器能力失衡造成训练不稳定，模型整体难以收敛(简单而言，就是训练过程不稳定)，此外还容易产生模式崩溃或梯度消失的问题，但近年经过各方的努力，GAN展示出了巨大的力量。下图展示了这几年，GAN在人脸生成的上的进步(算力需求也大幅提高，个人玩家几乎玩不起)。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902095943.png" alt="" /></p>
<p>除了在图像生成上，利用GAN还可以做很多有趣的事情。</p>
<p>比如智能PS。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902100035.png" alt="" /></p>
<p>比如通过一张图片生成一段视频。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902162611.png" alt="" /></p>
<h2 id="6pix2pix替换人脸"><a class="markdownIt-Anchor" href="#6pix2pix替换人脸"></a> 6.Pix2Pix替换人脸</h2>
<p>有了GAN的基本概念后，Pix2Pix就不难理解了。</p>
<p>与传统GAN不同，Pix2Pix中的判别器要判断输入的两张图像是否是真实的一对图像，而生成器也不是从噪音数据中生成图像，而是从某一张图像生成另一张图像，如下图：</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902215800.png" alt="" /></p>
<p>判别器的目的除了判断生成的图像是否真实外，还需要判断生成的图像是否与另一张图像可以组成正常的一对图像。</p>
<p>Pix2Pix除了使用标准GAN损失函数外，还使用生成图像与对应真实图像之间的L1距离作为损失，从其论文描述中可知，Pix2Pix利用GAN损失捕捉图像中的高频特征，而利用L1损失捕捉图像中的低频特征。</p>
<p>此外，为了让生成器更加容易生成与输入图像相关的图像，采用了U型网络结构(Unet)。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902220357.png" alt="" /></p>
<p>U型网络中使用了Skip-Connection，简单来说就是将前面层中的一些数据不经过后面层的运算处理(运算会丢失细节)，而直接交由较后面的层直接使用。这很大程度让生成器网络结构中的后面几层也得到了很多细节数据，从而让生成器更容易生成与输入图像相关的数据。</p>
<p>训练好Pix2Pix后，就可以实现图像的双域转换了，所谓域指的就是某种类型的图像。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902212821.png" alt="" /></p>
<p>Pix2Pix的整体思想比较简单，但有一个缺陷，就是训练数据不好找，比如我想利用Pix2Pix黑夜转白天的效果，就需要准备一堆黑夜的数据以及对应的一堆白天的数据，一对图像，你就需要在同一个地方，白天拍摄一张，晚上拍摄一张，有很多对这样的图像，才能训练出具有比较好效果的Pix2Pix，但这明显不现实。</p>
<p>但有些需求数据是很好找的，比如去除马赛克，只需要找到一张图像，然后为其打上马赛克就可以构成一对数据了，Pix2Pix可以实现效果不错的马赛克去除工具，比如下面对某些植物进行马赛克的去除，取得不俗的效果。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902221313.png" alt="" /></p>
<p>对真人呢？</p>
<p>而替换人脸其实也是类似的思路，下图就是Brannon Dorsey 使用Pix2Pix实现Person-to-Person的效果，虽然看上去不咋样。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902230125.png" alt="" /></p>
<p>原始的Pix2Pix难以产生高清的图像，所以Pix2PixHD被提出，它在保持了原始Pix2Pix能力的前提下提高了其生成高质量的图像的能力。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190903113538.png" alt="" /></p>
<h2 id="7cyclegan替换人脸"><a class="markdownIt-Anchor" href="#7cyclegan替换人脸"></a> 7.CycleGAN替换人脸</h2>
<p>因为训练Pix2Pix需要成对的图像，而很多时候，成对的数据是难以获得的，而CycleGAN可以解决这个问题，实现两个域内的图像相互转换的目的。</p>
<p>在训练CycleGAN时，并不需要使用成对的数据，这是怎么做到的？</p>
<p>一个直观的想法就是先通过生成器获取域X中的图像，将其转换为域Y中的图像，然后再将其转换回来，形象如下图：</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902224017.png" alt="" /></p>
<p>其中域X为马的图像，域Y为斑马的图像。</p>
<p>一开始，通过生成器，将马转换成斑马，即G(X-&gt;Y)，接着再通过另外一个生成器，将斑马转换为马，即G(Y-&gt;X)。</p>
<p>简单而言，生成器接收马的图像生成斑马，然后另外一个生成器接受斑马的图像生成马，此时可以计算原始的马图像与还原生成马图像的损失，论文中将这种损失称为循环一致性损失。</p>
<p>单单这样做还不行，因为在训练过程中，神经网络很有可能发现，你就是想将图像还原回输入图像的样子，那么它会慢慢倾向于不做什么有价值的操作，直接将输入图像的大部分数据直接还原，这并不是我们想要的，所以还需要另外一个损失来判断中间状态的生成的斑马是否真实。</p>
<p>再多加一个相似的结构，就可以构成CycleGAN了</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902224402.png" alt="" /></p>
<p>如果觉得上图有些难理解，可以看到下图：</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902224708.png" alt="" /></p>
<p>CycleGAN为了让模型训练的更加稳定，相比此前的GAN模型CycleGAN做了如下改变：</p>
<ul>
<li>1.Instance normalization代替Batch normalization</li>
<li>2.目标损失函数使用了LSGAN平方差损失代替传统的GAN损失</li>
<li>3.生成器中使用了残差网络，可以更好的保存图像的语义</li>
<li>4.使用缓存历史图像来训练生成器，减小训练时的震荡，让模型更加稳定</li>
</ul>
<p>下图就是我通过CycleGAN训练出的效果。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902224625.png" alt="" /></p>
<p>通过CycleGAN对人进行换脸本质依旧是不同域图像之间的转换。</p>
<p>此外，通过这种技术，还可以做一些变态的事情了，如给女优脱衣。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902225023.png" alt="" /></p>
<p>如果你还记得「DeepNude」这款给女性脱衣的应用，此时你应该可以明白其背后技术了(利用Pix2Pix或CycleGAN理论上都可以实现DeepNude这类应用)。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902225406.png" alt="" /></p>
<p>声明：这对女性是极其不尊重的，也不是技术应该使用的地方，在本文「10.威胁」中会简单的讨论一下这类技术产生的风波。</p>
<p>CycleGAN已经可以比较好的实现双域图像的转换的，那如何比较好的实现多域图像的转换呢？可以搜索阅读StarGAN相关的资料，因为与本文主题无关，就不多讨论了。</p>
<p>下图是我通过StarGAN模型得到的效果，StarGAN可以实现图像的多域转换，下图的每一列表示不同的域不同域即不同的效果，其中分布是：原图、黑发、金发、褐色头发、反性化、老年化。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902211950.png" alt="" /></p>
<p>可以看出，早些时候在国外社交媒体火爆的FaceApp背后的技术其实也是GAN，将StarGAN完善一下，让模型具有工业级的参数规模(以及工业级的训练数据与算力支持)，一个FaceApp就被弄出来了。</p>
<h2 id="8faceswap-gan换脸应用"><a class="markdownIt-Anchor" href="#8faceswap-gan换脸应用"></a> 8.Faceswap-GAN换脸应用</h2>
<p>前面讨论了这么多，是否已经有开源实现好的项目呢？</p>
<p>当然有，我们来看一下Faceswap-GAN，它是最初换脸项目deepfakes_faceswap的升级版。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190903114934.png" alt="" /></p>
<p>deepfake_faceswap虽然实现了人脸替换，但还是有一些问题，比如原版中使用了dlib人脸识别库，该库在非「全脸」或脸比较偏的时候，人脸识别率就不高了，而Faceswap-GAN使用了MTCNN来作为人脸识别引擎，代价就是慢。</p>
<p>我们可以通过下面几张图片来理解Faceswap-GAN大致的实现思路，需要注意，Faceswap-GAN具体的实现细节与图中的流程并不完全相同。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190903120010.png" alt="" /></p>
<p>从图中可以看出，在训练阶段，首先输入带有人脸的图像Person A，然后通过MTCNN人脸识别获得真脸图像 Real face A，接着将Real face A进行扭曲操作得到Warped face A(注意，扭曲只对人脸周围扭曲，不对人脸特征扭曲，如眼睛、鼻子等，这种做法与往图像上添加马赛克没有本质区别)，然后通过自编码器将扭曲后的人脸图像还原，从而获得重建后的人脸 Reconstructed face A。</p>
<p>deepfake_faceswap项目使用了自编码器，但改进后的Faceswap-GAN通过GAN实现了相同的过程。</p>
<p>获得了Reconstructed face A后并没有结束，它还会获得人脸特征面具，图中称为Segmentation mask，人脸特征面具会与重建后的脸做运算，目的是只获取人脸的特征，特征外的其他部分不再需要，接着将人脸特征域用于扭曲后人脸Warped face A从而获得最终的结果Masked face A。</p>
<p>而在测试阶段，流程也是相同的，传入带有人脸的图像Person B，然后MTCNN识别人脸，随后直接将人脸传入，不需要进行扭曲造成，因为我们训练时，使用了Person A，此时使用Person B的真实人脸，自编码器会将其认为是扭曲后的人脸A，即 Warped A，此时会进行重建操作，然后再通过相同的方式将人脸特征面具与还原重构后的人脸运算获得仅需要的人脸特征部分，再与Real face B融合就可以获得最终的结果face B，但因为它的五官有face A的特点，所以看起来像face A。</p>
<p>Faceswap-GAN使用了3种不同的损失来训练整个神经网络，分别是重建损失(reconsturction loss)、对抗损失(Adversarial loss)与感性损失(Perceptual loss)。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190903121633.png" alt="" /></p>
<p>重建损失：对比重建后的人脸与真实人脸之间的差距，具体而言，就是使用平均绝对误差(MAE)对图像中的每一个像素进行计算，希望随着训练，将这个损失降低到最小。</p>
<p>对抗损失：判别器判断数据是真实数据还是虚假数据，对于生成器而言，它希望判别器给它生成的数据标记为真实数据，而对判别器而言，它希望给生成器生成的数据标记为虚假数据，两者博弈产生的损失。</p>
<p>感性损失：用于改善生成图像中眼球的方向，使生成的图像更加真实，并且可以平滑处理生成图像中可能产生的伪影，该损失使用了VggFace模型(VggFace使用了VGG16实现人脸识别的模型)</p>
<p>Faceswap-GAN还使用了很多技巧来完善生成的数据，并且它还提供了可以在Google的colab上直接执行的代码，使得使用门槛进一步降低(colab最长只能运行12个小时，这份代码只能生成一个轻量的Faceswap-GAN)。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190903101723.png" alt="" /></p>
<p>最后提一句：Faceswap-GAN背后采用的是CycleGAN。</p>
<h2 id="9一张图像实现视频换脸"><a class="markdownIt-Anchor" href="#9一张图像实现视频换脸"></a> 9.一张图像实现视频换脸</h2>
<p>聪明的读者可以发现了，前面的方式很酷，但似乎与「ZAO」的不一样，「ZAO」似乎只用上传一张图像就是实现换脸了。</p>
<p>比如Faceswap-GAN，想通过它进行换脸，就需要准备两个人的大量图像，然后经过一定时长的训练，从而实现两者的换脸，此时如果传入第三者的脸(未经过训练)进行换脸操作，效果是不好的。</p>
<p>那「ZAO」是如何只通过一张图像就实现换脸的呢？</p>
<p>具体我也不清楚，因为「ZAO」团队没有说是通过什么技术实现的，但可以确定，并不是利用AutoEncoder、Pix2Pix或CycleGAN之类的，即与DeepFace或Faceswap使用的技术不同。</p>
<p>虽然不知道「ZAO」如何实现，但想要实现这种的效果可以通过Meta-GAN的思路，即元学习+GAN。</p>
<p>在2019年的5月，三星给出了《Few-Shot Adversarial Learning of Realistic Neural Talking Head Models》论文。</p>
<p>在论文中，提供了通过少量图像甚至一张图像就可以实现人物换脸效果的思路，其中主要的就是元学习+GAN。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190903165652.png" alt="" /></p>
<p>元学习简单而言就是学习如何学习，这涉及了大量的话题(本人对元学习所知也不多)，本文不深入探讨，这里简单的讨论一下论文的大体思路：</p>
<ul>
<li>1.通过基于GAN的元学习，在大量的视频数据中训练获得模型</li>
<li>2.训练完后，元学习会获得一个映射矩阵，元学习可以为GAN的生成器与判别器自动初始为适合目标人脸的参数，从而实现少量图像甚至一张图像就可以换脸的效果。</li>
</ul>
<p>其模型的大致结构如下：</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190903165742.png" alt="" /></p>
<p>从论文描述可知，Embedder嵌入器会将头像以及面部标记数据都映射到嵌入向量中，该向量包含了与姿势无关的信息。</p>
<p>生成器会利用输入的面部标记数据去生成数据，生成器的卷积层会通过AdaIN获取嵌入向量中的信息(人脸特征信息)来生成人脸。</p>
<p>判别器由两步构成，一步是通过编码网络将三种图像编码为向量，然后与W矩阵相乘从而获得最终得分。</p>
<p>通过论文中的思路构建神经网络可以实现惊人的效果，比如通过一张蒙拉丽莎的图片，让她活过来给你讲故事。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190903171655.png" alt="" /></p>
<h2 id="10威胁"><a class="markdownIt-Anchor" href="#10威胁"></a> 10.威胁</h2>
<p>这种技术的兴起也带来了坏的一面，如DeepNude(脱去女性衣服)，此外国内很多人闻风而起，搭建了各种DeepFace网站，在降低使用技术门槛的同时，也更容易被一些心怀不轨的人利用。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190902151252.png" alt="" /></p>
<p>这种技术在国外大多是被批评的，你无法想象，犯罪分子利用这种技术合成勒索视频给你父母、你的前任将你的脸合成到低俗视频中带来的影响。</p>
<p>人的脸不再属于自己是可怕的。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190903172241.png" alt="" /></p>
<p>不要觉得受害的只是明星，我们要抵制技术使用到这种方面。</p>
<h2 id="11ai对ai识破假视频"><a class="markdownIt-Anchor" href="#11ai对ai识破假视频"></a> 11.AI对AI，识破假视频</h2>
<p>知道了一些换脸的技术以及明白了它会带来的危害，那如何识别假视频呢？</p>
<p>现在生成的视频通过肉眼已经难以分辨出真假了，难道只能坐以待毙？</p>
<p>下面介绍一下我看见的几种识别假视频的方法。</p>
<h3 id="使用循环神经网络来识别视频"><a class="markdownIt-Anchor" href="#使用循环神经网络来识别视频"></a> 使用循环神经网络来识别视频</h3>
<p>目前大多数生成视频都是利用DeepFace相关的技术，其背后就是AutoEncoder、Pix2Pix或者CycleGAN，但单纯的使用这一类技术实现人脸的替换会存在一些小问题，具体而言，就是视频的当前帧与前一帧之间是独立的，这样前一帧的一些重要信息就无法用于当前帧，当视频中画面光源有所变化时，通过这种方式生成的视频就会有「闪屏现象」，这里说的闪屏不是我们常说的闪屏，而是通过人眼难以观察到的像素异常变化。</p>
<p>此时训练一个模型来观察则可，如果视频中连贯的部分存在这种现象，则可能是生成的造假视频，这就需要视频时间维度上的信息(当前帧的画面受上一帧的影响)。</p>
<p>谈论到时间维度，自然会想到循环神经网络RNN、LSTM、GRU之类的，这里以LSTM作为代表来简单介绍一下。</p>
<p>RNN在时间维度较长的数据上使用容易出现梯度消失的现象，人话说就是RNN不适合处理太长的数据，比如一段话，一段话中的每个词都是与前一个词或后一个词是相关的，而RNN要处理一段话中比较后面的词汇时，容易「忘记」这段话中排的比较前的词汇(梯度消失)，后来就提出了LSTM、GRU等模型来避免这类问题。</p>
<p>LSTM模型结构如下，其中t表示时间，本质就对数据进行运行，从而决定模型应该记住什么，应当忘记什么，最终让模型记住重要的信息。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190903104047.png" alt="" /></p>
<p>LSTM常用于NLP领域，现在用于视频检测，其本质并没有改变，都是将当前时间节点之前的信息传递到当前时间节点。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190903105019.png" alt="" /></p>
<p>更多细节可以参考中论文8。</p>
<h3 id="通过眨眼生理信号来识别视频"><a class="markdownIt-Anchor" href="#通过眨眼生理信号来识别视频"></a> 通过眨眼生理信号来识别视频</h3>
<p>通过标题就明白具体的识别方法了，如果是真实的视频，视频中的人物通常会有眨眼这种生理信号，而换脸后生成的虚假视频并不会有这样的生理特征。</p>
<p>此时可以利用CNN+LSTM的形式，通过判断视频图像中人物是否存在眨眼情况，来判断当前视频是真实视频还是生成视频。</p>
<p>论文中将这种方法称为LRCN方法。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190903180853.png" alt="" /></p>
<p>其中(a)是原始的视频序列，(b)是做了面部对齐后的序列，LRCN方法会基于(b)中眼睛周围p1~6，这6个标签来提取特征、进行序列学习与进行眼睛状态的预测。</p>
<p>值得一提的是，LRCN方法并不是简单的判断视频中人像的眨眼次数，而是会通过视频每一帧中眼睛的状态来判断眼睛在下一帧是否会眨眼，比如人物在当前帧的眼睛是关闭的，那么在下一帧其睁开的概率就会比较大。</p>
<p>如下图，第一行是原始视频，存在眨眼，而第二行是生成的虚假视频，其中人物没有进行眨眼。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190903181531.png" alt="" /></p>
<p>更多细节可以参考论文9。</p>
<h3 id="使用肖像中的生物信息识别视频"><a class="markdownIt-Anchor" href="#使用肖像中的生物信息识别视频"></a> 使用肖像中的生物信息识别视频</h3>
<p>简单而言就是利用视频中人脸的各种动作来捕捉其中的生物信息，而这些信息在生成视频中是不会存在的，或者是不符合规律的。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190903123843.png" alt="" /></p>
<p>没细看论文，不多言，感兴趣可以参考论文10。</p>
<h2 id="12结尾"><a class="markdownIt-Anchor" href="#12结尾"></a> 12.结尾</h2>
<p>本文只是抛砖迎玉，很多细节并没有讨论，如果文中有不妥之处欢迎各位留言斧正，最后希望这些技术可以用到正途之上。</p>
<p>写作不易，如果喜欢，欢迎点好看。</p>
<h2 id="13参考"><a class="markdownIt-Anchor" href="#13参考"></a> 13.参考</h2>
<h3 id="paper"><a class="markdownIt-Anchor" href="#paper"></a> Paper</h3>
<p>1.Joint Face Detection and Alignment using Multi-task Cascaded Convolutional Networks:<a href="https://kpzhang93.github.io/MTCNN_face_detection_alignment/paper/spl.pdf" target="_blank" rel="noopener">https://kpzhang93.github.io/MTCNN_face_detection_alignment/paper/spl.pdf</a></p>
<p>2.A Unified Multi-scale Deep Convolutional<br />
Neural Network for Fast Object Detection:<a href="http://www.svcl.ucsd.edu/publications/conference/2016/mscnn/mscnn.pdf" target="_blank" rel="noopener">http://www.svcl.ucsd.edu/publications/conference/2016/mscnn/mscnn.pdf</a></p>
<p>3.Auto-Encoding Variational Bayes:<a href="https://arxiv.org/pdf/1312.6114.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1312.6114.pdf</a></p>
<p>4.Generative Adversarial Nets:<a href="https://arxiv.org/pdf/1406.2661.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1406.2661.pdf</a></p>
<p>5.Image-to-Image Translation with Conditional Adversarial Networks:<a href="https://arxiv.org/pdf/1611.07004.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1611.07004.pdf</a></p>
<p>6.Unpaired Image-to-Image Translation using Cycle-Consistent Adversarial Networks<a href="https://arxiv.org/pdf/1703.10593.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1703.10593.pdf</a></p>
<p>7.Few-Shot Adversarial Learning of Realistic Neural Talking Head Models:<a href="https://arxiv.org/pdf/1905.08233.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1905.08233.pdf</a></p>
<p>8.Deepfake Video Detection Using Recurrent Neural Networks:<a href="https://engineering.purdue.edu/~dgueraco/content/deepfake.pdf" target="_blank" rel="noopener">https://engineering.purdue.edu/~dgueraco/content/deepfake.pdf</a></p>
<p><a href="http://9.In" target="_blank" rel="noopener">9.In</a> Ictu Oculi: Exposing AI Created Fake Videos by Detecting Eye Blinking<a href="https://ieeexplore.ieee.org/document/8630787" target="_blank" rel="noopener">https://ieeexplore.ieee.org/document/8630787</a></p>
<p>10.FakeCatcher: Detection of Synthetic Portrait Videos using Biological Signals<a href="https://arxiv.org/pdf/1901.02212.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1901.02212.pdf</a></p>
<h3 id="数据集"><a class="markdownIt-Anchor" href="#数据集"></a> 数据集</h3>
<p>1.WIDER FACE: A Face Detection Benchmark:<a href="http://shuoyang1213.me/WIDERFACE/" target="_blank" rel="noopener">http://shuoyang1213.me/WIDERFACE/</a></p>
<p>2.Deep Convolutional Network Cascade for Facial Point Detection:<a href="http://mmlab.ie.cuhk.edu.hk/archive/CNN_FacePoint.htm" target="_blank" rel="noopener">http://mmlab.ie.cuhk.edu.hk/archive/CNN_FacePoint.htm</a></p>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<p>1.MTCNN_face_detection_alignment:<a href="https://github.com/kpzhang93/MTCNN_face_detection_alignment" target="_blank" rel="noopener">https://github.com/kpzhang93/MTCNN_face_detection_alignment</a></p>
<p>2.pix2pix<a href="https://phillipi.github.io/pix2pix/" target="_blank" rel="noopener">https://phillipi.github.io/pix2pix/</a></p>
<p>3.faceswap-GAN:<a href="https://github.com/shaoanlu/faceswap-GAN" target="_blank" rel="noopener">https://github.com/shaoanlu/faceswap-GAN</a></p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python进阶：使用Matplotlib进行数据可视化(一)</title>
    <url>/blog/2019/10/21/Python%E8%BF%9B%E9%98%B6%EF%BC%9A%E4%BD%BF%E7%94%A8Matplotlib%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96-%E4%B8%80/</url>
    <content><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>数据可视化是让我们感知数据的一种重要手段，通过不同的数据可视化的方式，使得我们可以在不同维度去理解当前的数据。</p>
<p>数据可视化的基本原理就是，人脑对色块的敏感性远大于数字，从演化论角度来讲，可以很好的分辨出不同颜色事物的祖先更容易活下来，而数字，那个时候并没有，所以进化而来的大脑并不擅长处理数字，进而对干巴巴的数据不敏感。</p>
<p>本章内容会提供代码以及相应的数据，公众号回复：Data1 则可获得。</p>
<h2 id="matplotlib简单概念"><a class="markdownIt-Anchor" href="#matplotlib简单概念"></a> Matplotlib简单概念</h2>
<p>Matplotlib是Python中用于绘制二维图形的知名第三方库(如果要绘制三维图形，需要额外安装一些支持包)，也是很多几天高层次数据可视化第三方库的基础支持库。</p>
<p>Matplotlib中绘制的图有下面集中元素：</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190823135750.png" alt="" /></p>
<p>解释一下：</p>
<ul>
<li>Major tick：主线</li>
<li>Minor tick：线上的刻度</li>
<li>Major tick label：主线上的标签</li>
<li>Title：整个图的标题</li>
<li>Legend：标注</li>
<li>Y axis label：Y轴的标签</li>
<li>Line：绘制的线</li>
<li>Grid：网格</li>
<li>Markers：标记</li>
<li>Figure：图形</li>
<li>Axes：轴域</li>
</ul>
<p>上图就是Matplotlib绘制的整个窗口，图中包含了实际图表、x轴、y轴以及每个轴对应的标题、刻度和标签。在Matplotlib中可以为图形添加多个轴域，具体而言，就是使用pyplot来创建多个轴域并改变其形状。</p>
<p>这里可能会疑惑，Figure、Axes与Axis之间有什么关系？特别是Axes与Axis，英文直译都称为轴，可以通过一张图解释三者的关系。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190823141059.png" alt="" /></p>
<h2 id="绘制图像的常见步骤"><a class="markdownIt-Anchor" href="#绘制图像的常见步骤"></a> 绘制图像的常见步骤</h2>
<p>大多数时候，使用 Matplotlib 绘制数据的流程是类似的，虽然有些特殊的图像绘制需要一下特殊的操作，但大体流程都相似</p>
<ul>
<li>1.通过Pandas将要绘制图像的数据读入，如pd.read_csv()读入csv文件数据、pd.read_excel()读取Excel文件数据</li>
<li>2.导入 Matplotlib , 具体为: import matplotlib.pyplot as plt</li>
<li>3.使用 plt.plot() 绘制折线图，不同的图使用不同的绘图函数，所有的绘图函数都需要传入相应的数据</li>
<li>4.使用plt.xlabel与plt.ylabel定义x轴与y轴的标签，如定义标签字体样式、字体大小、字段位置等待，如果不使用，Matplotlib就会使用默认的样式将要显示的内容在标签处显示。需要注意的是，默认的样式是不支持显示中文的，如果此时你的标签要显示的内容是中文，那么Matplotlib生成的图像中，标签位置对应的内容会成为一个空方块，要显示中文，需要指定字体。</li>
<li>5.使用plt.xticks与plt.yticks定义x轴与y轴上的标记点，如定义标点的间隔</li>
<li>6.使用plt.legend()标注，如折线图中有3条不同颜色的折线，通过legend()方法就可以标注出不同折线的含义</li>
<li>7.使用plt.title()定义图中的标题</li>
<li>8.使用plt.show()将最终的图像展示出来。</li>
</ul>
<p>接着，就来看一些具体图像的绘制</p>
<h2 id="直方图"><a class="markdownIt-Anchor" href="#直方图"></a> 直方图</h2>
<p>直方图是我们比较常见的简单图像，它有助于我们理解数据的范围以及加强我们对数据的整体感知。</p>
<p>这里以商店销售特定游戏数据为例来绘制直方图，先来看一下数据的样子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">np_data=pd.read_csv(<span class="string">'datasets/national_parks.csv'</span>)</span><br><span class="line">print(np_data.head()) <span class="comment"># 打印前5行数据</span></span><br></pre></td></tr></table></figure>
<p>前5行数据如下：</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190823175227.png" alt="" /></p>
<p>绘制直方图的代码如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">n, bins, patches = plt.hist(np_data[<span class="string">'GrandCanyon'</span>],  # 某一类游戏的数据</span><br><span class="line">         <span class="attribute">facecolor</span>=<span class="string">'orange'</span>,  # 直方图中矩形的颜色</span><br><span class="line">         <span class="attribute">edgecolor</span>=<span class="string">'blue'</span>,  # 直方图中矩形边的颜色</span><br><span class="line">         <span class="attribute">bins</span>=10 # 绘制多少个矩形</span><br><span class="line">) </span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">'n: '</span>, n) # 表示每个矩形在 y 轴的最大值</span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">'bins: '</span>, bins) # 表示每个矩形在 x 轴的值</span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">'patches: '</span>, patches) # 每个矩形对应的 patch 对象</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190823175442.png" alt="" /></p>
<p>其中打印的内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">n:</span>  <span class="string">[</span> <span class="number">5</span><span class="string">.</span>  <span class="number">9</span><span class="string">.</span> <span class="number">10</span><span class="string">.</span>  <span class="number">2</span><span class="string">.</span>  <span class="number">1</span><span class="string">.</span>  <span class="number">9</span><span class="string">.</span> <span class="number">16</span><span class="string">.</span>  <span class="number">2</span><span class="string">.</span>  <span class="number">1</span><span class="string">.</span>  <span class="number">2</span><span class="string">.]</span></span><br><span class="line"><span class="attr">bins:</span>  <span class="string">[1253000.</span>  <span class="number">1753123.8</span> <span class="number">2253247.6</span> <span class="number">2753371.4</span> <span class="number">3253495.2</span> <span class="number">3753619</span><span class="string">.</span>  <span class="number">4253742.8</span></span><br><span class="line"> <span class="number">4753866.6</span> <span class="number">5253990.4</span> <span class="number">5754114.2</span> <span class="number">6254238</span><span class="string">.</span> <span class="string">]</span></span><br><span class="line"><span class="attr">patches:</span>  <span class="string">&lt;a</span> <span class="string">list</span> <span class="string">of</span> <span class="number">10</span> <span class="string">Patch</span> <span class="string">objects&gt;</span></span><br></pre></td></tr></table></figure>
<p>绘制直方图时，可以将cumulative设置为true，此时绘制直方图时，会将每个矩形前的所有矩形的y轴值累加并加上当前矩形的y轴值，然后再绘制这个矩形，代码与效果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.hist(np_data[<span class="string">'GrandCanyon'</span>], </span><br><span class="line">         facecolor=<span class="string">'orange'</span>, </span><br><span class="line">         edgecolor=<span class="string">'blue'</span>, </span><br><span class="line">         bins=<span class="number">10</span>,</span><br><span class="line">         cumulative=<span class="literal">True</span>) <span class="comment"># 累加属性设置为True</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190823180932.png" alt="" /></p>
<p>此外可以通过range属性来定义你想要看的直方图范围，比如我只关心(2000000, 5000000)之间的数据，其他数据我不关心，就可以用上range，使用如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.hist(np_data[<span class="string">'GrandCanyon'</span>], </span><br><span class="line">         facecolor=<span class="string">'orange'</span>, </span><br><span class="line">         edgecolor=<span class="string">'blue'</span>, </span><br><span class="line">         bins=<span class="number">10</span>,</span><br><span class="line">         range=(<span class="number">2000000</span>, <span class="number">5000000</span>))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>效果如下，主要观察图中的x轴，x轴不会超出(2000000, 5000000)这个范围</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190823181617.png" alt="" /></p>
<h2 id="饼图"><a class="markdownIt-Anchor" href="#饼图"></a> 饼图</h2>
<p>饼图也是一种常见的图像，它可以帮助我们理解数据中某个部分占总体数据的比例，此外，饼图并不适合用于说明一下信息，首先依旧是读入用于绘制饼图的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t_mov= pd.read_csv(<span class="string">'datasets/types_movies.csv'</span>)</span><br><span class="line">print(t_mov)</span><br></pre></td></tr></table></figure>
<p>数据如下：</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190823190829.png" alt="" /></p>
<p>绘制饼图的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.pie(t_mov[<span class="string">'Percentage'</span>],  <span class="comment"># 计算比例的具体数据</span></span><br><span class="line">        labels=t_mov[<span class="string">'Sector'</span>]) <span class="comment"># 对应的标签</span></span><br><span class="line"></span><br><span class="line">plt.axis(<span class="string">'equal'</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190823190932.png" alt="" /></p>
<p>如果想要定制饼图的颜色，直接通过colors参数，指定一组颜色则可，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">colors = [<span class="string">'darkorange'</span>, <span class="string">'sandybrown'</span>, <span class="string">'darksalmon'</span>, <span class="string">'orangered'</span>,<span class="string">'chocolate'</span>]</span><br><span class="line"></span><br><span class="line">plt.pie(t_mov[<span class="string">'Percentage'</span>], </span><br><span class="line">        labels=t_mov[<span class="string">'Sector'</span>], </span><br><span class="line">        colors=colors, </span><br><span class="line">        autopct=<span class="string">'%.2f'</span>)</span><br><span class="line"></span><br><span class="line">plt.axis(<span class="string">'equal'</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>效果如图：</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190823201402.png" alt="" /></p>
<p>此外饼图还能绘制成类似披萨的形态，即即让一些扇形不拼接在一起，指定explode参数则可，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">explode = (<span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">plt.pie(t_mov[<span class="string">'Percentage'</span>], </span><br><span class="line">        labels=t_mov[<span class="string">'Sector'</span>], </span><br><span class="line">        colors=colors, </span><br><span class="line">        autopct=<span class="string">'%.2f'</span>,</span><br><span class="line">        explode=explode)</span><br><span class="line"></span><br><span class="line">plt.axis(<span class="string">'equal'</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>效果如图：</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190823201523.png" alt="" /></p>
<h2 id="时间序列线图"><a class="markdownIt-Anchor" href="#时间序列线图"></a> 时间序列线图</h2>
<p>一些具有时间顺序属性的数据可以被称为时间序列数据，股票数据就是一种典型的时间序列数据，通过这些数据绘制一条时间序列线图可以帮助我们更好的了解数据随着时间的推移有什么变化，下面以部分美股的股票数据为例绘制一下时间序列线图。</p>
<p>简单看一下数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stock_data = pd.read_csv(<span class="string">'datasets/stocks.csv'</span>)</span><br><span class="line"><span class="comment"># 将其中的日期转为Pandas中的DataTime，会更方便处理</span></span><br><span class="line">stock_data[<span class="string">'Date'</span>] = pd.to_datetime(stock_data[<span class="string">'Date'</span>])</span><br><span class="line">stock_data.head()</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190823202035.png" alt="" /></p>
<p>接着来绘制一下时间序列线图，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure(figsize=(<span class="number">10</span>,<span class="number">6</span>)) <span class="comment"># 定义画布大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个轴域进行作图</span></span><br><span class="line">ax1 = fig.add_axes([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]) <span class="comment"># 添加轴域</span></span><br><span class="line">ax2 = fig.add_axes([<span class="number">0.05</span>, <span class="number">0.65</span>, <span class="number">0.5</span>, <span class="number">0.3</span>]) <span class="comment"># 添加轴域</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置标题</span></span><br><span class="line">ax1.set_title(<span class="string">'AAPL vs IBM(inset)'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个轴域进行绘图</span></span><br><span class="line">ax1.plot(stock_data[<span class="string">'Date'</span>],</span><br><span class="line">         stock_data[<span class="string">'AAPL'</span>],</span><br><span class="line">         color=<span class="string">'green'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个轴域进行绘图</span></span><br><span class="line">ax2.plot(stock_data[<span class="string">'Date'</span>],</span><br><span class="line">         stock_data[<span class="string">'IBM'</span>], </span><br><span class="line">         color=<span class="string">'blue'</span>)</span><br><span class="line">         </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>上述代码中，为了比对两支不同的股票在相同时间段内的走势，这里调用了 add_axes([x0, y0, width, height]) 方法，其前两个参数用于定义轴域左上角的开始位置，而width与height用于定义轴域的大小，定义好了轴域后就可以在其上绘图了，效果如下：</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190823203056.png" alt="" /></p>
<p>通过与上面类似的方法，可以添加多个轴域绘制多个时间序列线图，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Figsize for width and height of plot</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">15</span>,<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line">fig.suptitle(<span class="string">'Stock price comparison 2007-2017'</span>, </span><br><span class="line">             fontsize=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">ax1 = fig.add_subplot(<span class="number">231</span>)</span><br><span class="line">ax1.set_title(<span class="string">'MSFT'</span>)</span><br><span class="line"></span><br><span class="line">ax1.plot(stock_data[<span class="string">'Date'</span>],</span><br><span class="line">         stock_data[<span class="string">'MSFT'</span>], </span><br><span class="line">         color=<span class="string">'green'</span>)</span><br><span class="line"></span><br><span class="line">ax2 = fig.add_subplot(<span class="number">232</span>)</span><br><span class="line">ax2.set_title(<span class="string">'GOOG'</span>)</span><br><span class="line"></span><br><span class="line">ax2.plot(stock_data[<span class="string">'Date'</span>],</span><br><span class="line">         stock_data[<span class="string">'GOOG'</span>], </span><br><span class="line">         color=<span class="string">'purple'</span>)</span><br><span class="line"></span><br><span class="line">ax3 = fig.add_subplot(<span class="number">233</span>)</span><br><span class="line">ax3.set_title(<span class="string">'SBUX'</span>)</span><br><span class="line"></span><br><span class="line">ax3.plot(stock_data[<span class="string">'Date'</span>],</span><br><span class="line">         stock_data[<span class="string">'SBUX'</span>], </span><br><span class="line">         color=<span class="string">'magenta'</span>)</span><br><span class="line"></span><br><span class="line">ax4 = fig.add_subplot(<span class="number">234</span>)</span><br><span class="line">ax4.set_title(<span class="string">'ADBE'</span>)</span><br><span class="line"></span><br><span class="line">ax4.plot(stock_data[<span class="string">'Date'</span>],</span><br><span class="line">         stock_data[<span class="string">'ADBE'</span>], </span><br><span class="line">         color=<span class="string">'orange'</span>)</span><br><span class="line"></span><br><span class="line">ax4 = fig.add_subplot(<span class="number">235</span>)</span><br><span class="line">ax4.set_title(<span class="string">'NFLX'</span>)</span><br><span class="line"></span><br><span class="line">ax4.plot(stock_data[<span class="string">'Date'</span>],</span><br><span class="line">         stock_data[<span class="string">'NFLX'</span>], </span><br><span class="line">         color=<span class="string">'chocolate'</span>)</span><br><span class="line"></span><br><span class="line">ax4 = fig.add_subplot(<span class="number">236</span>)</span><br><span class="line">ax4.set_title(<span class="string">'ORCL'</span>)</span><br><span class="line"></span><br><span class="line">ax4.plot(stock_data[<span class="string">'Date'</span>],</span><br><span class="line">         stock_data[<span class="string">'ORCL'</span>], </span><br><span class="line">         color=<span class="string">'teal'</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190823203228.png" alt="" /></p>
<h2 id="结尾"><a class="markdownIt-Anchor" href="#结尾"></a> 结尾</h2>
<p>本篇文章介绍了一部分Matplotlib可视化数据的用法，在下一文章中会介绍Matplotlib绘制其他图的用法，记得关注HackPython，拜拜。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190821150724.png" alt="" /></p>
]]></content>
      <tags>
        <tag>Python,进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Python进阶：使用Matplotlib进行数据可视化(二)</title>
    <url>/blog/2019/10/21/Python%E8%BF%9B%E9%98%B6%EF%BC%9A%E4%BD%BF%E7%94%A8Matplotlib%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96-%E4%BA%8C/</url>
    <content><![CDATA[<h1 id="python进阶使用matplotlib进行数据可视化二"><a class="markdownIt-Anchor" href="#python进阶使用matplotlib进行数据可视化二"></a> Python进阶：使用Matplotlib进行数据可视化(二)</h1>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>接着 使用Matplotlib进行数据可视化(一) ，继续使用 Matplotlib 绘制图像，公众号回复 data2 就可以获得本文章的代码与使用数据。</p>
<h2 id="箱线图boxplot"><a class="markdownIt-Anchor" href="#箱线图boxplot"></a> 箱线图(BoxPlot)</h2>
<p>箱线图(BoxPlot)也称箱须图(Box-whisker Plot)，它利用数据中的五个统计量：最小值、第一四分位数、中位数、第三四分位数与最大值来描述数据的一种方法，如下图：</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190826100715.png" alt="" /></p>
<p>1.minimum(最小值)与maximum(最大值)是数据中的最小值和最大值</p>
<p>2.median(中位数)：对数据排序，找到中间位置的数，称为中位数，如果中间位置有两个数，则相加再除以2，如有数字1,2,4,5,7,7,8,9，此时中位数为：(5+7)/2 = 6</p>
<p>3.lower quartile，也称为第一四分位数：它是数据排序后，中位数左边数据的中位数，如有数字1,2,4,5,7,7,8,9，此时第一四分位数为1,2,4的中位数，则为2</p>
<p>4.upper quartile，也称第三四分位数：它是数据排序后，中位数右边数据的中位数，如有数字1,2,4,5,7,7,8,9，此时第三四分位数为7,8,9的中位数，则为8</p>
<p>5.IQR(Inter Quartile Range)，即第一四分位数到第三四分位数这一部分的数据，它估计了中间50%的数据，上图没有绘制出IQR</p>
<p>5.outlier，也称离群值，如果一个值小于(第一四分位数 - 1.5*IQR)或大于(第三四分位数 + 1.5*IQR)，则称这个值为离群值</p>
<p>使用箱线图可以粗略的判断出数据是否具有对称性以及数据分布的离散程度，下面就来绘制一下。</p>
<p>一开始，依旧先读取数据并进行简单的处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">exam_data = pd.read_csv(<span class="string">'datasets/exams.csv'</span>)</span><br><span class="line"><span class="comment"># 仅提取考试分数相关的信息</span></span><br><span class="line">exam_scores = exam_data[[<span class="string">'math score'</span>, <span class="string">'reading score'</span>, <span class="string">'writing score'</span>]]</span><br><span class="line">exam_scores.head()</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190826104943.png" alt="" /></p>
<p>为了方便绘制boxplot，将数据转为numpy中的数组类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">exam_scores_array = np.array(exam_scores)</span><br></pre></td></tr></table></figure>
<p>使用matplotlib绘制boxplot</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">colors = [<span class="string">'blue'</span>, <span class="string">'grey'</span>, <span class="string">'lawngreen'</span>]</span><br><span class="line"></span><br><span class="line">bp = plt.boxplot(exam_scores_array,  <span class="comment"># 数据</span></span><br><span class="line">                 patch_artist=<span class="literal">True</span>, <span class="comment"># patch_artist设置为True，在后面才能设置不同的颜色</span></span><br><span class="line">                 notch=<span class="literal">True</span>) <span class="comment"># 显示是否有凹槽</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(bp[<span class="string">'boxes'</span>])):</span><br><span class="line">    bp[<span class="string">'boxes'</span>][i].set(facecolor=colors[i]) <span class="comment"># 设置颜色，前提是：patch_artist要设置为True</span></span><br><span class="line">    bp[<span class="string">'caps'</span>][<span class="number">2</span>*i + <span class="number">1</span>].set(color=colors[i])</span><br><span class="line">    </span><br><span class="line">plt.xticks([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="string">'Math'</span>, <span class="string">'Reading'</span>, <span class="string">'Writing'</span>])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190826105404.png" alt="" /></p>
<h2 id="小提琴图violinplot"><a class="markdownIt-Anchor" href="#小提琴图violinplot"></a> 小提琴图(ViolinPlot)</h2>
<p>小提琴图(ViolinPlot)用于显示数据分布以及概率密度，它结合了箱线图与密度图的特征。</p>
<p>形象如图：</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190826130800.png" alt="" /></p>
<p>95% confidence interval(95%的置信区间)在图中指的是延伸出来的黑色细线<br />
Density Plot((数据分布)密度图)<br />
Median(中位数)<br />
Interquartile range(四分位数范围)<br />
Split densities by category(按类别划分密度图)</p>
<p>使用绘制箱线图的数据绘制小提琴图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vp = plt.violinplot(exam_scores_array,</span><br><span class="line">                    showmedians=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">plt.xticks([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="string">'Math'</span>, <span class="string">'Reading'</span>, <span class="string">'Writing'</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(vp[<span class="string">'bodies'</span>])):</span><br><span class="line">    vp[<span class="string">'bodies'</span>][i].set(facecolor=colors[i])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190826131720.png" alt="" /></p>
<p>从图中可以看出，小提琴图的中间部分数据分布密度更大，这表明学生分数大部分都在平均水平附近</p>
<h2 id="双轴图twinaxis-plot"><a class="markdownIt-Anchor" href="#双轴图twinaxis-plot"></a> 双轴图(TwinAxis Plot)</h2>
<p>双轴图，顾名思义，就是一张图有两个y轴，当我们的数据使用相同x轴时，就可以考虑绘制双轴图。</p>
<p>​通过双轴图可以很直观的感受出两种数据之间的关联性，比如人口数据与国内生产总值数据在相同的时间轴(x轴)上，此时就可以用双轴图来判断两者的变化有没有关联性。</p>
<p>这里以Austin(奥斯汀，美国得克萨斯州的首府)城镇的天气数据来绘制双轴图，主要使用其中的平均气温与平均风速这两列数据，从而判断这两者有没有什么联系</p>
<p>首先，依旧是将数据读入，并取其中需要的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">austin_weather = pd.read_csv(<span class="string">'datasets/austin_weather.csv'</span>)</span><br><span class="line">austin_weather.head()</span><br><span class="line"><span class="comment"># Data 日期</span></span><br><span class="line"><span class="comment"># TempAvgF 平均气温，华氏温度</span></span><br><span class="line"><span class="comment"># WindAvgMPH 平均风速，以英里/小时为单位</span></span><br><span class="line">austin_weather = austin_weather[[<span class="string">'Date'</span>, <span class="string">'TempAvgF'</span>, <span class="string">'WindAvgMPH'</span>]].head(<span class="number">5</span>)</span><br><span class="line">pritn(austin_weather)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190826132919.png" alt="" /></p>
<p>使用这些数据绘制双轴图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="comment"># 创建子图</span></span><br><span class="line">fig, ax_tempF = plt.subplots()  </span><br><span class="line"></span><br><span class="line"><span class="comment">#fig=plt.figure(figsize=(12,6)) 可以实现相同效果</span></span><br><span class="line">fig.set_figwidth(<span class="number">12</span>)</span><br><span class="line">fig.set_figheight(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置x标签</span></span><br><span class="line">ax_tempF.set_xlabel(<span class="string">'Date'</span>)</span><br><span class="line"></span><br><span class="line">ax_tempF.tick_params(axis = <span class="string">'x'</span>,</span><br><span class="line">                    bottom=<span class="literal">False</span>, <span class="comment"># 禁用 ticks</span></span><br><span class="line">                    labelbottom=<span class="literal">False</span> <span class="comment"># 禁用 x 轴标签</span></span><br><span class="line">                    ) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置左 Y 轴标签</span></span><br><span class="line">ax_tempF.set_ylabel(<span class="string">'Temp (F)'</span>, </span><br><span class="line">                    color=<span class="string">'red'</span>,</span><br><span class="line">                    size=<span class="string">'x-large'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为左 Y 轴标签设置labelcolor(标签颜色)与labelsize(标签大小)</span></span><br><span class="line">ax_tempF.tick_params(axis=<span class="string">'y'</span>, </span><br><span class="line">                     labelcolor=<span class="string">'red'</span>, </span><br><span class="line">                     labelsize=<span class="string">'large'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 AvgTemp 绘制到 左 Y 轴上</span></span><br><span class="line">ax_tempF.plot(austin_weather[<span class="string">'Date'</span>], </span><br><span class="line">              austin_weather[<span class="string">'TempAvgF'</span>], </span><br><span class="line">              color=<span class="string">'red'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为两个图设置相同的x轴</span></span><br><span class="line">ax_precip = ax_tempF.twinx()</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置右 Y 轴标签</span></span><br><span class="line">ax_precip.set_ylabel(<span class="string">'Avg Wind Speed (MPH)'</span>, </span><br><span class="line">                     color=<span class="string">'blue'</span>, </span><br><span class="line">                     size=<span class="string">'x-large'</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 为右 Y 轴标签设置labelcolor(标签颜色)与labelsize(标签大小)</span></span><br><span class="line">ax_precip.tick_params(axis=<span class="string">'y'</span>, </span><br><span class="line">                      labelcolor=<span class="string">'blue'</span>,</span><br><span class="line">                      labelsize=<span class="string">'large'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 WindAVg 绘制到 右 Y 轴上</span></span><br><span class="line">ax_precip.plot(austin_weather[<span class="string">'Date'</span>], </span><br><span class="line">         austin_weather[<span class="string">'WindAvgMPH'</span>], </span><br><span class="line">         color=<span class="string">'blue'</span>)</span><br><span class="line"></span><br><span class="line">fig.legend(loc=<span class="number">1</span>, bbox_to_anchor=(<span class="number">1</span>,<span class="number">1</span>), bbox_transform=ax_tempF.transAxes)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190826134314.png" alt="" /></p>
<p>从图中可以看出，两者有些关系，但平均温度并不只受平均风速影响。</p>
<h2 id="堆叠图stack-plot"><a class="markdownIt-Anchor" href="#堆叠图stack-plot"></a> 堆叠图(Stack Plot)</h2>
<p>堆叠图是一种特殊的面积图，可以用来比较一个区间内的多个变量，与普通面积图不同，堆叠图每个数据面积的绘制起点都是基于前面一个数据面积来绘制的。</p>
<p>这里使用国家公园的数据来绘制堆叠图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np_data= pd.read_csv(<span class="string">'datasets/national_parks.csv'</span>)</span><br><span class="line">print(np_data.head())</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190826135044.png" alt="" /></p>
<p>national parks(国家公园)数据中有Badlands(荒废土地)、GrandCanyon(大峡谷)以及BryceCanyon(布莱斯峡谷)这3种类别的土地面积数据。</p>
<p>因为要绘制堆叠图，所以先要讲3中类别土地面积数据整合成一个二维数组，这里直接通过numpy的vstack()方法来实现这个效果，vstack()方法简单示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">print(np.vstack((a,b)))</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br></pre></td></tr></table></figure>
<p>接着就使用national parks数据来绘制一下堆叠图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np_data[<span class="string">'Year'</span>]</span><br><span class="line">y = np.vstack([np_data[<span class="string">'Badlands'</span>], </span><br><span class="line">               np_data[<span class="string">'GrandCanyon'</span>], </span><br><span class="line">               np_data[<span class="string">'BryceCanyon'</span>]])</span><br><span class="line">               </span><br><span class="line"><span class="comment"># 每个面积区域的标签</span></span><br><span class="line">labels = [<span class="string">'Badlands'</span>, </span><br><span class="line">          <span class="string">'GrandCanyon'</span>, </span><br><span class="line">          <span class="string">'BryceCanyon'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个面积区域的颜色</span></span><br><span class="line">colors = [<span class="string">'sandybrown'</span>, </span><br><span class="line">          <span class="string">'tomato'</span>, </span><br><span class="line">          <span class="string">'skyblue'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 与 pandas 的 df.plot.area() 类似</span></span><br><span class="line"><span class="comment"># stackplot()创建堆叠图</span></span><br><span class="line">plt.stackplot(x, y, </span><br><span class="line">              labels=labels,</span><br><span class="line">              colors=colors, </span><br><span class="line">              edgecolor=<span class="string">'black'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制标注</span></span><br><span class="line">plt.legend(loc=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190826140727.png" alt="" /></p>
<h2 id="百分比堆叠图"><a class="markdownIt-Anchor" href="#百分比堆叠图"></a> 百分比堆叠图</h2>
<p>百分比堆叠图类似于普通堆叠图，只是每个数据被转换成了对应的百分比然后再绘制到图中，依旧使用national parks(国家公园)数据来绘制百分比堆叠图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># divide函数：在整数和浮点数除法中均只保留整数部分</span></span><br><span class="line">data_perc = np_data.divide(np_data.sum(axis=<span class="number">1</span>), axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">plt.stackplot(x,</span><br><span class="line">              data_perc[<span class="string">"Badlands"</span>],data_perc[<span class="string">"GrandCanyon"</span>],data_perc[<span class="string">"BryceCanyon"</span>],</span><br><span class="line">              edgecolor=<span class="string">'black'</span>,</span><br><span class="line">              colors=colors,</span><br><span class="line">              labels=labels)</span><br><span class="line"></span><br><span class="line">plt.legend(loc=<span class="string">'center left'</span>, bbox_to_anchor=(<span class="number">1</span>, <span class="number">0.5</span>))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190826141312.png" alt="" /></p>
<h2 id="结尾"><a class="markdownIt-Anchor" href="#结尾"></a> 结尾</h2>
<p>本篇文章介绍了一部分Matplotlib可视化数据的用法，在下一文章中会介绍Matplotlib绘制其他图的用法，记得关注HackPython，拜拜。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190821150724.png" alt="" /></p>
]]></content>
      <tags>
        <tag>Python,进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>AutoPublish:多平台文章发布软件</title>
    <url>/blog/2019/10/21/AutoPublish-%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>当我们完成一篇文章时，当然希望将自己的文章发布到多个不同的平台，让更多人看到，但自己一个个手动登录然后手动去发送实在太枯燥的，自己也有这样的需求，希望自己公众号的文章可以同步到知乎、CSDN等各种不同的平台上，找了一下市面上的工具，没有特别满意的，所以就着手自己开发一个。</p>
<p>现在已经开源到Github上：<a href="https://github.com/ayuLiao/AutoPublish" target="_blank" rel="noopener">https://github.com/ayuLiao/AutoPublish</a></p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190828202415.png" alt="" /></p>
<p>欢迎大家使用以及提PR</p>
<p>至于如何使用，Github的README.md中有比较详细的说明，这里就不再说明，本文主要从源码层面介绍一下AutoPublish</p>
<h2 id="原理分析"><a class="markdownIt-Anchor" href="#原理分析"></a> 原理分析</h2>
<h3 id="平台登录"><a class="markdownIt-Anchor" href="#平台登录"></a> 平台登录</h3>
<p>为了快速实现这个文章多平台发送的功能，选择使用Selenium来实现登录和文章发布的逻辑，但在实现过程中遇到了一些问题，如知乎、CSDN登录时都会检测到Selenium。</p>
<p>​在开发AutoPublish时主要使用 Chrome，这里尝试让 Selenium 通过开发者模式控制 Chrome，开发者模型下的Chrome在某些关键参数上会与正常使用相同，但是可惜的是依旧没有绕过检查，这说明这些网站使用了其他参数来判断你使用了Selenium，只是这个参数我们自身无法确定，遇到这种情况，有三种解决方法</p>
<ul>
<li>1.使用中间人 mitmproxy，将请求中的参数修改，这里可以将Selenium中所有的参数都修改了(推荐)</li>
<li>2.编写Chrome插件，Selenium通过插件模式加载Chrome，让插件通过JS直接修改Chrome的参数(编写插件难度较大，本人未使用过)</li>
<li>3.重新编译Selenium，替换关键变量名(难度大，本人未使用过)</li>
</ul>
<p>但目前支持的3个平台(知乎、CSDN、豆瓣)都没有使用上面3种方式，而是直接使用requests通过模拟请求的方式来实现登录，其中知乎的登录规则最为恶心:(。</p>
<h3 id="使用selenium"><a class="markdownIt-Anchor" href="#使用selenium"></a> 使用Selenium</h3>
<p>完成登录后，会获得对应的Cookies，这些Cookies就类似于身份证一样的存在，有了正确的Cookies你就可以在登录状态做相应的事情了，比如在登录的账号下发表文章。</p>
<p>其实发表文章理论上也是可以使用requests的形式来实现的，但简单看一下，不同平台发送文章的逻辑不相同，图片处理、样式处理这些也比较棘手，为了最快速度的实现项目，依旧通过Selenium的形式去实现，简单快速。</p>
<p>​但在使用 Selenium 的过程中也遇到了一些问题，比如文章中图像的输入，像 CSDN 还好，因为后台就是 MarkDown 编辑器，样式这些不需要我们关心，而知乎需要自己将 MarkDown 渲染成 HTML，此时图像输入就比较麻烦了，此外 Selenium 不支持输入 emoji 表情，我的部分文章为了让读者不感觉到无趣，在部分段落中添加了 emoji，而 Selenium 发送输入包含 emoji 的文字时就会抛出异常。</p>
<h3 id="使用autogui"><a class="markdownIt-Anchor" href="#使用autogui"></a> 使用autogui</h3>
<p>最后决定使用autogui，autogui可以控制计算机的鼠标与键盘，从而实现点击、输入等效果，安装autogui需要安装相应的依赖驱动，这也操作了一些困扰，当autogui控制你鼠标或键盘时，你就无法使用鼠标或键盘了，因为它是通过驱动去控制的，与通过真实鼠标去控制是类似的，所以你使用autogui会暂时失去对鼠标或键盘的控制。</p>
<p>如果不在意暂时失去鼠标或键盘的控制，autogui就是非常好用了，直接通过控制键盘的方式，实现「键盘级」的复制粘贴，此时内容就会完全复制到不同平台相应编写内容的区域了，但这其实也隐藏着一个问题，就是操作对象必须获得了「焦点」，即浏览器要在所有窗口前，此时复制的内容才会被正确复制在浏览器对应的位置。</p>
<p>如果你使用PyCharm来运行该项目，此时代码无法完整的运行完，这是因为PyCharm无论是运行模式还是Debug模式，其实都占据了「焦点」，autogui复制的内容会出现在PyCharm光标处。</p>
<h2 id="代码分析"><a class="markdownIt-Anchor" href="#代码分析"></a> 代码分析</h2>
<h3 id="selenium二次封装"><a class="markdownIt-Anchor" href="#selenium二次封装"></a> Selenium二次封装</h3>
<p>因为整个项目会经常使用Selenium，为了让代码更加简洁，这里以单例模式创建浏览器实例并将Selenium的常用方法了二次封装。</p>
<p>简单看一下单例模式的实现方式，代码如下，其实就是利用了<code>__new__</code>方法，先判断实例是否存在，不存在再创建。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span><span class="params">(object)</span>:</span></span><br><span class="line">    _instance = <span class="literal">None</span></span><br><span class="line">    driver = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Singleton mode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls._instance:</span><br><span class="line">            cls._instance = super(Driver, cls).__new__(cls, *args, **kwargs)</span><br><span class="line">            cls.driver = cls._instance.initdriver()</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initdriver</span><span class="params">(self, plug=False, brower=<span class="string">'Chrome'</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> brower == <span class="string">'Chrome'</span>:</span><br><span class="line">            option = webdriver.ChromeOptions()</span><br><span class="line">            <span class="comment"># Remove warnings from browser that 'Chrome is under the control of automated software'</span></span><br><span class="line">            option.add_argument(<span class="string">'disable-infobars'</span>)</span><br><span class="line">            <span class="comment"># No interface</span></span><br><span class="line">            <span class="comment"># option.add_argument('headless')</span></span><br><span class="line">            driver = webdriver.Chrome(executable_path=CHROMEDIRVER, chrome_options=option)</span><br><span class="line">            driver.set_window_size(<span class="number">1200</span>, <span class="number">900</span>)</span><br><span class="line">        <span class="keyword">elif</span> brower == <span class="string">'FireFox'</span>:</span><br><span class="line">            <span class="keyword">if</span> plug:</span><br><span class="line">                <span class="comment">#  open %APPDATA%\Mozilla\Firefox\Profiles\ find firefox plugin，then load plugin configuration.</span></span><br><span class="line">                firefox_plug_dir = <span class="string">''</span></span><br><span class="line">                profile_directory = os.path.join(appdata, <span class="string">'Mozilla\Firefox\Profiles'</span>, firefox_plug_dir)</span><br><span class="line">                profile = webdriver.FirefoxProfile(profile_directory)</span><br><span class="line">            <span class="comment"># Launch browser</span></span><br><span class="line">            driver = webdriver.Firefox(firefox_profile=profile)</span><br><span class="line">        <span class="keyword">return</span> driver</span><br></pre></td></tr></table></figure>
<p>接着看一下对Selenium的二次封装，比如一些点击的操作，为了确保操作对象的存在，这里会先隐式判断元素是否存在，如果存在再点击</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@run_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">waitxpath</span><span class="params">(self, xpath)</span>:</span></span><br><span class="line">   <span class="keyword">try</span>:</span><br><span class="line">       WebDriverWait(self.driver, WAITTIME, <span class="number">1</span>).until(</span><br><span class="line">           <span class="keyword">lambda</span> x: x.find_element_by_xpath(xpath)</span><br><span class="line">       )</span><br><span class="line">   <span class="keyword">except</span>:</span><br><span class="line">       traceback.print_exc()</span><br><span class="line">       <span class="keyword">return</span> ERROR, <span class="string">'waif xpath 20s timeout, try again'</span></span><br><span class="line">   <span class="keyword">return</span> SUCCESS, <span class="string">'wait xpath finish'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@run_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choice_select</span><span class="params">(self, xpath, content, sleeptime=<span class="number">0</span>)</span>:</span></span><br><span class="line">   <span class="string">'''</span></span><br><span class="line"><span class="string">   Choick select element</span></span><br><span class="line"><span class="string">   :param xpath: select xpath</span></span><br><span class="line"><span class="string">   :param content: select value</span></span><br><span class="line"><span class="string">   '''</span></span><br><span class="line">   self.waitxpath(xpath)</span><br><span class="line">   select = Select(self.driver.find_element_by_xpath(xpath))</span><br><span class="line">   <span class="comment">#  select the value of text='xxx'</span></span><br><span class="line">   select.select_by_visible_text(content)</span><br><span class="line">   <span class="keyword">if</span> sleeptime:</span><br><span class="line">       time.sleep(sleeptime)</span><br></pre></td></tr></table></figure>
<h3 id="tkinter编写界面"><a class="markdownIt-Anchor" href="#tkinter编写界面"></a> tkinter编写界面</h3>
<p>为了方便使用，我还是 tkinter 编写了一个「很丑」的界面，之所以选择 tkinter 是因为它是 Python 的内置库，使用起来也比较简单。</p>
<p>使用 tkinter 制作界面有个关键点，就是不能让负责界面渲染的主线程执行耗时操作，不然，界面就会出现严重的卡顿现象，常规的做法就是开启一个新线程来负责耗时逻辑，然后通过全局变量在不同的线程之间传递数据，这个全局变量通常会定义为队列。</p>
<p>在登录不同平台时，如果遇到验证码也需要通过 tkinter 显示并获取验证码正确的值，此时可以使用 tkinter 的弹窗机制，弹出一个新窗口来显示验证码并获取验证码的真实值，实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PopUpCaptchWindow</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    弹出验证码窗口</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,master, imgpath)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        :param master: 父窗口</span></span><br><span class="line"><span class="string">        :param imgpath: 图像路径(验证码图片路径)</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        top=self.top=Toplevel(master)</span><br><span class="line">        self.l=Label(top,text=<span class="string">"请输入验证码："</span>)</span><br><span class="line">        self.l.pack()</span><br><span class="line"></span><br><span class="line">        im = Image.open(imgpath)</span><br><span class="line">        img = ImageTk.PhotoImage(im)</span><br><span class="line">        panel = Label(top, image=img)</span><br><span class="line">        panel.image = img</span><br><span class="line">        panel.pack(expand=<span class="string">"yes"</span>)</span><br><span class="line"></span><br><span class="line">        self.e=Entry(top)</span><br><span class="line">        self.e.pack()</span><br><span class="line">        self.b=Button(top,text=<span class="string">'确定'</span>,command=self.cleanup)</span><br><span class="line">        self.b.pack()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cleanup</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.value=self.e.get()</span><br><span class="line">        self.top.destroy()</span><br></pre></td></tr></table></figure>
<h2 id="尾"><a class="markdownIt-Anchor" href="#尾"></a> 尾</h2>
<p>AutoPublish 本质其实是与不同平台做对抗，如果平台登录规则变动或发送文章的规则变动，AutoPublish 的逻辑就会失去效果，这不只是 AutoPublish 会面临的问题，任何爬虫项目都会面对这样的问题。</p>
<p>​希望感兴趣的朋友为 AutoPublish 点个星，此外也欢迎关注 HackPython<br />
​<br />
最后再提一下，项目地址：<a href="https://github.com/ayuLiao/AutoPublish" target="_blank" rel="noopener">https://github.com/ayuLiao/AutoPublish</a></p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python对大脑成像数据进行可视化分析</title>
    <url>/blog/2019/10/21/%E4%BD%BF%E7%94%A8Python%E5%AF%B9%E5%A4%A7%E8%84%91%E6%88%90%E5%83%8F%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>译自：<a href="https://medium.com/coinmonks/visualizing-brain-imaging-data-fmri-with-python-e1d0358d9dba" target="_blank" rel="noopener">https://medium.com/coinmonks/visualizing-brain-imaging-data-fmri-with-python-e1d0358d9dba</a></p>
</blockquote>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>大脑是人类目前所知的最复杂的器官，为了很好的了解大脑这个器官，我们做了很多努力，核磁共振成像(Magnetic Resonance Image,MRI)技术就是其中的重要突破，通过MRI的方式，我们可以获得大脑的一些数据。</p>
<p>近年来，随着机器学习的兴起，医学数据与机器学习结合使用的情况越来越多，而要有效的使用好医学数据，其前提就是处理好这些数据，本文内容会重点介绍如何使用Python来处理与分析这些脑成像数据，不会涉及过多医学知识。</p>
<h2 id="smri与fmri"><a class="markdownIt-Anchor" href="#smri与fmri"></a> sMRI与fMRI</h2>
<p>脑成像相关的数据可以去SPM网站中下载，SPM的含义是统计参数映射(Statistical Paramtric Mapping)，MRI生成的数据其实就是一种参数映射数据，当然，更加方便的是在工作公众号中回复data3获得相应的数据与jupyter代码文件。</p>
<p>下载后，其中有4个文件，其中README开头的为描述文件，fM00223为功能性核磁共振(funciton MRI,fMRI)成像数据,sM00223为结构性核磁共振(structural MRI, sMRI)成像数据。通过描述文件可知，这些数据是一个人躺在MRI机器上听「双音节词」时大脑的成像数据。</p>
<p>为了方便理解后面数据处理的内容，有必要理解sMRI与fMRI是什么以及两者的差异。</p>
<h3 id="结构性核磁共振smri"><a class="markdownIt-Anchor" href="#结构性核磁共振smri"></a> 结构性核磁共振(sMRI)</h3>
<p>因为人的体内存有大量的水分子，而水分子中还有氢原子，sMRI其实就是利用氢原子来成像，这意味着人身体中的内脏、软组织等含有高水分与脂肪的器官会被清楚的扫描出来，而大脑就是这样的一个器官，通过sMRI可以清晰的看到大脑中的密集结构与大量细节，但sMRI的成像无法观察到大脑的运动情况，即无法判断那些部位目前是比较活跃的，只能给出大脑的结构细节。</p>
<p>如下图，科学家利用sMRI对人体腹腔进行成像，从图可以看出，腹腔的结构很明显。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190829112912.png" alt="" /></p>
<h3 id="功能性核磁共振fmri"><a class="markdownIt-Anchor" href="#功能性核磁共振fmri"></a> 功能性核磁共振(fMRI)</h3>
<p>为了弥补sMRI的缺陷，fMRI应运而出，fMRI主要通过血氧浓度水平依赖(Blood-oxygen-level dependent，BOLD)来成像，一个器官的某个部位活跃，此时这个器官的这个部位就需要消耗更多的氧气，以此为依据，来进行成像。</p>
<p>通过fMRI的方式，我们可以很好的判断出大脑此时那些区域是活跃的，但这种活动并不等同于神经活动，但fMRI也有缺陷，即它的成像会损失大量的细节。</p>
<p>如下图，科学家通过fMRI，利用BOLD探索大脑活跃区域。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190829113145.png" alt="" /></p>
<p>但从图中可以看出，大脑的细节几乎看不清晰，所以目前常规的方式是使用sMRI对大脑结构进行成像，而fMRI对大脑活跃区域进行成像。</p>
<h2 id="smri数据可视化处理"><a class="markdownIt-Anchor" href="#smri数据可视化处理"></a> sMRI数据可视化处理</h2>
<p>通常，神经影像文件都会以相应的规律将数据存储在固定文件格式的文件中，我们可以通过NiBabel库来读/写常见的神经影像文件中的数据。</p>
<p>sMRI对应的数据在sM00223文件夹下，进入文件夹可以发现有两种不同文件格式的数据，分别是.img与.hdr，这其实是医学影像领域常见的格式，主要用于「分析」，其中，.img作为数据文件，包含二进制的图像资料，而.hdr作为头文件，包含图像的元数据，但这两种格式现在逐渐被.nifti格式代替，这是因为.hdr头文件难以完全真实反映元数据。</p>
<p>使用NiBabel将sMRI获得的数据载入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> nibabel</span><br><span class="line"></span><br><span class="line"><span class="comment"># sM0223对应的文件</span></span><br><span class="line">data_path = <span class="string">'./fMRI_data/sM00223/'</span></span><br><span class="line">files = os.listdir(data_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取其中的数据</span></span><br><span class="line">data_all = []</span><br><span class="line"><span class="keyword">for</span> data_file <span class="keyword">in</span> files:</span><br><span class="line">    <span class="keyword">if</span> data_file[<span class="number">-3</span>:] == <span class="string">'hdr'</span>:</span><br><span class="line">        data = nibabel.load(data_path + data_file).get_data() </span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印数据维数</span></span><br><span class="line">print(data.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -------结果</span></span><br><span class="line">(<span class="number">256</span>, <span class="number">256</span>, <span class="number">54</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>可以看出，sMRI产生的是4维数据，但第4维其实没有包含任何信息，其说明了sMRI每次扫描会产生54个数据切片，每个切片对应图像的大小为256x256个体素。</p>
<blockquote>
<p>体素：类似像素，像素表示的是二维图像的最小单位，而体素则用于三维成像空间。</p>
</blockquote>
<p>为了方面可视化每个切片的数据，可以简单处理一下数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">data = np.rot90(data.squeeze(), <span class="number">1</span>)</span><br><span class="line">print(data.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -------结果</span></span><br><span class="line">(<span class="number">256</span>, <span class="number">256</span>, <span class="number">54</span>)</span><br></pre></td></tr></table></figure>
<p>上述代码中，先通过numpy.squeeze()删除了数组中的单维条目，此时无用的第四维会被删除，接着使用numpy.rot90()将数组逆时针旋转了90度。</p>
<p>简单处理后，直接使用Matplotlib对每10个切片中的一个切片进行数据的绘制。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 6 个子图，不清楚其中概念，可以看本公众号关于Matplotlib的文章</span></span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">6</span>, figsize=[<span class="number">18</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">n = <span class="number">0</span></span><br><span class="line">slice = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    ax[n].imshow(data[:, :, slice], <span class="string">'gray'</span>)</span><br><span class="line">    ax[n].set_xticks([])</span><br><span class="line">    ax[n].set_yticks([])</span><br><span class="line">    ax[n].set_title(<span class="string">'Slice number: &#123;&#125;'</span>.format(slice), color=<span class="string">'r'</span>)</span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line">    slice += <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">fig.subplots_adjust(wspace=<span class="number">0</span>, hspace=<span class="number">0</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190901183337.png" alt="" /></p>
<p>这就是通过sMRI数据绘制出的大脑结构图了，其中第0层切片是最低的一个(接近脖子位置)，而第50层切片是最高的一个(接近头顶)，在第20层，可以看具有眼睛的切片。</p>
<h2 id="fmri数据可视化处理"><a class="markdownIt-Anchor" href="#fmri数据可视化处理"></a> fMRI数据可视化处理</h2>
<p>阅读README.txt可知fM00223数据集中，每张图像的大小为64x64个体素，采集的片数为64以及采集的卷数为96。知道了这些信息，就可以对fM00223数据集中的数据进行重构。</p>
<p>打开fM00223文件夹，可以发现确实正好有96个Hdr文件，这意味着每个文件包含了一个卷的所有片。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># fMRI数据的基本信息</span></span><br><span class="line">x_size = <span class="number">64</span></span><br><span class="line">y_size = <span class="number">64</span></span><br><span class="line">n_slice = <span class="number">64</span></span><br><span class="line">n_volumes = <span class="number">96</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得所有文件</span></span><br><span class="line">data_path = <span class="string">'./fMRI_data/fM00223/'</span></span><br><span class="line">files = os.listdir(data_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据并进行重塑</span></span><br><span class="line">data_all = []</span><br><span class="line"><span class="keyword">for</span> data_file <span class="keyword">in</span> files:</span><br><span class="line">    <span class="keyword">if</span> data_file[<span class="number">-3</span>:] == <span class="string">'hdr'</span>:</span><br><span class="line">        data = nibabel.load(data_path + data_file).get_data()</span><br><span class="line">        <span class="comment"># 将所有数据添加到list中，从而多了一个维度：时间维度      </span></span><br><span class="line">        data_all.append(data.reshape(x_size, y_size, n_slice))</span><br></pre></td></tr></table></figure>
<p>接着就可以通过Matplotlib可视化展示数据了，因为组成这些数据的是体素，是三维的图像，我们无法直接看到所有的数据，所有进行切片操作，通常会横切大脑从而获得冠状面(coronal)、横切面(transversal)和矢状面(sagittal)这3个平面，理解这三个概念很重要，如下图：</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190906222807.png" alt="" /></p>
<ul>
<li>冠状面为左，右方向将人体纵切为前后两部分的断面</li>
<li>横切面指横向水平切割的平面</li>
<li>矢状面是指将躯体纵断为左右两部分的解剖平面</li>
</ul>
<p>看一下下面的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建 3x6 的子图，大小为 18x11</span></span><br><span class="line">fig, ax = plt.subplots(<span class="number">3</span>, <span class="number">6</span>, figsize=[<span class="number">18</span>, <span class="number">11</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组织数据以冠状平面进行可视化，第四维度为时间维度，这里取第一个时间点</span></span><br><span class="line">coronal = np.transpose(data_all, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>])</span><br><span class="line">coronal = np.rot90(coronal, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组织数据以横切平面进行可视化</span></span><br><span class="line">transversal = np.transpose(data_all, [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>])</span><br><span class="line">transversal = np.rot90(transversal, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组织数据以矢状平面进行可视化</span></span><br><span class="line">sagittal = np.transpose(data_all, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">sagittal = np.rot90(sagittal, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化不同平面</span></span><br><span class="line">n = <span class="number">10</span></span><br><span class="line"><span class="comment"># 对每个切片的6个切面进行操作</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    ax[<span class="number">0</span>][i].imshow(coronal[:, :, n, <span class="number">0</span>], cmap=<span class="string">'gray'</span>)</span><br><span class="line">    ax[<span class="number">0</span>][i].set_xticks([])</span><br><span class="line">    ax[<span class="number">0</span>][i].set_yticks([])</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        ax[<span class="number">0</span>][i].set_ylabel(<span class="string">'coronal'</span>, fontsize=<span class="number">25</span>, color=<span class="string">'r'</span>)</span><br><span class="line">    n += <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">n = <span class="number">5</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    ax[<span class="number">1</span>][i].imshow(transversal[:, :, n, <span class="number">0</span>], cmap=<span class="string">'gray'</span>)</span><br><span class="line">    ax[<span class="number">1</span>][i].set_xticks([])</span><br><span class="line">    ax[<span class="number">1</span>][i].set_yticks([])</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        ax[<span class="number">1</span>][i].set_ylabel(<span class="string">'transversal'</span>, fontsize=<span class="number">25</span>, color=<span class="string">'r'</span>)</span><br><span class="line">    n += <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">n = <span class="number">5</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    ax[<span class="number">2</span>][i].imshow(sagittal[:, :, n, <span class="number">0</span>], cmap=<span class="string">'gray'</span>)</span><br><span class="line">    ax[<span class="number">2</span>][i].set_xticks([])</span><br><span class="line">    ax[<span class="number">2</span>][i].set_yticks([])</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        ax[<span class="number">2</span>][i].set_ylabel(<span class="string">'sagittal'</span>, fontsize=<span class="number">25</span>, color=<span class="string">'r'</span>)</span><br><span class="line">    n += <span class="number">10</span></span><br><span class="line"></span><br><span class="line">fig.subplots_adjust(wspace=<span class="number">0</span>, hspace=<span class="number">0</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190906221812.png" alt="" /></p>
<h2 id="尾"><a class="markdownIt-Anchor" href="#尾"></a> 尾</h2>
<p>感谢阅读，如果喜欢，点好看关注，如果有很想跟我说的话，欢迎直接跟我对话，个人微信：sighblue。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>自由职业之路-从每小时5美元的Upwork工作到百万美元跨境咨询业务</title>
    <url>/blog/2019/10/21/%E8%87%AA%E7%94%B1%E8%81%8C%E4%B8%9A%E4%B9%8B%E8%B7%AF-%E4%BB%8E%E6%AF%8F%E5%B0%8F%E6%97%B65%E7%BE%8E%E5%85%83%E7%9A%84Upwork%E5%B7%A5%E4%BD%9C%E5%88%B0%E7%99%BE%E4%B8%87%E7%BE%8E%E5%85%83%E8%B7%A8%E5%A2%83%E5%92%A8%E8%AF%A2%E4%B8%9A%E5%8A%A1/</url>
    <content><![CDATA[<blockquote>
<p>原文：<a href="https://www.sinostep.com/from-5USD-hourly-job-on-upwork-to-million-dollar-cross-border-consulting-business/" target="_blank" rel="noopener">https://www.sinostep.com/from-5USD-hourly-job-on-upwork-to-million-dollar-cross-border-consulting-business/</a></p>
</blockquote>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>从2011年以来，我一直在Upwork上从事工作，一开始，我的入门策略是定比较低的价格：每小时5美元，现在我是中国为数不多的高收入者之一。</p>
<blockquote>
<p>Upwork:一个全球性的自由职业平台，让企业和独立的专业人士可以进行远程连接与协作，Upwork原名为Elance-oDesk，2015年更名为Upwork。</p>
</blockquote>
<p>在过去的5年里， 我被邀请到10多个国家(如:美国，法国，比利时，墨西哥，泰国)进行商务旅行，我真的很喜欢这种工作方式(既能旅行，又能结交好友开拓眼界，还能赚钱，我感觉没人会不喜欢☺)</p>
<p>当我在Upwork赚了大约10万美元后，我自己的咨询业务也建立了，从此我不再单纯的依赖于自由职业者的市场。</p>
<p>当然，有时候我依然会从Upwork中找一些有趣的项目赚取一些零花钱。</p>
<p>我被很多网站、杂志和公司采访，现在越来越多国人知道我的故事。</p>
<p>我也被邀请到了知乎，经营一个关于自由职业者和创业公司的专栏，去年的11月，我被邀请到知乎的在线圆桌会议分享我对自由职业的见解和对中国跨境自由职业者的建议。</p>
<h2 id="我在upwork的第一份工作"><a class="markdownIt-Anchor" href="#我在upwork的第一份工作"></a> 我在Upwork的第一份工作</h2>
<p>我花了好多年才找到我的第一份工作，这是真的，我并没有开玩笑。</p>
<p>首先，我的母语并非英语，所以我很难深刻的理解Upwork这个平台中的游戏规则。</p>
<p>其次，我也怀疑Upwork是否可以成为自由职业者的金矿，如中国最大的自由职业市场：猪八戒就给了我非常差的印象，因为大多数人靠它根本无法过上体面的生活。</p>
<p>当我注册好账号后，一开始，我把自己的时薪定为30美元，然后发了一些提案，并相应收到了一些回复，但竞争实在太激烈了，我根本找不到工作。</p>
<p>在那个时候，我并不认为自己有某些很特殊的才能，我很难说服客户点击「租用」按钮。</p>
<p>后来，我开始发一些关于英文翻译与网站设计相关工作的提案，但我的竞争对手无处不在，尤其是来自与印度和菲律宾的竞争者。</p>
<p>让我感到荒谬的是，一个印度人会以一个很低的价格从西方客户那里获取英汉翻译的工作，然后再以更低的价格把这些工作外包给一个中国自由翻译者。</p>
<p>我并不想参与这样的游戏，但我真的很想知道那些成功的自由职业者到底是怎么赚到这么多钱的？</p>
<p>我改变了主意。</p>
<p>首先，我要学习Upwork是如何工作的，然后我才能靠它谋生。</p>
<p>我选择了最简单易行的策略：降低我的价格。</p>
<p>我在Upwork的第一份工作就是从Upwork获取快照资料，然后写出相应的内容，是的，我从一个德国客户手里开始了这项工作，每小时5美元。</p>
<p>这是一次非常愉快的经历，因为我才降低了一周的价格，它就对我产生作用了，这给了我很大的信心，让我愿意花更多时间在Upwork上。</p>
<h2 id="第二份工作-第三方工作-更多的工作以及我时薪的增长"><a class="markdownIt-Anchor" href="#第二份工作-第三方工作-更多的工作以及我时薪的增长"></a> 第二份工作、第三方工作、更多的工作…以及我时薪的增长</h2>
<blockquote>
<p>当你得到自己的第一份工作后，你就在前10%之列了</p>
</blockquote>
<p>大约90%在Upwork上的自由工作者其实没有从这个平台上获取过一分钱的收入，直到你接到第一单后，你才算真正的开始。</p>
<p>我很高兴我自己能接到第二份工作、第三份工作以及更多的工作。</p>
<p>我为自己定制了一个定价策略：每个月才去增加你的时薪，而不是每周</p>
<p>我就是这样做的，我从2011年11月起，每小时收费20美元，然后再2012年底，我每小时收费35美元，到2014年3月，我每小时收费变为了55美元，接着到2017年2月，我已经将我每小时的收费变为了300美元。</p>
<h2 id="规划我的咨询业务"><a class="markdownIt-Anchor" href="#规划我的咨询业务"></a> 规划我的咨询业务</h2>
<p>如果你能平衡好自己的工作与生活，增加时薪就会让你工作的更少而赚得更多。</p>
<p>如果你想过上体面的自由职业生活，你必须在早期阶段就进行一些长远的思考。我从Upwork获得第一份工作的那一天起就开始思考建立起自己的咨询业务了。</p>
<p>这看起来很有希望，因为我们可以发现有很多潜在客户，但我也知道，这是一条崎岖不平的道路，可是值得一试。</p>
<p>于是我通过WordPress建立了一个网站，并开始写博客。</p>
<h2 id="初始问题"><a class="markdownIt-Anchor" href="#初始问题"></a> 初始问题</h2>
<p>我每天都会问自己以下的的问题</p>
<ul>
<li>他们有什么问题需要解决？</li>
<li>为什么他们会有这些问题？</li>
<li>我怎样才能帮助他们？</li>
<li>我应该准备什么？</li>
<li>如何说服他们相信我？</li>
<li>其中有趣的部分是什么？</li>
</ul>
<h2 id="不仅仅只是工作还要研究与学习"><a class="markdownIt-Anchor" href="#不仅仅只是工作还要研究与学习"></a> 不仅仅只是工作，还要研究与学习</h2>
<p>实话说，当我在Upwork上接受越来越多工作时，我过的非常忙碌。</p>
<p>如果你已经有了一个既定的个人档案，当你将时薪调整到25~35美元时，不必太多担心，因为许多客户都是负担的起这样的定价的。</p>
<h3 id="制作一个吸引人的个人资料"><a class="markdownIt-Anchor" href="#制作一个吸引人的个人资料"></a> 制作一个吸引人的个人资料</h3>
<ul>
<li>1.让你的资料对潜在客户具有吸引力</li>
<li>2.列出你引以为豪的成功案例</li>
<li>3.使你的个人资料易于阅读</li>
</ul>
<h3 id="为你的客户思考"><a class="markdownIt-Anchor" href="#为你的客户思考"></a> 为你的客户思考</h3>
<ul>
<li>1.当你以客户的角度去思考问题时，你就能赢得他们的心。</li>
<li>2.详细说明你的技能以及你如何解决他人的问题</li>
</ul>
<h3 id="脱颖而出"><a class="markdownIt-Anchor" href="#脱颖而出"></a> 脱颖而出</h3>
<p>记住，只有10%的自由职业者才能在市场上找到工作，你需要去研究那些成功找到工作的人以及那些普通的人，比较他们的差异。</p>
<p>随时改善你的个人资料，让他人阅读并得到他们的反馈</p>
<h2 id="尽快找到你的第一份工作"><a class="markdownIt-Anchor" href="#尽快找到你的第一份工作"></a> 尽快找到你的第一份工作</h2>
<ul>
<li>1.只有当你找到第一份工作时，你才算真正开始了自由职业的旅程。</li>
<li>2.你要认真对待第一份工作的每一个建议。</li>
<li>3.你可以告诉他们(雇主)你的情况，甚至考虑给他们一些折扣。</li>
<li>4.即使第一个工作是一个简单的工作，也算是一个好的开始。</li>
</ul>
<h2 id="变得更好的秘诀"><a class="markdownIt-Anchor" href="#变得更好的秘诀"></a> 变得更好的秘诀</h2>
<p>当你得到越来越多工作时，你需要思考一下如何才能做得更好，这里有一些有用的建议。</p>
<h3 id="永远不要停止学习去发现自己的潜力"><a class="markdownIt-Anchor" href="#永远不要停止学习去发现自己的潜力"></a> 永远不要停止学习，去发现自己的潜力</h3>
<p>你需要去尝试不同的可能性，去与不同的客户见面，去接受挑战。</p>
<p>你可以从实际的工作中学到很多东西，这些东西可能是此前从未尝试过的。</p>
<p>找到最需要的技能并去学习他们。</p>
<h2 id="找到你的利基市场"><a class="markdownIt-Anchor" href="#找到你的利基市场"></a> 找到你的利基市场</h2>
<p>经过各种各样的试验和测试后，你会发现你自己喜欢做什么工作？你自己的市场在哪里？</p>
<h3 id="精心雕琢你的英语写作"><a class="markdownIt-Anchor" href="#精心雕琢你的英语写作"></a> 精心雕琢你的英语写作</h3>
<p>大多数职业者的工作需要远程交流，英语写作和口语能力都很重要，特别是写作能力。</p>
<p>学习如何使你的英语写作变得更具有说服力，写出更好的建议、档案、电子邮件、报告等等。</p>
<p>这不是一件容易的事情，但值得你花时间去做。</p>
<p>你的说服力就是你的武器和最好的推销员。</p>
<h2 id="建立你的个人品牌"><a class="markdownIt-Anchor" href="#建立你的个人品牌"></a> 建立你的个人品牌</h2>
<h3 id="使用你的真实姓名"><a class="markdownIt-Anchor" href="#使用你的真实姓名"></a> 使用你的真实姓名</h3>
<p>我不明白为什么有些自由职业者喜欢上传假的照片，或者假装自己是一个很有吸引力的女孩来赢得工作，这不是约会，而是建立你自己的生意。</p>
<p>我建议使用你的真实姓名和专业的真实照片，不要再用昵称以及卡通头像了。</p>
<p>谈到生意，信任是首要问题，只有当人信任你，他们才会去雇佣你。</p>
<h3 id="好的评价"><a class="markdownIt-Anchor" href="#好的评价"></a> 好的评价</h3>
<p>客户好的评价是你最好的广告，所以一定要尽力去赢得好的评价和推荐。</p>
<p>我承认，并不是所有客户都会给出真实的评价或意见，但大多数客户都是善良的，他们会给出真实的意见，从而帮你建立可靠的网络声誉，有了良好的声誉后，其他有需求的人就会来找你</p>
<h3 id="分析你的经验和专业知识"><a class="markdownIt-Anchor" href="#分析你的经验和专业知识"></a> 分析你的经验和专业知识</h3>
<p>不要隐藏你的专业知识，将它们写下来，并分享出来。</p>
<p>在我开始写博客后，我被邀请参加了各种会议，接受了采访，甚至写电子书和中国商业指南等，并且我因此认识了更多朋友，获得了更多的商业机会，这真的很棒。</p>
<h2 id="经营自己的咨询业务"><a class="markdownIt-Anchor" href="#经营自己的咨询业务"></a> 经营自己的咨询业务</h2>
<p>我从自由职业市场中获得了许多经验，这意味着我可以创建训练营来帮助新入行的朋友。我提高了我的写作和演讲技巧，发现了自己的潜力并找到了自己喜欢的利基市场。</p>
<h3 id="提高我的写作和演讲能力"><a class="markdownIt-Anchor" href="#提高我的写作和演讲能力"></a> 提高我的写作和演讲能力</h3>
<p>我通过日常使用来提高我的英语水平，我并不需要花费金钱去上某些课程。</p>
<p>对于非英语为母语的人而言，在电话或面对面的会议中讲英语是需要一定自信的，我们可以在工作中也尝试使用英语来解决这个问题。</p>
<p>这对我的中文写作和口语也起到了一定的帮助。</p>
<p>现在我每天都会写作，这已经成为了一种习惯。</p>
<h3 id="我的潜力"><a class="markdownIt-Anchor" href="#我的潜力"></a> 我的潜力</h3>
<p>我找到了很多有趣的工作，并学到了很多东西</p>
<p>我约到了许多好客户和有经验的商业顾问，与这些聪明的家伙一起工作可以帮助我进一步理解商业的本质。</p>
<p>现在我可以做很多我以前不知道的事情。</p>
<h3 id="我自己的小众市场"><a class="markdownIt-Anchor" href="#我自己的小众市场"></a> 我自己的小众市场</h3>
<p>中国市场是如此有利可图，这吸引了越来越多海外公司计划进入中国市场。</p>
<p>然而，许多中小企业和初创企业发现很难在中国选择适合的利基市场，面对文化与语言上的障碍，也难以制定出合适的策略，而一些跨国咨询公司(这类公司不多)就可以为此提供服务，而这也是我的机会。</p>
<h2 id="尾"><a class="markdownIt-Anchor" href="#尾"></a> 尾</h2>
<p>这篇文章后面的一些部分没有进行翻译，因为是作者介绍自己在跨国咨询这一领域提供的服务，如果想全面的了解，可以阅读原文。</p>
<p>文章中虽然没有非常细致的细节，但也看出了一个大致的路径。</p>
<p>先降低自己的起点，从小需求开始做，然后再慢慢成长并提高自己的价格，在这一过程中，你会积累一定的声誉，从而有了更广泛的信任基础，然后慢慢的再转到自己喜欢并擅长的领域。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190821150724.png" alt="" /></p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Web:Flask异步执行任务</title>
    <url>/blog/2019/10/21/Python-Web-Flask%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>Flask是Python中有名的轻量级同步web框架，在一些开发中，可能会遇到需要长时间处理的任务，此时就需要使用异步的方式来实现，让长时间任务在后台运行，先将本次请求的响应状态返回给前端，不让前端界面「卡顿」，当异步任务处理好后，如果需要返回状态，再将状态返回。</p>
<p>怎么实现呢？</p>
<h2 id="使用线程的方式"><a class="markdownIt-Anchor" href="#使用线程的方式"></a> 使用线程的方式</h2>
<p>当要执行耗时任务时，直接开启一个新的线程来执行任务，这种方式最为简单快速。</p>
<p>通过ThreadPoolExecutor来实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="comment"># DOCS https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor</span></span><br><span class="line"><span class="comment"># 创建线程池执行器</span></span><br><span class="line">executor = ThreadPoolExecutor(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/jobs')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_jobs</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 交由线程去执行耗时任务</span></span><br><span class="line">    executor.submit(long_task, <span class="string">'hello'</span>, <span class="number">123</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'long task running.'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 耗时任务</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_task</span><span class="params">(arg1, arg2)</span>:</span></span><br><span class="line">    print(<span class="string">"args: %s %s!"</span> % (arg1, arg2))</span><br><span class="line">    sleep(<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">"Task is done!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>
<p>当要执行一些比较简单的耗时任务时就可以使用这种方式，如发邮件、发短信验证码等。</p>
<p>但这种方式有个问题，就是前端无法得知任务执行状态。</p>
<p>如果想要前端知道，就需要设计一些逻辑，比如将任务执行状态存储到redis中，通过唯一的任务id进行标识，然后再写一个接口，通过任务id去获取任务的状态，然后让前端定时去请求该接口，从而获得任务状态信息。</p>
<p>全部自己实现就显得有些麻烦了，而Celery刚好实现了这样的逻辑，来使用一下。</p>
<h2 id="使用celery"><a class="markdownIt-Anchor" href="#使用celery"></a> 使用Celery</h2>
<p>为了满足前端可以获得任务状态的需求，可以使用Celery。</p>
<p>Celery是实时任务处理与调度的分布式任务队列，它常用于web异步任务、定时任务等，后面单独写一篇文章描述Celery的架构，这里不深入讨论。</p>
<p>现在我想让前端可以通过一个进度条来判断后端任务的执行情况。使用Celery就很容易实现，首先通过pip安装Celery与redis，之所以要安装redis，是因为让Celery选择redis作为「消息代理/消息中间件」。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install celery</span><br><span class="line">pip install redis</span><br></pre></td></tr></table></figure>
<p>在Flask中使用Celery其实很简单，这里先简单的过一下Flask中使用Celery的整体流程，然后再去实现具体的项目</p>
<ul>
<li>1.在Flask中初始化Celery</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="comment"># 配置</span></span><br><span class="line"><span class="comment"># 配置消息代理的路径，如果是在远程服务器上，则配置远程服务器中redis的URL</span></span><br><span class="line">app.config[<span class="string">'CELERY_BROKER_URL'</span>] = <span class="string">'redis://localhost:6379/0'</span></span><br><span class="line"><span class="comment"># 要存储 Celery 任务的状态或运行结果时就必须要配置</span></span><br><span class="line">app.config[<span class="string">'CELERY_RESULT_BACKEND'</span>] = <span class="string">'redis://localhost:6379/0'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化Celery</span></span><br><span class="line">celery = Celery(app.name, broker=app.config[<span class="string">'CELERY_BROKER_URL'</span>])</span><br><span class="line"><span class="comment"># 将Flask中的配置直接传递给Celery</span></span><br><span class="line">celery.conf.update(app.config)</span><br></pre></td></tr></table></figure>
<p>上述代码中，通过Celery类初始化celery对象，传入的应用名称与消息代理的连接URL。</p>
<ul>
<li>2.通过celery.task装饰器装饰耗时任务对应的函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@celery.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_task</span><span class="params">(arg1, arg2)</span>:</span></span><br><span class="line">    <span class="comment"># 耗时任务的逻辑</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<ul>
<li>3.Flask中定义接口通过异步的方式执行耗时任务</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    task = long_task.delay(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>delay()方法是apply_async()方法的快捷方式，apply_async()参数更多，可以更加细致的控制耗时任务，比如想要long_task()在一分钟后再执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    task = long_task.apply_async(args=[<span class="number">1</span>, <span class="number">2</span>], countdown=<span class="number">60</span>)</span><br></pre></td></tr></table></figure>
<p>delay()与apply_async()会返回一个任务对象，该对象可以获取任务的状态与各种相关信息。</p>
<p>通过这3步就可以使用Celery了。</p>
<p>接着就具体来实现「让前端可以通过一个进度条来判断后端任务的执行情况」的需求。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bind为True，会传入self给被装饰的方法</span></span><br><span class="line"><span class="meta">@celery.task(bind=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_task</span><span class="params">(self)</span>:</span></span><br><span class="line">    verb = [<span class="string">'Starting up'</span>, <span class="string">'Booting'</span>, <span class="string">'Repairing'</span>, <span class="string">'Loading'</span>, <span class="string">'Checking'</span>]</span><br><span class="line">    adjective = [<span class="string">'master'</span>, <span class="string">'radiant'</span>, <span class="string">'silent'</span>, <span class="string">'harmonic'</span>, <span class="string">'fast'</span>]</span><br><span class="line">    noun = [<span class="string">'solar array'</span>, <span class="string">'particle reshaper'</span>, <span class="string">'cosmic ray'</span>, <span class="string">'orbiter'</span>, <span class="string">'bit'</span>]</span><br><span class="line">    </span><br><span class="line">    message = <span class="string">''</span></span><br><span class="line">    total = random.randint(<span class="number">10</span>, <span class="number">50</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(total):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> message <span class="keyword">or</span> random.random() &lt; <span class="number">0.25</span>:</span><br><span class="line">            <span class="comment"># 随机的获取一些信息</span></span><br><span class="line">            message = <span class="string">'&#123;0&#125; &#123;1&#125; &#123;2&#125;...'</span>.format(random.choice(verb),</span><br><span class="line">                                              random.choice(adjective),</span><br><span class="line">                                              random.choice(noun))</span><br><span class="line">        <span class="comment"># 更新Celery任务状态</span></span><br><span class="line">        self.update_state(state=<span class="string">'PROGRESS'</span>,</span><br><span class="line">                          meta=&#123;<span class="string">'current'</span>: i, <span class="string">'total'</span>: total,</span><br><span class="line">                                <span class="string">'status'</span>: message&#125;)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 返回字典</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'current'</span>: <span class="number">100</span>, <span class="string">'total'</span>: <span class="number">100</span>, <span class="string">'status'</span>: <span class="string">'Task completed!'</span>,</span><br><span class="line">            <span class="string">'result'</span>: <span class="number">42</span>&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，celery.task()装饰器使用了bind=True参数，这个参数会让Celery将Celery本身传入，可以用于记录与更新任务状态。</p>
<p>然后就是一个for迭代，迭代的逻辑没什么意义，就是随机从list中抽取一些词汇来模拟一些逻辑的运行，为了表示这是耗时逻辑，通过time.sleep(1)休眠一秒。</p>
<p>每次获取一次词汇，就通过self.update_state()更新Celery任务的状态，Celery包含一些内置状态，如SUCCESS、STARTED等等，这里使用了自定义状态「PROGRESS」，除了状态外，还将本次循环的一些信息通过meta参数(元数据)以字典的形式存储起来。有了这些数据，前端就可以显示进度条了。</p>
<p>定义好耗时方法后，再定义一个Flask接口方法来调用该耗时方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/longtask', methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longtask</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 异步调用</span></span><br><span class="line">    task = long_task.apply_async()</span><br><span class="line">    <span class="comment"># 返回 202，与Location头</span></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;&#125;), <span class="number">202</span>, &#123;<span class="string">'Location'</span>: url_for(<span class="string">'taskstatus'</span>,</span><br><span class="line">                                                  task_id=task.id)&#125;</span><br></pre></td></tr></table></figure>
<p>简单而言，前端通过POST请求到/longtask，让后端开始去执行耗时任务。</p>
<p>返回的状态码为202，202通常表示一个请求正在进行中，然后还在返回数据包的包头(Header)中添加了Location头信息，前端可以通过读取数据包中Header中的Location的信息来获取任务id对应的完整url。</p>
<p>前端有了任务id对应的url后，还需要提供一个接口给前端，让前端可以通过任务id去获取当前时刻任务的具体状态。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/status/&lt;task_id&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">taskstatus</span><span class="params">(task_id)</span>:</span></span><br><span class="line">    task = long_task.AsyncResult(task_id)</span><br><span class="line">    <span class="keyword">if</span> task.state == <span class="string">'PENDING'</span>: <span class="comment"># 在等待</span></span><br><span class="line">        response = &#123;</span><br><span class="line">            <span class="string">'state'</span>: task.state,</span><br><span class="line">            <span class="string">'current'</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">'total'</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">'status'</span>: <span class="string">'Pending...'</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">elif</span> task.state != <span class="string">'FAILURE'</span>: <span class="comment"># 没有失败</span></span><br><span class="line">        response = &#123;</span><br><span class="line">            <span class="string">'state'</span>: task.state, <span class="comment"># 状态</span></span><br><span class="line">            <span class="comment"># meta中的数据，通过task.info.get()可以获得</span></span><br><span class="line">            <span class="string">'current'</span>: task.info.get(<span class="string">'current'</span>, <span class="number">0</span>), <span class="comment"># 当前循环进度</span></span><br><span class="line">            <span class="string">'total'</span>: task.info.get(<span class="string">'total'</span>, <span class="number">1</span>), <span class="comment"># 总循环进度</span></span><br><span class="line">            <span class="string">'status'</span>: task.info.get(<span class="string">'status'</span>, <span class="string">''</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'result'</span> <span class="keyword">in</span> task.info: </span><br><span class="line">            response[<span class="string">'result'</span>] = task.info[<span class="string">'result'</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 后端执行任务出现了一些问题</span></span><br><span class="line">        response = &#123;</span><br><span class="line">            <span class="string">'state'</span>: task.state,</span><br><span class="line">            <span class="string">'current'</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">'total'</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">'status'</span>: str(task.info),  <span class="comment"># 报错的具体异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> jsonify(response)</span><br></pre></td></tr></table></figure>
<p>为了可以获得任务对象中的信息，使用任务id初始化AsyncResult类，获得任务对象，然后就可以从任务对象中获得当前任务的信息。</p>
<p>该方法会返回一个JSON，其中包含了任务状态以及meta中指定的信息，前端可以利用这些信息构建一个进度条。</p>
<p>如果任务在PENDING状态，表示该任务还没有开始，在这种状态下，任务中是没有什么信息的，这里人为的返回一些数据。如果任务执行失败，就返回task.info中包含的异常信息，此外就是正常执行了，正常执行可以通task.info获得任务中具体的信息。</p>
<p>这样，后端的逻辑就处理完成了，接着就来实现前端的逻辑，要实现图形进度条，可以直接使用nanobar.js，简单两句话就可以实现一个进度条，其官网例子如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    classname: <span class="string">'my-class'</span>,</span><br><span class="line">  id: <span class="string">'my-id'</span>,</span><br><span class="line">  <span class="comment">// 进度条要出现的位置</span></span><br><span class="line">    target: <span class="built_in">document</span>.getElementById(<span class="string">'myDivId'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化进度条对象</span></span><br><span class="line"><span class="keyword">var</span> nanobar = <span class="keyword">new</span> Nanobar( options );</span><br><span class="line"></span><br><span class="line">nanobar.go( <span class="number">30</span> ); <span class="comment">// 30% 进度条</span></span><br><span class="line">nanobar.go( <span class="number">76</span> ); <span class="comment">// 76% 进度条</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 100% 进度条，进度条结束</span></span><br><span class="line">nanobar.go(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>有了nanobar.js就非常简单了。</p>
<p>先定义一个简单的HTML界面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Long running task with progress updates<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"start-bg-job"</span>&gt;</span>Start Long Calculation<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"progress"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过JavaScript实现对后台的请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按钮点击事件</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       $(<span class="string">'#start-bg-job'</span>).click(start_long_task);</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 请求 longtask 接口</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start_long_task</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 添加元素在html中</span></span><br><span class="line">            div = $(<span class="string">'&lt;div class="progress"&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;0%&lt;/div&gt;&lt;div&gt;...&lt;/div&gt;&lt;div&gt;&amp;nbsp;&lt;/div&gt;&lt;/div&gt;&lt;hr&gt;'</span>);</span><br><span class="line">            $(<span class="string">'#progress'</span>).append(div);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建进度条对象</span></span><br><span class="line">            <span class="keyword">var</span> nanobar = <span class="keyword">new</span> Nanobar(&#123;</span><br><span class="line">                bg: <span class="string">'#44f'</span>,</span><br><span class="line">                target: div[<span class="number">0</span>].childNodes[<span class="number">0</span>]</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ajax请求longtask</span></span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                type: <span class="string">'POST'</span>,</span><br><span class="line">                url: <span class="string">'/longtask'</span>,</span><br><span class="line">                <span class="comment">// 获得数据，从响应头中获取Location</span></span><br><span class="line">                success: <span class="function"><span class="keyword">function</span>(<span class="params">data, status, request</span>) </span>&#123;</span><br><span class="line">                    status_url = request.getResponseHeader(<span class="string">'Location'</span>);</span><br><span class="line">                    <span class="comment">// 调用 update_progress() 方法更新进度条</span></span><br><span class="line">                    update_progress(status_url, nanobar, div[<span class="number">0</span>]);</span><br><span class="line">                &#125;,</span><br><span class="line">                error: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    alert(<span class="string">'Unexpected error'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新进度条</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update_progress</span>(<span class="params">status_url, nanobar, status_div</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// getJSON()方法是JQuery内置方法，这里向Location中对应的url发起请求，即请求「/status/&lt;task_id&gt;」</span></span><br><span class="line">            $.getJSON(status_url, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 计算进度</span></span><br><span class="line">                percent = <span class="built_in">parseInt</span>(data[<span class="string">'current'</span>] * <span class="number">100</span> / data[<span class="string">'total'</span>]);</span><br><span class="line">                <span class="comment">// 更新进度条</span></span><br><span class="line">                nanobar.go(percent);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新文字</span></span><br><span class="line">                $(status_div.childNodes[<span class="number">1</span>]).text(percent + <span class="string">'%'</span>);</span><br><span class="line">                $(status_div.childNodes[<span class="number">2</span>]).text(data[<span class="string">'status'</span>]);</span><br><span class="line">                <span class="keyword">if</span> (data[<span class="string">'state'</span>] != <span class="string">'PENDING'</span> &amp;&amp; data[<span class="string">'state'</span>] != <span class="string">'PROGRESS'</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">'result'</span> <span class="keyword">in</span> data) &#123;</span><br><span class="line">                        <span class="comment">// 展示结果</span></span><br><span class="line">                        $(status_div.childNodes[<span class="number">3</span>]).text(<span class="string">'Result: '</span> + data[<span class="string">'result'</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 意料之外的事情发生</span></span><br><span class="line">                        $(status_div.childNodes[<span class="number">3</span>]).text(<span class="string">'Result: '</span> + data[<span class="string">'state'</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 2秒后再次运行</span></span><br><span class="line">                    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                        update_progress(status_url, nanobar, status_div);</span><br><span class="line">                    &#125;, <span class="number">2000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以通过注释阅读代码整体逻辑。</p>
<p>至此，需求实现完了，运行一下。</p>
<p>首先运行Redis</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure>
<p>然后运行celery</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">celery worker -A app.celery --loglevel=info</span><br></pre></td></tr></table></figure>
<p>最后运行Flask项目</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">python</span> app.<span class="keyword">py</span></span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190915220719.png" alt="" /></p>
<h1 id="尾"><a class="markdownIt-Anchor" href="#尾"></a> 尾</h1>
<p>Flask异步运行任务的常见方式就介绍完了，因为本人在开发一个用于自动生成字幕的小玩具，其中视频上传以及字幕生成都是耗时任务，所以就单独写一篇文章来介绍一下这部分的内容，后面会将小玩具的代码开源让大家学习一下，先一睹其真容：</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190916095203.png" alt="" /></p>
<p>如果你觉得文章有帮助，请按一下右下角的「在看」小星星，那是可以按的，谢谢。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能离真正的智能还很漫长</title>
    <url>/blog/2019/10/21/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%A6%BB%E7%9C%9F%E6%AD%A3%E7%9A%84%E6%99%BA%E8%83%BD%E8%BF%98%E5%BE%88%E6%BC%AB%E9%95%BF/</url>
    <content><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>在跟非IT行业的朋友解释人工智能总是一个比较费劲的事情，他们对这块也有比较大的误区，本人虽然不是什么知名人士，但也从事过一段时间相关内容的学习与研究，本篇文章就尝试从较高的层面去讨论一下人工智能以及它目前的局限。</p>
<p>我会以我比较擅长的NLP(自然语言处理)领域作为例子，下面都是我个人观点，如有不对，还请斧正。</p>
<h2 id="当前人工智能的本质"><a class="markdownIt-Anchor" href="#当前人工智能的本质"></a> 当前人工智能的本质</h2>
<p>我们常说的人工智能通常指的是深度学习，因为近年大数据的兴起，让深度学习大展拳脚，但深度学习「理论层面的东西并没有大的突破」，依旧是旧的东西，本质依旧是概率论与统计学。</p>
<p>这里以微软小冰、苹果Siri这些智能助手为例，它们的技术原理其实都是对话系统+语音识别。当我们说一句话给小冰时，小冰此时做了什么？</p>
<p>小冰接收到这句话时，首先会进行语音识别，所谓语音识别就是利用它此前训练好的概率模型，计算这些语音数据对应了哪些文字，然后再进行对话预测，即这些文字下一句出现概率最大的文字是哪些，「小冰本身并没有理解我说的话，它只是通过计算概率给出回答」。</p>
<p>训练一个可以商用的聊天机器需要很多工程技巧的支撑，但本质就是概率模型这么回事，我们可以从微博上、从论坛上爬取大量的语料数据，这些数据是我们正常人类在网上留下的，进行复杂的预处理后，得到训练数据，而训练大致就是从这些数据中找到文字之间的规律。</p>
<p>举个例子，比如一个100T的语料中，出现了很多次「快来关注HackPython」这句话，那么模型就会记住「关注」这个词后大概率要接「HackPython」，但模型并没有理解这句话，它并不知道「HackPython」是一个公众号，并不知道「快来关注」是一种宣传表述，它知道的就只有概率。</p>
<p>NLP领域中，无论是「LSTM」、「GRU」，还是「注意力机制」，亦或是当前比较热门的「知识图谱」，都是基于文本在玩概率游戏，不同的方式只是在使用训练数据的信息时不同。</p>
<p>当前所有知名模型的本质都是如此，通过矩阵运算训练数据来获得某种概率分布，复杂模型的概率分布通常是高维的，这里又会引申出各种数学方法，如测度论、流形，但本质的思想依旧是想通过概率分布来描述训练数据的特征。有了这些，对于同类的数据，就可以使用相同的概率分布去描述，从而实现所谓的「识别」。</p>
<p>获得了概率分布后，其实还有问题缠绕着我们，如：为什么会训练出这样的概率分布？</p>
<p>这块对我们来说依旧是黑盒，我们也不知道这些数据通过这种模型训练后，为什么是这样的概率分布，即不可解释。</p>
<p>不可解释性的问题让深度学习在某些领域的使用受到一定的障碍，如金融领域，模型说这样投，大概率赚钱，但你无法严格的去证明这个结论的可靠性，只能直观的去解释，这就会让人犹豫，毕竟可能损失大量金钱。</p>
<p>同样的，自动驾驶也受到模型不可解释带来的困扰，自动驾驶依赖于图像识别技术。通过大量数据训练出的图像识别模型虽然有很高的识别率，但依旧存在问题，这点从「对抗攻击」领域的研究可以看出，当我们改变图像中少量的数据，图像识别模型就无法识别或识别错误。因为我们无法从数据层面去解释图像识别模型的概率分布，所以不清楚它在什么情况会失效。</p>
<h2 id="识别与理解的差异"><a class="markdownIt-Anchor" href="#识别与理解的差异"></a> 识别与理解的差异</h2>
<p>通过前面的讨论，可以知道，目前的深度学习做到的是「识别」，如语言识别、图像识别等，而并没有做到「理解」，这点从NLP领域可以很直观的看出，最智能的对话系统表现的依旧强差人意。</p>
<p>我们通过大量的数据的训练，在「识别」上已经有了不错的效果，这些效果已经可以产生很大的作用，比如人脸识别用于安检领域、车牌识别用于交通系统等等，「但关于理解的工作可能才刚刚开始」。</p>
<p>人工智能并不像我们想象的那么智能，无论是多么大的公司，推出多么先进的框架，什么自动调参、什么自动学习等牛逼的功能，本质都是如此，先进的框架只是让我们更快、更好的获得可以描述数据特征的概率分布，而这些概率分布并不能实现「理解」。</p>
<p>我们思考一下，人类是怎么做到「理解」的？</p>
<p>我们「理解」某个东西，通常指知道其背后抽象的概念，如「苹果」这个词，当我们看到这个词时，脑中会浮现出「苹果」相关的信息，这些信息并不来自「苹果」这个词，而是来自我曾经经历的生活，这些生活给了我们相应的背景知识，而这些背景知识让我们可以理解「苹果」这个词。</p>
<p>这些背景知识我们是怎么得到的？目前也还在研究。</p>
<p>这让很多学者开始质疑当前深度学习的研究路径是否正确，这里给出一个著名的讨论来展现当下我们训练模型的方式与自然界中真正学习方式的巨大差异。</p>
<p>日本的街头有很多乌鸦，研究人员发现这些乌鸦会偷坚果来吃，但乌鸦本身无法破开坚果的壳，那它们是怎么吃到坚果果肉的呢？它们在电线杆上观察十字路口的红绿灯，当红灯的时候，将坚果放在马路上，然后飞走，等绿灯，绿灯时，车流走过，将坚果果壳碾碎，当下次红灯时，乌鸦再飞过去悠闲的吃其中的果肉。</p>
<p>这件普通的事情表现了生物的学习其实只需要简单的观察就可以习得某个技能，这与深度学习学习方式完全不同，深度学习会利用大量的数据，然后反复的训练试错，使用试错获得的损失，利用梯度下降与反向传播的算法去更新模型，最终得到可以描述数据特征的概率分布，而乌鸦没有那么多命去试错，也没有那么多时间去试错。</p>
<p>可以说，乌鸦通过少量的观察「理解」了红绿灯的规律，而深度学习获得的模型无法做到。</p>
<p>自然界生物的学习方式与当前深度学习主流的学习方式之间具有的差异难以不让人疑惑。</p>
<h2 id="莫拉维克悖论"><a class="markdownIt-Anchor" href="#莫拉维克悖论"></a> 莫拉维克悖论</h2>
<p>1980 年汉斯・莫拉维克提到：要让电脑如成人般地下棋是相对容易的，但是要让电脑有如一岁小孩般的感知和行动能力却是相当困难甚至是不可能的。这便是著名的莫拉维克悖论(Moravec’s paradox)，这个悖论在当下依旧适用，简单而言，「困难的问题是简单的，简单的问题是困难的」是当下人工智能的处境。</p>
<p>对计算机而言，实现逻辑推理、数学运算等人类高级智慧只需要相对很少的计算能力，而实现感知、运动等低等级智慧却需要巨大的计算资源，这刚好与人类相反，对于感知、运动等，我们自身并不用费多少脑子就可以做好，而逻辑推导、数学计算这类问题却需要思考很久。</p>
<p>如何让人工智能具有「理解」能力？如何让人工智能对真实世界有基本的背景知识与反应？</p>
<p>当这两个问题解决了，我们才需要开始担心，人类会不会被人工智能取代。</p>
<p>但，深度学习带来的对数据特征的描述能力已经可以对一些职业产生致命的冲击，如工厂的工人，加了图像识别的机械臂可以很好的代替工人的大部分工作。</p>
<h2 id="尾"><a class="markdownIt-Anchor" href="#尾"></a> 尾</h2>
<p>如果你担心一种技术或某件事情会对自己的产生影响，最好的方法就是去了解它，弄明白它的原理，而不是看各种媒体文章，他们只能扰乱视线，增加游戏难度。知道原理后，无知带来的担忧就会消散，自己也可以做出相应的调整。</p>
<p>文章虽然主要从NLP的角度去讨论问题，但这些现象存在于不同的领域，如图像处理、强化学习等。</p>
<p>最后，感谢阅读。</p>
]]></content>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>动手实现一个简单的Celery</title>
    <url>/blog/2019/10/21/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Celery/</url>
    <content><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>Celery是一个由Python实现的分布式任务队列，任务队列通常有3个方面的功能。</p>
<ul>
<li>1.减缓高并发压力，先将任务写入队列，有空余资源再运行</li>
<li>2.执行定时任务，先将任务写入队列，指定时间下再执行</li>
<li>3.异步任务，web中存在耗时任务可以先将其写入队列，然后后台任务进程去执行</li>
</ul>
<p>已经有很多文章来描述Celery的用法与简单原理，本篇文章也会简单提及，但不会费太多笔墨。</p>
<p>本篇重点在于，利用Python动手实现一个简单的Celery，并使用自己实现的Celery实现异步任务，与上一篇「Python Web:Flask异步执行任务」一样，通过Flask构建一个简单的web，然后执行耗时任务，希望前端可以通过进度条显示任务的进度。</p>
<p>需注意，这里不会去解读Celery的源码，其源码具有很多工程细节，比较复杂，这里只是从其本质出发，简单的实现一个玩具Celery，这个玩具Celery在稳定性、效率等方面当然不能与Celery相比，但可以很好的理解Celery大体是怎么实现的。</p>
<p>本文讲究的是「形离神合」，与Celery实现细节不同，但本质原理相同。</p>
<p>那我们开始吧！</p>
<h2 id="celery的概念与原理"><a class="markdownIt-Anchor" href="#celery的概念与原理"></a> Celery的概念与原理</h2>
<p>Celery 5 个关键的概念，弄明白，就大致理解 Celery 了。</p>
<ul>
<li>
<p>1.Task(任务)<br />
简单而言就是你要做的事情，如用户注册流程中的发送邮件</p>
</li>
<li>
<p>2.Worker(工作者)<br />
在后台处理Task的人</p>
</li>
<li>
<p>3.Broker(经纪人)<br />
本质是一种队列，Task 会交给 Broker ，Worker 会从 Broker 中取 Task ，并处理</p>
</li>
<li>
<p>4.Beat<br />
定时任务调度器，根据定的时间，向 Broker 中添加数据，然后等待 Worker 去处理</p>
</li>
<li>
<p>5.Backend<br />
用于保存 Worker 执行结果的对象，每个 Task 都要有返回值，这些返回值，就在 Backend 中</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190925100424.png" alt="" /></p>
<p>这里我们抛开这里的各种概念，从更本质的角度来看Celery，发现它就一个任务序列化存储与反序列化获取的过程。</p>
<p>以Web异步任务为例，使用方式通常为：</p>
<ul>
<li>1.有一个要长时间处理I/O的函数，如果不将其异步执行就会产生的阻塞，这通常是不被允许的</li>
<li>2.启动一个后台任务执行进程</li>
<li>3.当要执行耗时函数时，不会立刻同步运行，而是提取函数的关键数据，将其序列化存储到队列中，队列可以使用Redis或其他方式实现</li>
<li>4.后台任务执行进程会从队列中获取数据，并将其反序列化还原</li>
<li>5.后台任务执行进程会使用原来的函数以及还原的数据完成函数的执行，从而实现异步执行的效果。</li>
</ul>
<p>流程并不复杂，Celery中不同的概念分别负责上面流程中的不同部分。</p>
<h2 id="实现一个简单的celery"><a class="markdownIt-Anchor" href="#实现一个简单的celery"></a> 实现一个简单的Celery</h2>
<p>接着我们来实现一个Celery，这里Celery选择Redis作为后端。</p>
<p>先来整理一个大体的框架。</p>
<p>首先我们需要定义一个Task类来表示要执行的任务，不同的任务要执行的具体逻辑由使用者自身编写。</p>
<p>接着要定义一个任务队列，即Celery中的Broker，用于存储要执行的任务。</p>
<p>随后要定义执行进程Worker，Worker要从Broker中获取任务并去执行。</p>
<p>最后还需要定义一个用于存储任务返回数据的类，即Celery中的Backend。</p>
<p>看上去有点复杂，不慌，其实很简单。</p>
<h3 id="实现任务类"><a class="markdownIt-Anchor" href="#实现任务类"></a> 实现任务类</h3>
<p><a href="http://xn--task-ko8fn16c8ntmpwy41f.py" target="_blank" rel="noopener">首先来实现task.py</a>，用于定义任务相关的一些逻辑</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># task.py</span></span><br><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> broker <span class="keyword">import</span> Broker</span><br><span class="line"><span class="keyword">from</span> backend <span class="keyword">import</span> Backend</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseTask</span><span class="params">(abc.ABC)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Example Usage:</span></span><br><span class="line"><span class="string">        class AdderTask(BaseTask):</span></span><br><span class="line"><span class="string">            task_name = "AdderTask"</span></span><br><span class="line"><span class="string">            def run(self, a, b):</span></span><br><span class="line"><span class="string">                result = a + b</span></span><br><span class="line"><span class="string">                return result</span></span><br><span class="line"><span class="string">        adder = AdderTask()</span></span><br><span class="line"><span class="string">        adder.delay(9, 34)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    task_name = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.task_name:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"task_name should be set"</span>)</span><br><span class="line">        self.broker = Broker()</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @abc.abstractmethod # abstractmethod 派生类必须重写实现逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 写上你具体的逻辑</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">"Task `run` method must be implemented."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新任务状态</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_state</span><span class="params">(self, task_id, state, meta=&#123;&#125;)</span>:</span></span><br><span class="line">        _task = &#123;<span class="string">"state"</span>: state, <span class="string">"meta"</span>: meta&#125;</span><br><span class="line">        serialized_task = json.dumps(_task)</span><br><span class="line">        backend = Backend()</span><br><span class="line">        backend.enqueue(queue_name=task_id, item=serialized_task)</span><br><span class="line">        print(<span class="string">f"task info: <span class="subst">&#123;task_id&#125;</span> succesfully queued"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 异步执行</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delay</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.task_id = str(uuid.uuid4())</span><br><span class="line">            _task = &#123;<span class="string">"task_id"</span>: self.task_id, <span class="string">"args"</span>: args, <span class="string">"kwargs"</span>: kwargs&#125;</span><br><span class="line">            serialized_task = json.dumps(_task)</span><br><span class="line">            <span class="comment"># 加入redis中</span></span><br><span class="line">            self.broker.enqueue(queue_name=self.task_name, item=serialized_task)</span><br><span class="line">            print(<span class="string">f"task: <span class="subst">&#123;self.task_id&#125;</span> succesfully queued"</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="comment"># traceback.print_exc()</span></span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Unable to publish task to the broker."</span>)</span><br><span class="line">        <span class="keyword">return</span> self.task_id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">async_result</span><span class="params">(task_id)</span>:</span></span><br><span class="line">    backend = Backend()</span><br><span class="line">    _dequeued_item = backend.dequeue(queue_name=task_id)</span><br><span class="line">    dequeued_item = json.loads(_dequeued_item)</span><br><span class="line">    state = dequeued_item[<span class="string">"state"</span>]</span><br><span class="line">    meta = dequeued_item[<span class="string">"meta"</span>]</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Info</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, state, meta)</span>:</span></span><br><span class="line">            self.state = state</span><br><span class="line">            self.meta = meta</span><br><span class="line">    info = Info(state, meta)</span><br><span class="line">    <span class="keyword">return</span> info</span><br></pre></td></tr></table></figure>
<p>上述代码中，定义了BaseTask类，它继承自python的abc.ABC成为一个抽象基类，其中一开始便要求必须定义task_name，这是因为后面我们需要通过task_name去找对应的任务队列。</p>
<p>BaseTask类的run()方法被abc.abstractmethod装饰，该装饰器会要求BaseTask的派生类必须重写run()方法，这是为了让使用者可以自定义自己的任务逻辑。</p>
<p>BaseTask类的update_state()方法用于更新任务的状态，其逻辑很简单，先将参数进行JSON序列化，然后调用Backend的enqueue()方法将数据存入，这里的Backend其实是Redis实例，enqueue()方法会将数据写入Redis的list中，需要注意，这里list的key为task_id，即当前任务的id。</p>
<p>BaseTask类的delay()方法用于异步执行任务，首先通过uuid为任务创建一个唯一id，然后将方法的参数通过JSON序列化，然后调用Broker的enqueue()将数据存入，这里的Broker其实也是一个Redis实例，enqueue()方法同样是将数据写入到Redis的list中，只是list的key为task_name，即当前任务的名称。</p>
<p>此外还实现了async_result()方法，该方法用于异步获取任务的数据，通过该方法可以获得任务的执行结果，或任务执行中的各种数据，数据的结构是有简单约定的，必须要有state表示当然任务的状态，必须要有meta表示当前任务的一些信息。</p>
<h3 id="实现broker与backend"><a class="markdownIt-Anchor" href="#实现broker与backend"></a> 实现Broker与Backend</h3>
<p>在task.py中使用了Broker与Backend，那接着就来实现一下这两个，先实现Broker。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># broker.py</span></span><br><span class="line"><span class="keyword">import</span> redis <span class="comment"># pip install redis</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Broker</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    use redis as our broker.</span></span><br><span class="line"><span class="string">    This implements a basic FIFO queue using redis.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        host = <span class="string">"localhost"</span></span><br><span class="line">        port = <span class="number">6379</span></span><br><span class="line">        password = <span class="literal">None</span></span><br><span class="line">        self.redis_instance = redis.StrictRedis(</span><br><span class="line">            host=host, port=port, password=password, db=<span class="number">0</span>, socket_timeout=<span class="number">8.0</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, item, queue_name)</span>:</span></span><br><span class="line">        self.redis_instance.lpush(queue_name, item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self, queue_name)</span>:</span></span><br><span class="line">        dequed_item = self.redis_instance.brpop(queue_name, timeout=<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> dequed_item:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        dequed_item = dequed_item[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dequed_item</span><br></pre></td></tr></table></figure>
<p>没什么可讲的，就是定了两个方法用于数据的存储与读取，存储使用lpush方法，它会将数据从左边插入到Redis的list中，读取数据使用brpop方法，它会从list的右边取出第一个元素，返回该元素值并从list删除，左进右出就构成了一个队列。</p>
<p>为了简便，Backend的代码与Broker一模一样，只是用来存储任务的信息而已，代码就不贴了。</p>
<h3 id="后台任务执行进程worker"><a class="markdownIt-Anchor" href="#后台任务执行进程worker"></a> 后台任务执行进程Worker</h3>
<p>接着来实现后台任务执行进程Worker</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># worker.py</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Example Usage:</span></span><br><span class="line"><span class="string">        task = AdderTask()</span></span><br><span class="line"><span class="string">        worker = Worker(task=task)</span></span><br><span class="line"><span class="string">        worker.start()</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, task)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.task = task</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self,)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                _dequeued_item = self.task.broker.dequeue(queue_name=self.task.task_name)</span><br><span class="line">                dequeued_item = json.loads(_dequeued_item)</span><br><span class="line">                task_id = dequeued_item[<span class="string">"task_id"</span>]</span><br><span class="line">                task_args = dequeued_item[<span class="string">"args"</span>]</span><br><span class="line">                task_kwargs = dequeued_item[<span class="string">"kwargs"</span>]</span><br><span class="line">                task_kwargs[<span class="string">'task_id'</span>] = task_id</span><br><span class="line">                self.task.run(*task_args, **task_kwargs)</span><br><span class="line">                print(<span class="string">"succesful run of task: &#123;0&#125;"</span>.format(task_id))</span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                print(<span class="string">"Unable to execute task."</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
<p>上述代码中，定义了Worker类，Worker类在初始化时需要指定具体的任务实例，然后从broker中获取任务相关的数据，接着调用其中的run()方法完成任务的执行，比较简单。</p>
<h3 id="使用玩具celery"><a class="markdownIt-Anchor" href="#使用玩具celery"></a> 使用玩具Celery</h3>
<p>玩具Celery的关键结构都定义好了，接着就来使用一下它，这里依旧会使用「Python Web:Flask异步执行任务」文章中的部分代码，如前端代码，这里也不再讨论其前端代码，没有阅读可以先阅读一下，方便理解下面的内容。</p>
<p>首先定义出一个耗时任务</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># app.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LongTask</span><span class="params">(BaseTask)</span>:</span></span><br><span class="line"></span><br><span class="line">    task_name = <span class="string">"LongTask"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, task_id)</span>:</span></span><br><span class="line">        <span class="string">"""Background task that runs a long function with progress reports."""</span></span><br><span class="line">        verb = [<span class="string">'Starting up'</span>, <span class="string">'Booting'</span>, <span class="string">'Repairing'</span>, <span class="string">'Loading'</span>, <span class="string">'Checking'</span>]</span><br><span class="line">        adjective = [<span class="string">'master'</span>, <span class="string">'radiant'</span>, <span class="string">'silent'</span>, <span class="string">'harmonic'</span>, <span class="string">'fast'</span>]</span><br><span class="line">        noun = [<span class="string">'solar array'</span>, <span class="string">'particle reshaper'</span>, <span class="string">'cosmic ray'</span>, <span class="string">'orbiter'</span>, <span class="string">'bit'</span>]</span><br><span class="line"></span><br><span class="line">        message = <span class="string">''</span></span><br><span class="line">        total = random.randint(<span class="number">10</span>, <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(total):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> message <span class="keyword">or</span> random.random() &lt; <span class="number">0.25</span>:</span><br><span class="line">                message = <span class="string">'&#123;0&#125; &#123;1&#125; &#123;2&#125;...'</span>.format(random.choice(verb),</span><br><span class="line">                                                  random.choice(adjective),</span><br><span class="line">                                                  random.choice(noun))</span><br><span class="line">            self.update_state(task_id=task_id, state=<span class="string">'PROGRESS'</span>,</span><br><span class="line">                              meta=&#123;<span class="string">'current'</span>: i, <span class="string">'total'</span>: total,</span><br><span class="line">                                    <span class="string">'status'</span>: message&#125;)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        self.update_state(task_id=task_id, state=<span class="string">'FINISH'</span>, meta=&#123;<span class="string">'current'</span>:<span class="number">100</span>, <span class="string">'total'</span>: <span class="number">100</span>,<span class="string">'status'</span>: <span class="string">'Task completed!'</span>, <span class="string">'result'</span>:<span class="number">32</span>&#125;)</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>每个耗时任务都要继承在BaseTask并且重写其run()方法，run()方法中的逻辑就是当前这个耗时任务要处理的具体逻辑。</p>
<p>这里逻辑其实很简单，就是随机的从几个列表中抽取词汇而已。</p>
<p>在for迭代中，想要前端知道当前任务for迭代的具体情况，就需要将相应的数据通过BaseTask的update_state()方法将其更新到backend中，使用task_id作为Redis中list的key。</p>
<p>当逻辑全部执行完后，将状态为FINISH的信息存入backend中。</p>
<p>写一个接口来触发这个耗时任务</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># app.py</span></span><br><span class="line"><span class="meta">@app.route('/longtask', methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longtask</span><span class="params">()</span>:</span></span><br><span class="line">    long_task = LongTask()</span><br><span class="line">    task_id = long_task.delay()</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;&#125;), <span class="number">202</span>, &#123;<span class="string">'Location'</span>: url_for(<span class="string">'taskstatus'</span>,</span><br><span class="line">                                                  task_id=task_id)&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑非常简单，实例化LongTask()，并调用其中的delay()方法，该方法会将当前任务存入认为队列中，当前的请求会将当前任务的task_id通过响应包头的中的taskstatus字段传递给前端。</p>
<p>前端获取到后，就可以通过task_id去获取当前任务执行状态等信息，从而实现前端的可视化。</p>
<p>接着定义相应的接口来获取当前任务的信息，调用用async_result()方法，将task_id传入则可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># app.py</span><br><span class="line">@app.route(&apos;/status/&lt;task_id&gt;&apos;)</span><br><span class="line">def taskstatus(task_id):</span><br><span class="line">    info = async_result(task_id)</span><br><span class="line">    print(info)</span><br><span class="line">    if info.state == &apos;PENDING&apos;:</span><br><span class="line">        response = &#123;</span><br><span class="line">            &apos;state&apos;: info.state,</span><br><span class="line">            &apos;current&apos;: 0,</span><br><span class="line">            &apos;total&apos;: 1,</span><br><span class="line">            &apos;status&apos;: &apos;Pending...&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    elif info.state != &apos;FAILURE&apos;:</span><br><span class="line">        response = &#123;</span><br><span class="line">            &apos;state&apos;: info.state,</span><br><span class="line">            &apos;current&apos;: info.meta.get(&apos;current&apos;, 0),</span><br><span class="line">            &apos;total&apos;: info.meta.get(&apos;total&apos;, 1),</span><br><span class="line">            &apos;status&apos;: info.meta.get(&apos;status&apos;, &apos;&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">        if &apos;result&apos; in info.meta:</span><br><span class="line">            response[&apos;result&apos;] = info.meta[&apos;result&apos;]</span><br><span class="line">    else:</span><br><span class="line">        # something went wrong in the background job</span><br><span class="line">        response = &#123;</span><br><span class="line">            &apos;state&apos;: info.state,</span><br><span class="line">            &apos;current&apos;: 1,</span><br><span class="line">            &apos;total&apos;: 1,</span><br><span class="line">            &apos;status&apos;: str(info.meta),  # this is the exception raised</span><br><span class="line">        &#125;</span><br><span class="line">    return jsonify(response)</span><br><span class="line">```        </span><br><span class="line"></span><br><span class="line">最后，需要定义一个启动后台任务执行进程的逻辑</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"># run_worker.py</span><br><span class="line">from worker import Worker</span><br><span class="line">from app import LongTask</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    long_task = LongTask()</span><br><span class="line">    worker = Worker(task=long_task)</span><br><span class="line">    worker.start()</span><br><span class="line">```                  </span><br><span class="line"></span><br><span class="line">至此，整体结构就构建完了，使用一下。</span><br><span class="line"></span><br><span class="line">首先运行redis。</span><br></pre></td></tr></table></figure>
<p>redis-server</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">然后运行Flask。</span><br></pre></td></tr></table></figure>
<p>python <a href="http://app.py" target="_blank" rel="noopener">app.py</a></p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">最后启动一下后台任务执行进程，它相当于Celery的`celery -A xxx worker --loglevel=info`命令。</span><br></pre></td></tr></table></figure>
<p>python run_worker.py</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">同时执行多个任务，效果如下</span><br><span class="line"></span><br><span class="line">![](https:<span class="regexp">//</span>raw.githubusercontent.com<span class="regexp">/ayuLiao/im</span>ages<span class="regexp">/master/</span><span class="number">20190925094458</span>.png)</span><br><span class="line"></span><br><span class="line">对应的一些打印如下：</span><br></pre></td></tr></table></figure>
<p>python run_worker.py<br />
Unable to execute task.<br />
Unable to execute task.<br />
Unable to execute task.<br />
task info: 3c7cd8ac-7482-467b-b17c-dba2649b70ee succesfully queued<br />
task info: 3c7cd8ac-7482-467b-b17c-dba2649b70ee succesfully queued<br />
task info: 3c7cd8ac-7482-467b-b17c-dba2649b70ee succesfully queued<br />
task info: 3c7cd8ac-7482-467b-b17c-dba2649b70ee succesfully queued</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>python <a href="http://app.py" target="_blank" rel="noopener">app.py</a></p>
<ul>
<li>
<p>Serving Flask app “app” (lazy loading)</p>
</li>
<li>
<p>Environment: production<br />
WARNING: Do not use the development server in a production environment.<br />
Use a production WSGI server instead.</p>
</li>
<li>
<p>Debug mode: on</p>
</li>
<li>
<p>Running on <a href="http://127.0.0.1:5000/" target="_blank" rel="noopener">http://127.0.0.1:5000/</a> (Press CTRL+C to quit)</p>
</li>
<li>
<p>Restarting with stat</p>
</li>
<li>
<p>Debugger is active!</p>
</li>
<li>
<p>Debugger PIN: 145-285-706<br />
127.0.0.1 - - [25/Sep/2019 11:14:07] “GET / HTTP/1.1” 200 -<br />
task: 3c7cd8ac-7482-467b-b17c-dba2649b70ee succesfully queued<br />
127.0.0.1 - - [25/Sep/2019 11:14:11] “POST /longtask HTTP/1.1” 202 -<br />
&lt;task.async_result.<locals>.Info object at 0x107f50780&gt;<br />
127.0.0.1 - - [25/Sep/2019 11:14:11] “GET /status/3c7cd8ac-7482-467b-b17c-dba2649b70ee HTTP/1.1” 200 -<br />
&lt;task.async_result.<locals>.Info object at 0x107f50a20&gt;<br />
127.0.0.1 - - [25/Sep/2019 11:14:13] “GET /status/3c7cd8ac-7482-467b-b17c-dba2649b70ee HTTP/1.1” 200 -</p>
</li>
</ul>
<pre class="highlight"><code class="">
## 尾

需要注意一些，上面的代码中，使用Worker需要实例化具体的任务，此时任务实例与app.py中通过接口创建的任务实例是不同的，Worker利用不同的实例，使用相同的参数，从而实现执行效果相同的目的。

代码已上传Githu：https://github.com/ayuLiao/toy_celery

如果你觉得文章有帮助，请按一下右下角的「在看」小星星，那是可以按的，谢谢。




</code></pre>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>不如吃茶去</title>
    <url>/blog/2019/10/21/%E4%B8%8D%E5%A6%82%E5%90%83%E8%8C%B6%E5%8E%BB/</url>
    <content><![CDATA[<blockquote>
<p>这是一篇没什么用的随笔。</p>
</blockquote>
<p>我写文章的时候喜欢泡茶喝，这个习惯不知道什么时候开始有的，喝茶会让我内心更加平和，手指在键盘上飞舞时也更加灵动。</p>
<p>我不懂茶，只是喜欢那种「纯」的感觉，这种感觉是模糊的，并不透彻，我也难以用文字将其描述清楚，但喝了一口，人就会静下来。</p>
<p>相比于喝西洋咖啡，茶会多出一种文化的厚重感，这很有可能是心理作用。</p>
<p>闲来无事泡茶喝，脑中总会时不时浮现武侠高人煮茶笑谈天下的画面，便会有向往之情。</p>
<p>我泡茶十分随意，既不讲究水的使用，也不讲究茶叶的使用，更不讲究茶具的时候，电磁壶烧一壶热水，茶饼掰上小块，放入廉价的茶壶中，水入茶成，在热气腾腾之际，小品一口，将热气呼出，心神畅快。</p>
<p>凡喝茶之人定听过洗茶一说，所谓先洗而后饮之，所以我泡茶也会装模作样，先洗后饮，但洗茶其实并不一定能洗取茶中之杂物。</p>
<p>据查，洗茶出于北宋，主要用于洗去散茶表面杂质，从而诱发茶的香与味，但我总感觉洗茶一事形式意义大于实际意义，大多数工艺生产的茶叶，其污垢可能难以通过洗茶去除。</p>
<p>我自己偶尔会外出买一些茶，但通常会选择普洱茶饼，回想以前不喝茶时，买了两个2005年的普洱茶饼，本想带回给父亲喝，但他却不要，儿时自己对父亲的一个印象是喜喝茶，因为平常去看他，都有泡茶喝，万万没想到，他并不喜欢，只是没啥可喝，别人又送了很多茶，才泡来喝，他喜喝的应该是啤酒，所以两个茶饼只能自己享用。</p>
<p>我此前买茶多买铁盒子装的散茶，当时是我第一次买茶饼，喝了之后，感觉味道更浓郁，就喜欢上了。</p>
<p>前段时间，小青柑比较流行，也买了一盒回来喝，小青柑的味道比较特别，茶中含有青柑之味，喝起来会有青涩之感，偶尔泡来提神也是极佳的，唯有不足就是，一个小青柑对于我的廉价茶壶而言太大了，很多时候，泡一壶会有很重的茶与青柑之味，此时茶已非茶，过于浓郁的茶，喝起来难以让人喜欢。</p>
<p>现在我最常泡的茶其实并不是茶饼之茶，而是泰式手标茶，说来也巧，当时泰国之行，只是顺带买了一盒回来，并没有对其抱有什么期待，毕竟在我的印象中，泰国并不算一个有茶文化的国家，但买回来喝却别有一番味道。</p>
<p>泰式手标茶通常是袋装的，要泡时，直接取出一袋茶叶，往壶中一放，加水即可成茶，这种茶会带有微甜之味，而缺少茶本来的淡苦，甜味时常会让人感到愉悦，但苦涩有时也很重要。</p>
<p>那混着喝？我女友有时确实会混合着泡，但我个人并没有那么喜欢。</p>
<p>说来惭愧，品茶之友常言：「茶里乾坤大，壶中日月长」，我虽常喝茶，但连门径都未曾窥得。</p>
<p>茶道历史悠久，我有时会问自己，是否也要学一学茶道？</p>
<p>此前我一直以为茶道源于中国，但后来发现「中国无茶道，茶道源于日本，中国有的是茶艺。」</p>
<p>对我们中国人而言，茶只是开门七事之一：柴米油盐酱醋茶，它只是一个很生活化的东西，而「道」在传统文化中是很神圣的，所谓得道便可升仙，没人会将如此生活化的东西称为道，也没人会将自己高超的技艺称为道。</p>
<p>在传统文化中，对某人高超技艺最高的褒奖就是「技近乎道」(出自&lt;庄子-养生篇&gt;，「庖丁解牛，技进乎道」)，所以我们更多将其称为「术」或「艺」，而很少称为「道」，而日本很喜欢定义各种道，但感觉更多只是喜欢那种仪式感以及那种仪式感创造出的氛围。</p>
<p>虽说中国无茶道，但却是丰厚茶文化的起源地，这其实才是茶道、茶艺的核心，其他的只是名词之争。</p>
<p>懂茶文化的人与我这种不懂茶文化的人，虽然都喝茶，但喝的肯定不是一种茶，这很好理解，懂音乐的听音乐会，懂艺术的鉴赏名画，跟不懂的人感受到肯定是不一样的。</p>
<p>如何获得这种高级体验呢？</p>
<p>这个话题太深刻了，此次不聊，吃茶去了。</p>
<p>对了，你平时喜欢喝什么茶呢？</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>详解Python import机制(一):import中的基本概念</title>
    <url>/blog/2019/10/21/%E8%AF%A6%E8%A7%A3Python-import%E6%9C%BA%E5%88%B6-%E4%B8%80-import%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>详解Python import机制(二):绝对导入与相对导入</title>
    <url>/blog/2019/10/21/%E8%AF%A6%E8%A7%A3Python-import%E6%9C%BA%E5%88%B6-%E4%BA%8C-%E7%BB%9D%E5%AF%B9%E5%AF%BC%E5%85%A5%E4%B8%8E%E7%9B%B8%E5%AF%B9%E5%AF%BC%E5%85%A5/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>一致性Hash算法</title>
    <url>/blog/2019/10/21/%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>本节简单讨论一下Hash(哈希)算法以及它的常见应用场景，之所以写此篇，是因为在群里看见相关的讨论。</p>
<p>Hash算法与一致性Hash其使用范围是很广泛的，本文抛砖引玉一下。</p>
<h2 id="hash算法"><a class="markdownIt-Anchor" href="#hash算法"></a> Hash算法</h2>
<p>什么是Hash算法？</p>
<p>一句话定义，将任意长度的二进制数据映射成固定长度的二进制值串，这种映射规则就是哈希算法。</p>
<p>想重头设计一个优秀Hash算法并不容易，它需要满足一些基本条件</p>
<ul>
<li>1.不可逆，无法通过Hash算法处理过的二进制值(哈希值)串反推出原始值</li>
<li>2.数据敏感，原始数据有一些微小的变化都会让Hash后的二进制值出现较大变化</li>
<li>3.冲突尽量小，根据「鸽巢原理」，任何Hash算法都不可能完全没有冲突，但优秀的Hash算法会让冲突的概率很小</li>
<li>4.效率高，Hash算法要可以比较高效的计算出哈希值</li>
</ul>
<p>什么是鸽巢原理？</p>
<p>很简单，总共只有10个巢，但却有11只鸽子，那么肯定会出现两个鸽子在同一个巢的情况。</p>
<p>引申到Hash算法中，因为Hash算法要将任意长度的二进制值都映射成固定长度的哈希值，固定长度哈希值其变化是有限的，而任意长度的原始数据是无限的，相当于有限的鸽巢与无限的鸽子，所以任意Hash算法在理论上都是无法避免冲突的，但Hash算法生成的哈希值越长，冲突的概率越小，但要生成越长的哈希值，需要的运算时间也就越长。</p>
<p>常见的Hash算法有很多，如MD5、SHA、AES等等</p>
<p>Hash算法有很多应用场景，如作为唯一标识、给密码安全加密等等，但为了配合文章主题，这里主要从分布式这个方向来讨论。</p>
<p>一个经典的问题：现在图库中有1亿张图片，你怎么可以快速判断某张图片是否存在于图库中？</p>
<h2 id="取模应用"><a class="markdownIt-Anchor" href="#取模应用"></a> 取模应用</h2>
<p>思考一下1亿图片图库是否存在某图片的问题。</p>
<p>1亿张图片，单台物理机没戏，所以需要多台物理机配合才能处理这种规模的数据。</p>
<p>具体怎么做？</p>
<p>先准备n台物理机，每台物理机只维护部分图片对应的散列表(利用散列算法，通过key可以快速找到value的一种数据结构)，我们每次从图库中读取一张图片，都利用Hash算法计算唯一标识，并利用这个唯一表示构建散列表的key，但问题是，一张图片的信息放在哪个物理机中呢？</p>
<p>搭建一个redis，如根据图片名称，如图片名称以1结尾的，放到1号物理机，其他的类推？这种方式并不好，最好的方式就是利用哈希与取模，具体做法如下：</p>
<p>我们每次从图库中取一张图片，利用Hash算法获得哈希值，这相当于图片的唯一标识，利用它与机器的个数n进行求余运算，取其模作为作为要操作物理机的编号，假设取模获得的值是x，则将图片的唯一标识与路径存放在第x个物理机中。</p>
<p>而查询一种图片是否存在图库中，其过程也类似，先对图片做Hash，获得哈希值后，求余取模获得对应的物理机编号，再去这台物理机，通过散列表判断这个哈希值是否存在，从而就可以判断图片是否存在。</p>
<p>通过上面的结构，就可以快速判断1亿图片图库是否存在某图片了。</p>
<p>这里再讨论一下1亿张图片大概需要多少物理机。</p>
<p>假设我们通过MD5处理，获得图片的MD5值，这个值会占128bit，即16字节，而文件路径长度上限为256字节，因为散列表会出现冲突的可能，所以还需要利用链表来解决冲突，而列表的指针预估占8个字节，这里对文件路径占的字节数取平均值来估算，一张图片构建散列表元素的大小大约需要152字节(256/2+16+8)。</p>
<p>一台物理机，内存如果为2GB，那么大概可以处理1400万张图片(2GB/152字节)，那处理1亿张图片，需要十几台物理机，这里还没有涉及装载因子的概念，所谓装载因子是指散列表中的数据超过装载因子定义的值，就需要进行扩容了。</p>
<blockquote>
<p>散列表:可以通过数组的方式来简单理解散列表，数组可以通过下标找到对应的值，其时间复杂度为O(1)，散列表也是如此，散列表会申请一段内存连续内存空间，然后通过散列函数获得下标，这个下标就可以定位出该内存空间的某个位置，其时间复杂度也为O(1)，散列函数没有Hash函数那么复杂，它只要求算法可以将对应的值比较平均的分配到对应的内存空间则可。</p>
</blockquote>
<h2 id="一致性hash"><a class="markdownIt-Anchor" href="#一致性hash"></a> 一致性Hash</h2>
<p>如果加多或减少一个物理机呢？</p>
<p>比如图库应用上线后，效果不错，图库图片增多到了1.1亿张了，此时就要增加物理机了，只是简单的增加一台物理机吗？</p>
<p>为了描述清楚，这里将情况简化一下，比如有2000万张图片在图库中，它们通过Hash函数求余取模的方式在两台物理机上构建了散列表，但此时图片增加到了3000w张，要增加多一台，此时就会出现取余求模的值发生变化。</p>
<p>原本，2台物理机时：Hash(a.jpg)%2 = 1</p>
<p>现在，3台物理机时：Hash(a.jpg)%3 = ???</p>
<p>可以发现，增加一台物理机后，原本构建的散列表也都失效了，需要对所有的3000w张图片进行Hash计算，重新构建散列表，这是非常不现实的。</p>
<p>这也是造成缓存雪崩的原因之一。</p>
<p>所谓缓存雪崩，当服务器增加时，此前的缓存全部失效，导致请求直接到达底层数据库，请求量一大，会让底层数据库崩溃，出现灾难性后果。</p>
<p>那怎么办？</p>
<p>使用一致性Hash则可。</p>
<p>解释一下一致性Hash，比如某种Hash算法，它映射出的哈希值有2<sup>32种取值可能(比如MD5，有2</sup>128种取值可能)，此时我们就可以构建出一个虚拟的哈希环</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191014231820.png" alt="" /></p>
<p>哈希环从0开始，顺时针方向增大，0的右侧第一个点表示1，以此类推，最后一个点位2^32-1，在0左侧第一个，哈希环上就表示了当前这种Hash算法所有可能的值。</p>
<p>接着利用Hash算法对服务器的特征值进行哈希运算，获得唯一的哈希值，这里可以选择服务器的IP或主机名等关键字段，此时，服务器对应的哈希值就会出现到哈希环上。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191014232014.png" alt="" /></p>
<p>回答一开始的图片问题，当一张图片来后，先计算其哈希值，然后将其放置到哈希环上，并沿着哈希环顺时针行走，其遇到的第一台服务器就是它要存储的服务器。</p>
<p>这就是一致性Hash的所有过程。</p>
<p>当某个服务器宕机了，此时，不需要对所有图像数据都重新进行Hash运算并构建新的散列表，而只需对宕机服务器中的数据进行上述操作。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191014232335.png" alt="" /></p>
<p>如果数据量增大，需要新增服务器，此时也不需要操作所有的数据。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191014232514.png" alt="" /></p>
<p>一致性Hash算法不像此前的求余取模方法，服务器数量的变动只会影响到部分服务器的数据，而不会影响全局数据。</p>
<h2 id="虚拟节点"><a class="markdownIt-Anchor" href="#虚拟节点"></a> 虚拟节点</h2>
<p>接着讨论一下虚拟节点的概念。</p>
<p>进行一致性Hash时，如果服务器太少，比如只有两台服务器，此时就容易出现数据倾斜，即大部分数据都让其中某一台服务器处理了。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191014232706.png" alt="" /></p>
<p>为了避免这种情况，就提出了虚拟节点的概念。</p>
<p>简单而言，就是为一台服务器构建多个逻辑上的节点，比如在服务器的IP后引入编号，从而获得不同的哈希值，这些哈希值都落在哈希环上构成虚拟节点，然后维护一张简单的映射表，保存虚拟节点与真实服务器之间的关系。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191014233034.png" alt="" /></p>
<p>真实数据依旧以同样的操作获得哈希值，然后落在哈希环上，只是它们遇到虚拟节点就停下来了，并将具体的数据交由虚拟节点对应的真实服务器去处理。</p>
<p>在实际应用中，虚拟节点设置的比较大，从而让少量的服务器也可以做相对均衡的数据分布处理。</p>
<h2 id="尾"><a class="markdownIt-Anchor" href="#尾"></a> 尾</h2>
<p>本人最近在恶补算法、计算机组成原理方面的知识以及在学习C++语言，所以更新的并不频繁。</p>
<p>希望在写公众号的这段时间里，与大家一同学习进步。</p>
<p>最后，如果内容对你有帮助，麻烦点一下「好看」，那是可以点击的，叩谢豪恩。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>一人利用无聊的技术构建商业网站</title>
    <url>/blog/2019/10/21/%E4%B8%80%E4%BA%BA%E5%88%A9%E7%94%A8%E6%97%A0%E8%81%8A%E7%9A%84%E6%8A%80%E6%9C%AF%E6%9E%84%E5%BB%BA%E5%95%86%E4%B8%9A%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<p>译自：<a href="https://broadcast.listennotes.com/the-boring-technology-behind-listen-notes-56697c2e347b" target="_blank" rel="noopener">https://broadcast.listennotes.com/the-boring-technology-behind-listen-notes-56697c2e347b</a></p>
<p>看作者如何轻松利用「Django+其他技术」构建一个商业网站。</p>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191018110459.png" alt="" /></p>
<p>Listen Note 是一个播客搜索引擎和数据库。Listen Note背后的技术其实非常简单无聊，没有使用什么人工智能、深度学习或区块链（任何人说自己使用了人工智能技术，他使用的都不是真正的人工智能）。</p>
<blockquote>
<p>播客，也称PodCast，是一种数字媒体，指一系列的音频、影片、电子电台或文字档以列表形式经互联网发布，然后听众经由电子设备订阅该列表以下载或流当中的电子文件，从而接收内容。</p>
</blockquote>
<p>读完这篇文章后，你应该也可以构建一个Listen Notes或者很轻松的做一些类似的事情。</p>
<p>你不需要雇很多员工，还记得Instagram被FaceBook以10亿美元收购的事情吗？当时Instagram才13个员工，而且并非全部都是工程师。</p>
<p>现在比以往任何时候都可能通过一个小型团队(甚至一个人)来构建一些有价值有意义的东西。</p>
<h2 id="listten-notes概览"><a class="markdownIt-Anchor" href="#listten-notes概览"></a> Listten Notes概览</h2>
<p>Listen Notes为用户提供了两样东西。</p>
<ul>
<li>1.一个网站，地址为：<a href="http://listennotes.com" target="_blank" rel="noopener">listennotes.com</a>，它提供了一个搜索引擎、一个播客数据库，还提供了稍后再听、播放列表、听播客片段(它允许你剪辑任何播客界面的一个片段，然后收听)以及播客监听提醒(互联网上的新播客中提到了你指定的关键字，它就会通知你)等功能</li>
<li>2.为开发者提供了播客搜索与目录的API，通过API可以了解用户的使用情况。</li>
</ul>
<p>我在AWS上运行了ListenNotes的所有东西，总共用了20台生产服务器(2019年5月5日为止)</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191018111835.png" alt="" /></p>
<p>从主机名就可以猜出，每个服务器是做什么的</p>
<ul>
<li>1.production-web(生产网服务器)：主要用于提供listennotes.com网络流量服务。</li>
<li>2.production-api(生产api服务器)：主要用于提供API服务，目前我运行了两个版本的API(v1api遗留版api与v2api新版api）</li>
<li>3.production-db(生产数据库)：使用PostgreSQL构建主从数据库</li>
<li>4.production-es(Elasticsearch集群)：主要负责搜索</li>
<li>5.production-worker(工作者)：主要用于运行各种离线任务(爬取最新的播客)，以保持播客数据库始终是最新的，并提供一些其他的小功能。</li>
<li>6.production-lb(负载均衡器)：使用了Redis与RabbitMQ这种简单方式构建（这不是一个理想的方案，但我从来不是一个完美的人)</li>
<li>7.production-pangu(盘古)用于运行一些一次性脚本以及进行测试的机器(这里的盘古就是盘古开天地的盘古，中国文化在国外还是很有吸引力的:))</li>
</ul>
<h2 id="后端"><a class="markdownIt-Anchor" href="#后端"></a> 后端</h2>
<p>整个后端使用 Django/Python3 编写，操作系统是Ubuntu。</p>
<p>使用uWSGI+Nginx来部署Django，Nginx也用来充当负载均衡器(这其实就是常见的Ubuntu+uWSGI+Nginx+Django的部署方案，不了解的，可以搜索一下，可以找到一大堆具体的操作)。</p>
<p>数据库主要使用PostgreSQL，我对PostgreSQL有多年的开发与运营经验，使用的比较好。</p>
<p>Redis用于不同目的，如用于缓存、统计等等</p>
<p>Elasticsearch负责整个网站的搜索，我使用Elasticsearch索引了网站中的播客与剧集，使用方式跟很多无聊的公司一样，没什么可说的。</p>
<p>我使用Celery来调度离线任务，用Supervisord来对服务器上进程进行管理。</p>
<p>为什么不用Docker/Kubernetes/Serverless这些技术？</p>
<p>没有必要，对于中小型公司而言，过度工程化是不好的。实际上，早在2014年，我就为我的雇主做过一些Docker早期的工作，这对于一个规模达到十亿美元的中型创业公司是一件好事，但对我这种一个人的创业公司，可能就有些过了。</p>
<h2 id="前端"><a class="markdownIt-Anchor" href="#前端"></a> 前端</h2>
<p>网站的前端主要使用 React+Redux+WebPack+ES构建，这是现在的标准做法。</p>
<p>当部署到生产环境时，我将JS包导出到Amazon S3上，并通过CloudFront提供CDN服务</p>
<blockquote>
<p>Amazon CloudFront 是由亚马逊网络服务系统提供基础服务的一个内容分发网络（CDN）。其在欧洲、亚洲、北美、澳洲、南美、美国多个主要大城市多地拥有自己的数据中心，共 107 个网络边际服务点提供服务。</p>
</blockquote>
<p>在listennotes.com这个网站上，大多数网页一半使用了Django模块一半使用了React程序。服务器渲染部分提供了web页面的样板，而客户端(浏览器端)部分基本上就是一个交互式web应用程序。</p>
<p>但有一些网页是完全同Django模板渲染呈现的，因为我懒得将事情做得太完美，而且这可能对SEO有一些好处。</p>
<h2 id="音乐播放器"><a class="markdownIt-Anchor" href="#音乐播放器"></a> 音乐播放器</h2>
<p>在listennotes网站上，我使用一个进过大量修改的开源音乐播放器react-media-player，这个播放器我使用在了多个地方，通过iframe简单嵌入在需要的页面就好了，非常简单。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191018114800.png" alt="" /></p>
<blockquote>
<p>react-media-player开源地址：<a href="https://github.com/souporserious/react-media-player" target="_blank" rel="noopener">https://github.com/souporserious/react-media-player</a></p>
</blockquote>
<h2 id="播客api"><a class="markdownIt-Anchor" href="#播客api"></a> 播客API</h2>
<p>listennotes为开发者提供了简单可靠的播客API，构建API类似于构建网站，后端使用了Django/Python来构建，前端使用了ReactJS，效果如下。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191018114954.png" alt="" /></p>
<p>对于API，我们需要跟踪记录使用API的用户在当前计费周期中使用了多少次请求，并在计费周期结束时收取相应的费用。</p>
<h2 id="devops"><a class="markdownIt-Anchor" href="#devops"></a> DevOps</h2>
<h3 id="机器配置与代码部署"><a class="markdownIt-Anchor" href="#机器配置与代码部署"></a> 机器配置与代码部署</h3>
<p>我使用Ansible进行服务器的部署，简单来说就写了一堆yaml文件来指定什么类型的服务器需要声明什么配置文件以及什么软件，下面是这些Ansible yaml文件的目录结构。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191018115219.png" alt="" /></p>
<p>我还使用Ansible将代码部署到生产环境汇总，基本上，我就在MacOS中运行一个部署脚本deploy.sh就可以了。</p>
<blockquote>
<p>Ansible：做Python运维必须知道的一个第三方库，简单而言，Ansible是一个简便的IT自动化引擎，有兴趣可以自行搜索了解一下，其生态丰富，有很多文档可以参考。</p>
</blockquote>
<p>deploy.sh接收3个参数，使用方式如下：</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">./deploy.sh</span> production HEAD web</span><br></pre></td></tr></table></figure>
<ul>
<li>1.Envireonment：用于区分你要部署的是生产环境还是staging环境</li>
<li>2.listennotes repo版本：HEAD是只部署最新的版本，如果指定的是git commite中的SHA，那么它就会部署一个特定的版本，这在我需要从一个错误部署中回滚到某个版本的代码来说非常有用。</li>
<li>3.Server kind服务器类型：有web、woker、api等不同服务器类型选择，我不需要同时部署所有的服务器，有时我对JavaScript代码进行了修改，我就只需要将其部署到web上，而不需要改动api与worker类型服务器</li>
</ul>
<blockquote>
<p>staging环境：通常一个web项目都需要一个staging环境，一来给客户做演示，二来可以作为 production server的一个 “预演”，正式发布新功能前能及早发现问题。</p>
</blockquote>
<p>部署的大部分过程由Ansible yaml配置文件精心安排，Ansible会自动去执行完这个流程，当然，这非常简单：</p>
<ul>
<li>1.在我的MacBook Pro上：如果要部署到web服务器上，就自动构建JavaScript包，并上传到Amazon S3上</li>
<li>2.在目标服务器上：通git，将对应的listennotes repo克隆到一个以时间戳命名的文件夹中，检查特定的版本，并通过pip安装新的Python依赖</li>
<li>3.在目标服务器上：将软连接(通过ln命令构建软连接)指向新的时间戳文件夹，并通过supervisorctl重启服务器</li>
</ul>
<p>整个工作我没有使用任何复杂的技术，只是利用了一些简单且实际的技术来实现这样的流程。</p>
<h3 id="监控与报警"><a class="markdownIt-Anchor" href="#监控与报警"></a> 监控与报警</h3>
<p>我使用DataDog服务进行监控与报警，它是一个SaaS服务，所以我并不需要做什么复杂的事情就可以得到一个简单仪表盘，并从中看都我服务器的各种指标。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191018121137.png" alt="" /></p>
<p>我将DataDog链接到PagerDuty，如果出了什么问题，PagerDuty会通过电话与短信的形式提醒我。</p>
<p>此外，我还使用Rollbar来关注Django代码的状况，它会捕捉代码意外产生的异常并通过email或Slack(Slack基于云的专有即时消息传递平台)来通知为通知我。</p>
<blockquote>
<p>Datadog 是云服务应用程序的监控服务，通过基于SaaS的数据分析平台提供对服务器，数据库，工具和服务的监控。<br />
PagerDuty 是一家美国云计算公司为IT部门提供SaaS事件的响应平台。<br />
Rollbar 可以自动化错误监视和筛选，开发人员可以在几分钟内修复重要的错误，并且可以快速、轻松地构建软件。<br />
这些都是SaaS服务，都是要花钱的:(</p>
</blockquote>
<p>我个人经常使用Slack，但公司只有我一个人，所以我不使用Slack与他人交流，而是通过Slack来监控有趣的应用程序级事件。</p>
<p>除了将DataDog和Rollbar与Slack集成，我还在Listen Notes后端代码中使用了Slack传入webhooks(网页钩子)，当用户注册或执行一些操作时，Slack就可以通知到我。</p>
<p>在2017年初推出ListeNote以来，只在2018年4月22日停电事故宕机了一次，那一次ListenNote网站关闭了4个小时，我损失了10个小时的生产数据，是一次重大的打击。此外ListeNote就没有出现过任何中断。</p>
<h2 id="发展"><a class="markdownIt-Anchor" href="#发展"></a> 发展</h2>
<p>我在旧金山的WeWork共享空间工作。</p>
<p>为什么不在家里?</p>
<p>我非常重视生产力，我愿意在生产力上投资，我不认为在家里摸鱼有助于软件开发(或任何类型的知识/创造性工作)。我很少一天工作超过8小时，我珍惜每一分钟。</p>
<p>因此，我需要一个漂亮且相对昂贵的私人办公室，我不愿花更多时间来节省这些钱，而更愿意花费一些钱利用更少的时间来赚钱。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20191018123014.png" alt="" /></p>
<p>我使用MacBook Pro进行开发工作，我在Vagrant+VirtualBox中运行了几乎与线上相同的环境，我同样使用Anserable yaml文件来部署Vagrant内部开发环境。</p>
<p>我将listennote的代码都托管到Github的私有repo中，我在主分支上做所有的开发工作，我很少使用功能分支。</p>
<p>我使用PyCharm编写并运行dev服务(Django runserver 和 webpack dev server)，这很无聊…我没有使用VS Code或Atom或其他很酷的IDE。</p>
<h2 id="保持冷静持续行动"><a class="markdownIt-Anchor" href="#保持冷静持续行动"></a> 保持冷静，持续行动</h2>
<p>正如你所见，我们生活在可以轻松创办公司的美好时代，有那么多现成的工具与服务，可以节省我们的时间和金钱，并提高我们的生产力，现在比以往任何时候都更能让一个小团队或一个人利用一些简单且无聊的技术来构建一些对世界有用的东西。</p>
<p>随着时间的推移，公司会越变越小，你不需要雇佣全职员工，你完全可以通过SaaS以及Upwork上找承包商来完成工作。</p>
<p>大多数时候，阻碍我们行动的就是过度思考，你会想，如果这个…如果那个…，其实你一点都不重要，每个人都在忙于自己的生活，没人关注你创建的东西，除非你证明你值得被别人关注。即使你完全搞砸了最初的产品发布，也很少有人会注意到。</p>
<p>Think big, start small, act fast.</p>
<p>使用一下无聊的技术开始做一些简单的事情是完全可以的，只要你能真正解决问题。</p>
<h2 id="尾"><a class="markdownIt-Anchor" href="#尾"></a> 尾</h2>
<p>国内很多文章都将做个东西描绘的复杂难懂，细节很多，而国外很多文章一上来就会说，这是个简单且无聊的东西，我更喜欢国外文章的氛围，不是说，技术一定都很简单，而是给人树立信息，对自己可以做的事情有信心是很好的事情。</p>
<p>如果我的文章对你有所帮助，请点一下「好看」，这对我这个小号而言非常重要，叩谢豪恩。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python进阶：浅析「垃圾回收机制」(下篇)</title>
    <url>/blog/2019/07/18/Python%E8%BF%9B%E9%98%B6%EF%BC%9A%E6%B5%85%E6%9E%90%E3%80%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E3%80%8D-%E4%B8%8B%E7%AF%87/</url>
    <content><![CDATA[<blockquote>
<p>HackPython致力于有趣有价值的编程教学</p>
</blockquote>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>Python垃圾回收机制本质就是对内存的操作机制，当程序需要长时间运行时，其内存的变化就变得关键，如果没有及时释放内存，即Python自动垃圾回收机制因为我们某些代码逻辑上的错误而导致某些内存一直不能被回收，从而造成程序的内存泄露。</p>
<p>Python为GC提供了扩展模块gc，利用gc模块提供的接口，可以查看到垃圾收集器的状态，垃圾收集器收集的对象、被收集对象的详细信息等。</p>
<p>在上篇中，我们简要的讨论了「垃圾回收机制」的原理，本篇则来讨论一下操作层面的内容。</p>
<h2 id="gc模块概况"><a class="markdownIt-Anchor" href="#gc模块概况"></a> gc模块概况</h2>
<p>虽说Python垃圾回收是自动的，不需要人为的干预，但人为干预的情况并不少见，如在游戏公司，为了提高Python运行的效率，Python GC被开发人员手动关闭，再在某些情况下打开，但默认情况下，Python GC通常只会在下面3种情况触发：</p>
<p>😯1.人为手动调用了 gc.coolect()<br />
😯2.GC的计数器到达阈值时<br />
😯3.Python程序退出时</p>
<p>我们可以利用gc模块来操作Python的GC，在具体操作前，先理解其提供方法的大致功能。</p>
<p>😗gc.isenabled() 判断Python程序在当前的状态的下是否已经打开自动垃圾回收机制，如果已经打开，该方法返回True。</p>
<p>😗gc.disable() 该方法用于关闭自动垃圾收集器，关闭自动垃圾收集器后，程序产生的垃圾对象(不可访问的对象)不会被自动回收，会持续的占用内存。</p>
<p>😗gc.collect([generation]) 显式进行垃圾回收，可以输入参数，0 代表只检查第一代的对象，1 代表检查一，二代的对象，2 代表检查一，二，三代的对象，如果不传参数，则启动完全的垃圾回收，也就是等于传 2。该方法会返回不可达对象的个数。</p>
<p>😗gc.set_debug(flags) 将垃圾收集器设置为调试状态，在该状态下，垃圾收集器会打印出收集到的所有对象信息并将不可访问的垃圾对象保存到 gc.garbage 列表中。</p>
<p>😗gc.set_threshold(threshold0[, threshold1[, threshold2])<br />
设置自动执行垃圾回收的频率。</p>
<p>😗gc.garbage列表，列表内部存放着垃圾收回器找到的不可达并且无法被释放的对象，通常这些对象会一直存在到程序结束，如果程序要长时间运行，如果gc.garbage列表中的对象一直在增多，容易造成内存泄露。</p>
<p>😗gc.is_tracked(obj) 该方法用于判断某个变量是否被垃圾回收器监控，如果是，则返回True，否则返回False，通常只有非原子类（如容器、用户自定义对象）会被监控，这是为了避免循环引用的情况出现。</p>
<p>😗gc.get_count() 获取当前自动执行垃圾回收的计数器，返回一个长度为 3 的列表</p>
<p>常用于set_debug()的flags:</p>
<p>🤓gc.DEBUG_STATS<br />
表示打印垃圾回收器回收完后的统计信息，当回收频率较高时，这些信息比较有利。</p>
<p>🤓gc.DEBUG_COLLECTABLE<br />
发现可回收对象时打印信息</p>
<p>🤓gc.DEBUG_UNCOLLECTABLE<br />
打印找到的不可回收对象的信息（指不能被回收器回收的不可达对象）。这些对象会被添加到 gc.garbage 列表中，即不可达又不能被释放的对象</p>
<p>🤓gc.DEBUG_SAVEALL<br />
设置后，所有垃圾回收器找到的不可达对象会被添加进 garbage 而不是直接被释放。这在调试一个内存泄漏的程序时会很有用。</p>
<p>🤓gc.DEBUG_LEAK<br />
调试内存泄漏的程序时，使回收器打印信息的调试标识位。（等价于 DEBUG_COLLECTABLE | DEBUG_UNCOLLECTABLE | DEBUG_SAVEALL ）</p>
<p>更多功能，可以参考官方文档：<a href="https://docs.python.org/zh-cn/3.8/library/gc.html" target="_blank" rel="noopener">gc — 垃圾回收器接口 — Python 3.8.0b2 文档</a></p>
<h2 id="内存泄露"><a class="markdownIt-Anchor" href="#内存泄露"></a> 内存泄露</h2>
<p>我们已经知道Python利用「标记-清除」算法来解决循环引用的情况，但在Python2.7中要依赖于对象的<code>__del__</code>方法，如果该方法被用户自定义了，则「标记-清除」就无法打破循环引用，从而出现不可达且不可释放的垃圾对象，一个具体的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'A del'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_leak</span><span class="params">()</span>:</span></span><br><span class="line">	c1 = A()</span><br><span class="line">	c2 = A()</span><br><span class="line">	<span class="comment"># 循环引用</span></span><br><span class="line">	c1.t = c2</span><br><span class="line">	c2.t = c1</span><br><span class="line">	<span class="comment"># 删去</span></span><br><span class="line">	<span class="keyword">del</span> c1</span><br><span class="line">	<span class="keyword">del</span> c2</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	test_leak()</span><br><span class="line">	<span class="comment"># collect() 显示触发垃圾回收，并获得不可达对象个数</span></span><br><span class="line">	print(gc.collect())</span><br><span class="line">	<span class="comment"># 不可释放的个数</span></span><br><span class="line">	print(len(gc.garbage))</span><br><span class="line">	print(gc.garbage)</span><br></pre></td></tr></table></figure>
<p>如果在Python2.7下运行上述代码，输出如下内容：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">2</span><br><span class="line">[&lt;__main__.A<span class="built_in"> instance </span>at 0x103faea70&gt;, &lt;__main__.A<span class="built_in"> instance </span>at 0x103faeab8&gt;]</span><br></pre></td></tr></table></figure>
<p>可以看出有2个变量是不可释放的，如果这类对象随着程序运行的时长而增加，就容易造成程序的内存泄露，从打印也可以知道，这两个对象是A类实例，而且观察A类中的<code>__del__</code>方法，其中的内容并</p>
<p>但这类问题在Python3.5及以上版本的Python中没有出现(没有测试Python3.5以下版本的Python)，在Python3.7下运行上面程序的结果如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">A del</span><br><span class="line">A del</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<p>从结果可以看出，Python3.7中已经将这一的问题修复了。</p>
<h2 id="python-gc-分代回收使用"><a class="markdownIt-Anchor" href="#python-gc-分代回收使用"></a> Python GC 分代回收使用</h2>
<p>Python为了保证GC的速度，使用了分代回收的策略，即不对变量立刻进行回收，在上篇中提及了其中的原理，在一轮 gc 扫描中存活下来的变量存到对应「代」的列表中，其分为第0代、第1代与第2代，存活到最后，gc扫描的频率就越低，直到触发对应的阈值。</p>
<p>gc 模快有一个自动垃圾回收的阀值，即通过 gc.get_threshold 函数获取到的长度为 3 的元组，其默认值为 (700,10,10)。每一次计数器的增加，gc 模块就会检查增加后的计数是否达到阀值的数目，如果是，就会执行对应的代数的垃圾检查，然后重置计数器<br />
例如，假设阀值是 (700,10,10)：</p>
<p>😳1.当计数器从 (699,8,0) 增加到 (700,8,0)，gc 模块就会执行 gc.collect(0), 即检查 0 代对象的垃圾，并重置计数器为 (0,9,0)</p>
<p>😳2.当计数器从 (699,9,0) 增加到 (700,9,0)，gc 模块就会执行 gc.collect(1), 即检查 1、2 代对象的垃圾，并重置计数器为 (0,0,1)</p>
<p>😳3.当计数器从 (699,9,9) 增加到 (700,9,9)，gc 模块就会执行 gc.collect(2), 即检查 0、1、2 代对象的垃圾，并重置计数器为 (0,0,0)</p>
<p>可以通过set_threshold()函数来设置不同代之间的阈值，从而实现控制gc扫描频率的目的，简单代码如下：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="title">threshold</span> = int(sys.argv[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">A</span>(<span class="title">object</span>):</span></span><br><span class="line"><span class="class">	def __init__(<span class="title">self</span>, <span class="title">name</span>):</span></span><br><span class="line"><span class="class">		self.name = name</span></span><br><span class="line"><span class="class">		print('<span class="type">Create</span>', <span class="title">self</span>.<span class="title">name</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"># 打印垃圾回收器回收完后的统计信息</span></span><br><span class="line"><span class="class">gc.set_debug(<span class="title">gc</span>.<span class="type">DEBUG_STATS</span>)</span></span><br><span class="line"><span class="class"># 设置分代回收阀值</span></span><br><span class="line"><span class="class">gc.set_threshold(<span class="title">threshold</span>, 1, 1)</span></span><br><span class="line"><span class="class">print('<span class="type">Thresholds</span>:', <span class="title">gc</span>.<span class="title">get_threshold</span>())</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">print('<span class="type">Clear</span> <span class="title">the</span> <span class="title">collector</span> <span class="title">by</span> <span class="title">forcing</span> <span class="title">a</span> <span class="title">run'</span>)</span></span><br><span class="line"><span class="class">gc.collect()</span></span><br><span class="line"><span class="class">print()</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">print('<span class="type">Creating</span> <span class="title">objects'</span>)</span></span><br><span class="line"><span class="class">alist = []</span></span><br><span class="line"><span class="class">for i in range(10):</span></span><br><span class="line"><span class="class">    alist.append(<span class="type">A</span>('<span class="type">A</span>'+<span class="title">str</span>(<span class="title">i</span>)))</span></span><br></pre></td></tr></table></figure>
<p>上述代码中，使用 set_debug()设置gc模块为debug模式，方便查看信息，再利用set_threshold()方法设置分代回收的阀值，从而控制Python GC的频率</p>
<p>简单使用一下，首先将分代回收阈值设置为 (100,1,1)</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">python</span> <span class="string">-u</span> <span class="string">test4.py</span> <span class="number">100</span></span><br><span class="line"><span class="attr">Thresholds:</span> <span class="string">(100,</span> <span class="number">1</span><span class="string">,</span> <span class="number">1</span><span class="string">)</span></span><br><span class="line"><span class="string">Clear</span> <span class="string">the</span> <span class="string">collector</span> <span class="string">by</span> <span class="string">forcing</span> <span class="string">a</span> <span class="string">run</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">collecting</span> <span class="string">generation</span> <span class="number">2</span><span class="string">...</span></span><br><span class="line"><span class="attr">gc: objects in each generation:</span> <span class="number">574</span> <span class="number">3814</span> <span class="number">0</span></span><br><span class="line"><span class="attr">gc: objects in permanent generation:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">done,</span> <span class="number">0.</span><span class="string">0004s</span> <span class="string">elapsed</span></span><br><span class="line"></span><br><span class="line"><span class="string">Creating</span> <span class="string">objects</span></span><br><span class="line"><span class="string">Create</span> <span class="string">A0</span></span><br><span class="line"><span class="string">Create</span> <span class="string">A1</span></span><br><span class="line"><span class="string">Create</span> <span class="string">A2</span></span><br><span class="line"><span class="string">Create</span> <span class="string">A3</span></span><br><span class="line"><span class="string">Create</span> <span class="string">A4</span></span><br><span class="line"><span class="string">Create</span> <span class="string">A5</span></span><br><span class="line"><span class="string">Create</span> <span class="string">A6</span></span><br><span class="line"><span class="string">Create</span> <span class="string">A7</span></span><br><span class="line"><span class="string">Create</span> <span class="string">A8</span></span><br><span class="line"><span class="string">Create</span> <span class="string">A9</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">collecting</span> <span class="string">generation</span> <span class="number">2</span><span class="string">...</span></span><br><span class="line"><span class="attr">gc: objects in each generation:</span> <span class="number">11</span> <span class="number">0</span> <span class="number">4260</span></span><br><span class="line"><span class="attr">gc: objects in permanent generation:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">done,</span> <span class="number">0.</span><span class="string">0004s</span> <span class="string">elapsed</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">collecting</span> <span class="string">generation</span> <span class="number">2</span><span class="string">...</span></span><br><span class="line"><span class="attr">gc: objects in each generation:</span> <span class="number">66</span> <span class="number">0</span> <span class="number">4177</span></span><br><span class="line"><span class="attr">gc: objects in permanent generation:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">done,</span> <span class="number">589</span> <span class="string">unreachable,</span> <span class="number">0</span> <span class="string">uncollectable,</span> <span class="number">0.</span><span class="string">0005s</span> <span class="string">elapsed</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">collecting</span> <span class="string">generation</span> <span class="number">2</span><span class="string">...</span></span><br><span class="line"><span class="attr">gc: objects in each generation:</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3029</span></span><br><span class="line"><span class="attr">gc: objects in permanent generation:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">done,</span> <span class="number">151</span> <span class="string">unreachable,</span> <span class="number">0</span> <span class="string">uncollectable,</span> <span class="number">0.</span><span class="string">0002s</span> <span class="string">elapsed</span></span><br></pre></td></tr></table></figure>
<p>接着将其设置小一些</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">python</span> <span class="string">-u</span> <span class="string">test4.py</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Thresholds:</span> <span class="string">(2,</span> <span class="number">1</span><span class="string">,</span> <span class="number">1</span><span class="string">)</span></span><br><span class="line"><span class="string">Clear</span> <span class="string">the</span> <span class="string">collector</span> <span class="string">by</span> <span class="string">forcing</span> <span class="string">a</span> <span class="string">run</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">collecting</span> <span class="string">generation</span> <span class="number">2</span><span class="string">...</span></span><br><span class="line"><span class="attr">gc: objects in each generation:</span> <span class="number">574</span> <span class="number">3814</span> <span class="number">0</span></span><br><span class="line"><span class="attr">gc: objects in permanent generation:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">done,</span> <span class="number">0.</span><span class="string">0004s</span> <span class="string">elapsed</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">collecting</span> <span class="string">generation</span> <span class="number">0</span><span class="string">...</span></span><br><span class="line"><span class="attr">gc: objects in each generation:</span> <span class="number">1</span> <span class="number">0</span> <span class="number">4261</span></span><br><span class="line"><span class="attr">gc: objects in permanent generation:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">done,</span> <span class="number">0.</span><span class="string">0000s</span> <span class="string">elapsed</span></span><br><span class="line"></span><br><span class="line"><span class="string">Creating</span> <span class="string">objects</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">collecting</span> <span class="string">generation</span> <span class="number">0</span><span class="string">...</span></span><br><span class="line"><span class="attr">gc: objects in each generation:</span> <span class="number">3</span> <span class="number">0</span> <span class="number">4261</span></span><br><span class="line"><span class="attr">gc: objects in permanent generation:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">done,</span> <span class="number">0.</span><span class="string">0000s</span> <span class="string">elapsed</span></span><br><span class="line"><span class="string">Create</span> <span class="string">A0</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">collecting</span> <span class="string">generation</span> <span class="number">1</span><span class="string">...</span></span><br><span class="line"><span class="attr">gc: objects in each generation:</span> <span class="number">2</span> <span class="number">2</span> <span class="number">4261</span></span><br><span class="line"><span class="attr">gc: objects in permanent generation:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">done,</span> <span class="number">0.</span><span class="string">0000s</span> <span class="string">elapsed</span></span><br><span class="line"><span class="string">Create</span> <span class="string">A1</span></span><br><span class="line"><span class="string">Create</span> <span class="string">A2</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">collecting</span> <span class="string">generation</span> <span class="number">0</span><span class="string">...</span></span><br><span class="line"><span class="attr">gc: objects in each generation:</span> <span class="number">2</span> <span class="number">0</span> <span class="number">4264</span></span><br><span class="line"><span class="attr">gc: objects in permanent generation:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">done,</span> <span class="number">0.</span><span class="string">0000s</span> <span class="string">elapsed</span></span><br><span class="line"><span class="string">Create</span> <span class="string">A3</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">collecting</span> <span class="string">generation</span> <span class="number">0</span><span class="string">...</span></span><br><span class="line"><span class="attr">gc: objects in each generation:</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4264</span></span><br><span class="line"><span class="attr">gc: objects in permanent generation:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">done,</span> <span class="number">0.</span><span class="string">0000s</span> <span class="string">elapsed</span></span><br><span class="line"><span class="string">Create</span> <span class="string">A4</span></span><br><span class="line"><span class="string">Create</span> <span class="string">A5</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">collecting</span> <span class="string">generation</span> <span class="number">1</span><span class="string">...</span></span><br><span class="line"><span class="attr">gc: objects in each generation:</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4264</span></span><br><span class="line"><span class="attr">gc: objects in permanent generation:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">done,</span> <span class="number">0.</span><span class="string">0000s</span> <span class="string">elapsed</span></span><br><span class="line"><span class="string">Create</span> <span class="string">A6</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">collecting</span> <span class="string">generation</span> <span class="number">0</span><span class="string">...</span></span><br><span class="line"><span class="attr">gc: objects in each generation:</span> <span class="number">3</span> <span class="number">0</span> <span class="number">4268</span></span><br><span class="line"><span class="attr">gc: objects in permanent generation:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">done,</span> <span class="number">0.</span><span class="string">0000s</span> <span class="string">elapsed</span></span><br><span class="line"><span class="string">Create</span> <span class="string">A7</span></span><br><span class="line"><span class="string">Create</span> <span class="string">A8</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">collecting</span> <span class="string">generation</span> <span class="number">0</span><span class="string">...</span></span><br><span class="line"><span class="attr">gc: objects in each generation:</span> <span class="number">2</span> <span class="number">2</span> <span class="number">4268</span></span><br><span class="line"><span class="attr">gc: objects in permanent generation:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">done,</span> <span class="number">0.</span><span class="string">0000s</span> <span class="string">elapsed</span></span><br><span class="line"><span class="string">Create</span> <span class="string">A9</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">collecting</span> <span class="string">generation</span> <span class="number">2</span><span class="string">...</span></span><br><span class="line"><span class="attr">gc: objects in each generation:</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4267</span></span><br><span class="line"><span class="attr">gc: objects in permanent generation:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">done,</span> <span class="number">0.</span><span class="string">0003s</span> <span class="string">elapsed</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">collecting</span> <span class="string">generation</span> <span class="number">0</span><span class="string">...</span></span><br><span class="line"><span class="attr">gc: objects in each generation:</span> <span class="number">5</span> <span class="number">0</span> <span class="number">4216</span></span><br><span class="line"><span class="attr">gc: objects in permanent generation:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">done,</span> <span class="number">0.</span><span class="string">0000s</span> <span class="string">elapsed</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">collecting</span> <span class="string">generation</span> <span class="number">0</span><span class="string">...</span></span><br><span class="line"><span class="attr">gc: objects in each generation:</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4216</span></span><br><span class="line"><span class="attr">gc: objects in permanent generation:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">done,</span> <span class="number">0.</span><span class="string">0000s</span> <span class="string">elapsed</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">collecting</span> <span class="string">generation</span> <span class="number">1</span><span class="string">...</span></span><br><span class="line"><span class="attr">gc: objects in each generation:</span> <span class="number">6</span> <span class="number">11</span> <span class="number">4216</span></span><br><span class="line"><span class="attr">gc: objects in permanent generation:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">done,</span> <span class="number">0.</span><span class="string">0000s</span> <span class="string">elapsed</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">collecting</span> <span class="string">generation</span> <span class="number">0</span><span class="string">...</span></span><br><span class="line"><span class="attr">gc: objects in each generation:</span> <span class="number">6</span> <span class="number">0</span> <span class="number">4233</span></span><br><span class="line"><span class="attr">gc: objects in permanent generation:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">done,</span> <span class="number">0.</span><span class="string">0000s</span> <span class="string">elapsed</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">collecting</span> <span class="string">generation</span> <span class="number">0</span><span class="string">...</span></span><br><span class="line"><span class="attr">gc: objects in each generation:</span> <span class="number">8</span> <span class="number">6</span> <span class="number">4232</span></span><br><span class="line"><span class="attr">gc: objects in permanent generation:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">done,</span> <span class="number">0.</span><span class="string">0000s</span> <span class="string">elapsed</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">collecting</span> <span class="string">generation</span> <span class="number">1</span><span class="string">...</span></span><br><span class="line"><span class="attr">gc: objects in each generation:</span> <span class="number">6</span> <span class="number">14</span> <span class="number">4232</span></span><br><span class="line"><span class="attr">gc: objects in permanent generation:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">done,</span> <span class="number">0.</span><span class="string">0000s</span> <span class="string">elapsed</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">collecting</span> <span class="string">generation</span> <span class="number">0</span><span class="string">...</span></span><br><span class="line"><span class="attr">gc: objects in each generation:</span> <span class="number">10</span> <span class="number">0</span> <span class="number">4245</span></span><br><span class="line"><span class="attr">gc: objects in permanent generation:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">done,</span> <span class="number">0.</span><span class="string">0000s</span> <span class="string">elapsed</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">collecting</span> <span class="string">generation</span> <span class="number">0</span><span class="string">...</span></span><br><span class="line"><span class="attr">gc: objects in each generation:</span> <span class="number">4</span> <span class="number">10</span> <span class="number">4244</span></span><br><span class="line"><span class="attr">gc: objects in permanent generation:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">done,</span> <span class="number">0.</span><span class="string">0000s</span> <span class="string">elapsed</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">collecting</span> <span class="string">generation</span> <span class="number">1</span><span class="string">...</span></span><br><span class="line"><span class="attr">gc: objects in each generation:</span> <span class="number">3</span> <span class="number">14</span> <span class="number">4244</span></span><br><span class="line"><span class="attr">gc: objects in permanent generation:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">done,</span> <span class="number">0.</span><span class="string">0000s</span> <span class="string">elapsed</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">collecting</span> <span class="string">generation</span> <span class="number">0</span><span class="string">...</span></span><br><span class="line"><span class="attr">gc: objects in each generation:</span> <span class="number">3</span> <span class="number">0</span> <span class="number">4261</span></span><br><span class="line"><span class="attr">gc: objects in permanent generation:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">done,</span> <span class="number">0.</span><span class="string">0000s</span> <span class="string">elapsed</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">collecting</span> <span class="string">generation</span> <span class="number">0</span><span class="string">...</span></span><br><span class="line"><span class="attr">gc: objects in each generation:</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4261</span></span><br><span class="line"><span class="attr">gc: objects in permanent generation:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">done,</span> <span class="number">0.</span><span class="string">0000s</span> <span class="string">elapsed</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">collecting</span> <span class="string">generation</span> <span class="number">1</span><span class="string">...</span></span><br><span class="line"><span class="attr">gc: objects in each generation:</span> <span class="number">4</span> <span class="number">6</span> <span class="number">4260</span></span><br><span class="line"><span class="attr">gc: objects in permanent generation:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">done,</span> <span class="number">0.</span><span class="string">0000s</span> <span class="string">elapsed</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">collecting</span> <span class="string">generation</span> <span class="number">2</span><span class="string">...</span></span><br><span class="line"><span class="attr">gc: objects in each generation:</span> <span class="number">2</span> <span class="number">0</span> <span class="number">4241</span></span><br><span class="line"><span class="attr">gc: objects in permanent generation:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">done,</span> <span class="number">589</span> <span class="string">unreachable,</span> <span class="number">0</span> <span class="string">uncollectable,</span> <span class="number">0.</span><span class="string">0004s</span> <span class="string">elapsed</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">collecting</span> <span class="string">generation</span> <span class="number">2</span><span class="string">...</span></span><br><span class="line"><span class="attr">gc: objects in each generation:</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3029</span></span><br><span class="line"><span class="attr">gc: objects in permanent generation:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">done,</span> <span class="number">151</span> <span class="string">unreachable,</span> <span class="number">0</span> <span class="string">uncollectable,</span> <span class="number">0.</span><span class="string">0002s</span> <span class="string">elapsed</span></span><br></pre></td></tr></table></figure>
<p>从打印可以看出，将分代回收阈值设置为(2,1,1)后，Python GC执行的频率明显更频繁，但这会在一定程度上影响程序的效率。</p>
<h2 id="禁用gc调高速度"><a class="markdownIt-Anchor" href="#禁用gc调高速度"></a> 禁用GC调高速度</h2>
<p>从前面的介绍可知，Python的引用计数会在每个内存对象中都存在一个计数变量，当有大量的对象新建或删除时，就会涉及到该变量的大量修改，从而影响程序的性能，为了避免这种情况，在程序进行大量对象新建或删除前，可以先将GC禁用，等这些操作结束后，再开启GC，例子如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">import gc</span><br><span class="line"><span class="comment"># 关闭GC</span></span><br><span class="line">gc.<span class="builtin-name">disable</span>()</span><br><span class="line"><span class="comment"># do something</span></span><br><span class="line"><span class="comment"># 开启GC</span></span><br><span class="line">gc.<span class="builtin-name">enable</span>()</span><br><span class="line"><span class="comment"># 手动执行GC</span></span><br><span class="line">gc.collect()</span><br></pre></td></tr></table></figure>
<p>此时就会在批量操作后，对这些变量进行批量的回收。</p>
<h2 id="结尾"><a class="markdownIt-Anchor" href="#结尾"></a> 结尾</h2>
<p>本节主要讨论了Python中的gc模块并简单的使用了该模块，</p>
<p>本节中简单的讨论了Python中的垃圾回收机制，那是否有某些手段可以比较直观的看出当前项目中Python GC的使用情况，从而可以直观的判断项目对内存的使用是否合理呢？这些内容会尝试在浅析「垃圾回收机制」下篇中讨论😏，最后欢迎学习 HackPython 的教学课程并感觉您的阅读与支持。</p>
<p>👋👋</p>
]]></content>
      <tags>
        <tag>Python,进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Python进阶：浅析「垃圾回收机制」(上篇)</title>
    <url>/blog/2019/07/05/Python%E8%BF%9B%E9%98%B6%EF%BC%9A%E6%B5%85%E6%9E%90%E3%80%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E3%80%8D-%E4%B8%8A%E7%AF%87/</url>
    <content><![CDATA[<blockquote>
<p>HackPython致力于有趣有价值的编程教学</p>
</blockquote>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>Python垃圾回收机制是很多Python岗位面试官喜欢提的一点🙃，虽然Python具有垃圾自动回收的机制，但在一些大型项目中有些资源是不能等到它自动回收的，而需要手动将使用完的资源回收释放，从而让程序尽可能的耗尽服务器的所有资源，这在游戏开发中很重要，服务器是需要成本的🤨。</p>
<p>Python中垃圾回收机制(Garbage Collection, GC)主要使用「引用计数」进行垃圾回收，通过「标记-清理」解决「容器对象」产生循环引用的问题，在通过「分代回收」以空间换时间的方式来提高垃圾回收的效率。</p>
<p>下面分别从「引用计数」、「标记-清理」以及「分代回收」来讨论一下Python中的GC。</p>
<h2 id="引用计数"><a class="markdownIt-Anchor" href="#引用计数"></a> 引用计数</h2>
<p>从CPython源码中，Python对象的核心是PyObject这个结构体😗，该结构体内存通过ob_refcnt实现变量的引用计数，PyObject结构体如下:</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"> typedef struct_object &#123;</span><br><span class="line">    int ob_refcnt<span class="comment">;</span></span><br><span class="line">    struct_typeobject *ob_type<span class="comment">;</span></span><br><span class="line">&#125; PyObject<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>程序在运行的过程中会实时的更新 ob_refcnt 的值，来反映引用当前对象的名称数量。当某对象的引用计数值为 0, 那么它的内存就会被立即释放掉，即被垃圾回收。</p>
<p>以下情况是导致引用计数加一的情况:</p>
<p>😀1.对象被创建，例如 a=2333<br />
😀2.对象被引用，b=a<br />
😀3.对象被作为参数，传入到一个函数中<br />
😀4.对象作为一个元素，存储在容器中</p>
<p>下面的情况则会导致引用计数减一:</p>
<p>🙁1.对象别名被显示销毁 del<br />
🙁2.对象别名被赋予新的对象<br />
🙁3.一个对象离开他的作用域<br />
🙁4.对象所在的容器被销毁或者是从容器中删除对象</p>
<p>可以通过 sys 包中的 getrefcount() 来获取一个名称所引用的对象当前的引用计数 (注意，这里 getrefcount () 本身会使得引用计数加一)</p>
<p>「引用计数」这种方式很容易从逻辑层面去理解，简单而言就是有人用旧留着，没人用就回收，但这种方式是比较耗费资源的，毕竟计数也需要占用内存，而且该方法无法解决「容器对象」循环引用的问题，如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>] # 计数为 <span class="number">1</span></span><br><span class="line">b=[<span class="number">2</span>,<span class="number">3</span>] # 计数为 <span class="number">1</span></span><br><span class="line">a.append(b) # 计数为 <span class="number">2</span></span><br><span class="line">b.append(a) # 计数为 <span class="number">2</span></span><br><span class="line">DEL a # 计数为 <span class="number">1</span></span><br><span class="line">DEL b # 计数为 <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>循环引用导致变量计数永不为0，造成引用计数无法将其删除。</p>
<h2 id="标记-清除"><a class="markdownIt-Anchor" href="#标记-清除"></a> 标记-清除</h2>
<p>Python 中使用标记-清除的方式来解决循环引用导致的问题。</p>
<p>只有容器对象才会产生循环引用的情况，比如列表、字典、用户自定义类的对象、元组等。而像数字，字符串这类简单类型不会出现循环引用。</p>
<p>「标记-清除」作为一种优化策略，对于只包含简单类型的元组也不在标记清除算法的考虑之列，简单来看，「标记-清除」算法在进行垃圾回收时分成了两步，分别是：</p>
<p>🤫A）标记阶段，遍历所有的对象，如果是可达的（reachable），也就是还有对象引用它，那么就标记该对象为可达；<br />
🤫B）清除阶段，再次遍历对象，如果发现某个对象没有标记为可达，则就将其回收。</p>
<p>下面看图来理解 标记-清除 ，图片出自 <a href="https://andrewpqc.github.io/2018/10/08/python-memory-management/" target="_blank" rel="noopener">聊聊 Python 内存管理</a></p>
<p>在标记清除算法中，为了追踪容器对象，需要每个容器对象维护两个额外的指针，用来将容器对象组成一个双端链表，指针分别指向前后两个容器对象，方便插入和删除操作😎。python 解释器 (Cpython) 维护了两个这样的双端链表，一个链表存放着需要被扫描的容器对象，称为 Object to Scan，另一个链表存放着临时不可达对象，称为 Unreachable。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190705224034.png" alt="" /></p>
<p>上图中 link1,link2,link3 组成一个引用环，此外 link1 还被变量 A 引用，看图中 link1 被几个箭头指着就知道了，其中 ref_count 记录当前对象的引用计数，而 gc_ref 在一开始，gc_ref 只是 ref_count 的副本，所以 gc_ref 的初始值等于 ref_count。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190705224055.png" alt="" /></p>
<p>gc 启动的时候，会逐个遍历”Object to Scan” 链表中的容器对象，并且将当前对象所引用的所有对象的 gc_ref 减一😐。这一步操作就相当于解除了循环引用对引用计数的影响。如 link4 是自己引用了自己造成了循环引用，此时 link4 的 gc_ref 为 0.</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190705224111.png" alt="" /></p>
<p>接着，gc 会再次扫描所有的容器对象，如果对象的 gc_ref 值为 0，且引用该对象的对象其 gc_ref 也为 0 ，那么这个对象就被标记为 GC_TENTATIVELY_UNREACHABLE，并且被移至”Unreachable” 链表中😐。下图中的 link3 和 link4 就是这样一种情况。</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190705224126.png" alt="" /></p>
<p>如果对象的 gc_ref 不为 0，那么这个对象就会被标记为 GC_REACHABLE😐。同时当 gc 发现有一个节点是可达的，那么他会递归式的将从该节点出发可以到达的所有节点标记为 GC_REACHABLE, 这就是下图中 link2 和 link3 所碰到的情形😯。除了将所有可达节点标记为 GC_REACHABLE 之外，如果该节点当前在”Unreachable” 链表中的话，还需要将其移回到”Object to Scan” 链表中，下图就是 link3 移回之后的情形。</p>
<p>第二次遍历的所有对象都遍历完成之后，存在于”Unreachable” 链表中的对象就是真正需要被释放的对象。如上图所示，此时 link4 存在于 Unreachable 链表中，gc 随即释放之。</p>
<p>上面描述的垃圾回收的阶段，会暂停整个应用程序，等待标记清除结束后才会恢复应用程序的运行🙂。</p>
<h2 id="分代回收"><a class="markdownIt-Anchor" href="#分代回收"></a> 分代回收</h2>
<p>引用计数 + 标记-清除 的方式实现了Python垃圾回收，但整个过程比较慢，而且在 标记-清除 过程中还需要暂停整个程序，为了减少应用程序暂停使用，Python利用分代回收(Generational Collection)以空间换时间的方式来提高垃圾回收效率😯。</p>
<p>分代回收是基于这样的一个统计事实，对于程序，存在一定比例的内存块的生存周期比较短；而剩下的内存块，生存周期会比较长，甚至会从程序开始一直持续到程序结束。生存期较短对象的比例通常在 80%～90% 之间，这种思想简单点说就是：对象存在时间越长，越可能不是垃圾，应该越少去收集🤯。这样在执行标记 - 清除算法时可以有效减小遍历的对象数，从而提高垃圾回收的速度。</p>
<p>python gc 给对象定义了三种世代 (0,1,2), 每一个新生对象在 generation zero 中，如果它在一轮 gc 扫描中活了下来，那么它将被移至 generation one, 在那里他将较少的被扫描，如果它又活过了一轮 gc, 它又将被移至 generation two，在那里它被扫描的次数将会更少🤔。</p>
<p>当某一世代被分配的对象与被释放的对象之差达到某一阈值的时候，就会触发 gc 对某一世代的扫描。值得注意的是当某一世代的扫描被触发的时候，比该世代年轻的世代也会被扫描😯。也就是说如果世代 2 的 gc 扫描被触发了，那么世代 0, 世代 1 也将被扫描，如果世代 1 的 gc 扫描被触发，世代 0 也会被扫描。</p>
<p>该阈值可以通过下面两个函数查看和调整:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">import gc</span><br><span class="line">gc.get<span class="constructor">_threshold()</span> # (threshold0, threshold1, threshold2).</span><br><span class="line">gc.set<span class="constructor">_threshold(<span class="params">threshold0</span>[, <span class="params">threshold1</span>[, <span class="params">threshold2</span>]])</span></span><br></pre></td></tr></table></figure>
<p>gc 会记录自从上次收集以来新分配的对象数量与释放的对象数量，当两者之差超过 threshold0 的值时，gc 的扫描就会启动，初始的时候只有世代 0 被检查。如果自从世代 1 最近一次被检查以来，世代 0 被检查超过 threshold1 次，那么对世代 1 的检查将被触发。相同的，如果自从世代 2 最近一次被检查以来，世代 1 被检查超过 threshold2 次，那么对世代 2 的检查将被触发。</p>
<h2 id="结尾"><a class="markdownIt-Anchor" href="#结尾"></a> 结尾</h2>
<p>本节中简单的讨论了Python中的垃圾回收机制，那是否有某些手段可以比较直观的看出当前项目中Python GC的使用情况，从而可以直观的判断项目对内存的使用是否合理呢？这些内容会尝试在浅析「垃圾回收机制」下篇中讨论😏，最后欢迎学习 HackPython 的教学课程并感觉您的阅读与支持。</p>
<p>👋👋</p>
]]></content>
      <tags>
        <tag>Python,进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Python进阶：百万「并发」基础之异步编程（下篇）</title>
    <url>/blog/2019/07/05/Python%E8%BF%9B%E9%98%B6%EF%BC%9A%E7%99%BE%E4%B8%87%E3%80%8C%E5%B9%B6%E5%8F%91%E3%80%8D%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8B%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>HackPython致力于有趣有价值的编程教学</p>
</blockquote>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>在上一节中，了解了yield、yield from等概念，此时Python以及具有编写协程实现「回调」的能力，而「回调」是异步编程的基础，随后Python语言的开发者利用yield from能力，在Python3.4中引入了异步I/O框架asyncio，该框架在Python3.5中被完善并作为标准库之一，用于基于协程的异步I/O编程，本节就来讨论一下asyncio以及async/await等内容。</p>
<h2 id="关键概念"><a class="markdownIt-Anchor" href="#关键概念"></a> 关键概念</h2>
<p>在Python3.4中引入了asyncio.coroutine装饰器来标志函数作为协程函数，协程函数具有协程的特性并与asyncio的事件循环一同使用，实现异步编程的目的，为了避免生成器与协程之间的混淆，在Python3.5中引入了async/await，其中async替代asyncio.coroutine装饰器，await替代yield from，从而让协程的实现更加直观，async/await和yield frome这两种不同风格的协程在底层其实是相互复用相互兼容的，在Python3.6中asyncio库“转正”，成为正式的标注库。</p>
<p>这里只讨论新的写法，即async/await实现协程的方式，Python中协程主要的特性如下：</p>
<p>😀1.函数使用了async表达式开头，即使它不包含await表达式，也是一个协程函数<br />
😀2.async协程函数中使用yield或者yield from会阐释SyntaxError错误，即新旧语法不可混合使用<br />
😀3.与常规生成器类似，协程函数在调用时会返回一个coroutine对象<br />
😀4.与yield方式实现的协程不同，yield在最后会抛出Stoplteration异常，而async中则是RuntimeError<br />
😀5.当async创建的协程函数被垃圾回收时，一个未被await的协程会抛出RuntimeWarning异常。</p>
<p>在使用asyncio框架前，需要先了解其中几个概念。</p>
<h2 id="coroutine-协程"><a class="markdownIt-Anchor" href="#coroutine-协程"></a> Coroutine 协程</h2>
<p>以async表达式开头的函数成为协程函数或简称为协程，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'world'</span>)</span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>上述代码中，main() 为协程函数，其写法是Python3.7的写法，Python3.7中对asyncio的使用做了简化，😑如果你使用python3.6为主，其asyncio写法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'world'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建协程对象</span></span><br><span class="line">    coroutine = main()</span><br><span class="line">    <span class="comment"># 创建事件循环</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="comment"># 将协程对象添加到事件循环中，运行直到结束</span></span><br><span class="line">    loop.run_until_complete(coroutine)</span><br><span class="line">    <span class="comment"># 关闭事件循环</span></span><br><span class="line">    loop.close()</span><br><span class="line"></span><br><span class="line">run()</span><br></pre></td></tr></table></figure>
<p>可以看出，Python3.6中asyncio的用法会复杂一下，在Python3.7中，run()方法已经为我们处理好了创建事件、添加协程对象到事件循环、关闭事件循环等事情😏，即</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loop asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(main())</span><br><span class="line">loop.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在Python3.7中被替换为</span></span><br><span class="line"></span><br><span class="line">asyncio.run()</span><br></pre></td></tr></table></figure>
<p>当然，asyncio也支持传统的基于生成器的协程，不再多提。</p>
<h2 id="awaitables-可等待对象"><a class="markdownIt-Anchor" href="#awaitables-可等待对象"></a> Awaitables 可等待对象</h2>
<p>「可等待对象」通常有3类，分别是：</p>
<p>😗1.协程 coroutine<br />
😗2.任务 Task<br />
😗3.未来对象 Future</p>
<p>一个直观的判断方法就是，如果一个对象能够被用在 await 表达式中，那么就可以称这个对象为 「可等待对象」</p>
<p>简单示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">myprint</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello hackpython'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 直接调用，创建协程对象，不会执行协程中的内容</span></span><br><span class="line">    myprint()</span><br><span class="line">    <span class="comment"># 协程对象成为被等待对象后，才会执行其中的内容</span></span><br><span class="line">    <span class="keyword">await</span> myprint()</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>上述代码会输出如下内容：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">use_asyncio4.py:8: RuntimeWarning: coroutine <span class="string">'myprint'</span> was never awaited</span><br><span class="line">  myprint()</span><br><span class="line">RuntimeWarning: <span class="builtin-name">Enable</span> tracemalloc <span class="keyword">to</span> <span class="builtin-name">get</span> the object allocation traceback</span><br><span class="line"></span><br><span class="line">hello hackpython</span><br></pre></td></tr></table></figure>
<p>从输入内容可以看出，直接使用协程函数是不会执行其中的逻辑的，而且还会因为没有使用而触发相应的警告，😀只有利用await成为可等待对象后，才会被asyncio事件循环去执行。await会将控制权交由可等待对象。</p>
<h2 id="task-任务"><a class="markdownIt-Anchor" href="#task-任务"></a> Task 任务</h2>
<p>「任务」主要用于「并发」的调度协程。</p>
<p>一个协程可以通过asyncio.create_task()函数封装成一个Task，此时这个协程很快就会被自动调度执行，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hackpython'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建任务</span></span><br><span class="line">    task = asyncio.create_task(fun1())</span><br><span class="line">    <span class="comment"># 作为被等待对象</span></span><br><span class="line">    <span class="keyword">await</span> task</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>asyncio.create_task() 是 Python 3.7 新增的方法，如果是Python3.6还可以用 asyncio.ensure_future 和 loop.create_task🤔。</p>
<p>可以将Task理解为协程对象的进一步封装，其中包含着各种状态，简单使用如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'a funtion start.'</span>)</span><br><span class="line">    <span class="keyword">await</span>  asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'a function end.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># task = asyncio.ensure_future(a())</span></span><br><span class="line">    task = asyncio.create_task(a())</span><br><span class="line">    print(task)</span><br><span class="line">    print(task.done())</span><br><span class="line">    <span class="keyword">await</span> task</span><br><span class="line">    print(task)</span><br><span class="line">    print(task.done())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>上述代码输出如下：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">Task</span> pending coro=&lt;a() running at <span class="regexp">/Users/</span>ayuliao<span class="regexp">/Desktop/</span>spider<span class="regexp">/lianjia/u</span>se_asyncio1.py:<span class="number">3</span>&gt;&gt;</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line">a funtion start.</span><br><span class="line">a function end.</span><br><span class="line">&lt;<span class="keyword">Task</span> finished coro=&lt;a() done, defined at <span class="regexp">/Users/</span>ayuliao<span class="regexp">/Desktop/</span>spider<span class="regexp">/lianjia/u</span>se_asyncio1.py:<span class="number">3</span>&gt; result=None&gt;</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>从输出内容可以看出，一开始Task任务的状态为pending(等待状态)，调用其done()方法可以判断该任务是否执行😳，可以看出，没有利用await将其转为可等待对象前，Task任务是没有执行的，使用await后，即将控制权交由task对象，此时再次打印，发现其状态改变为finshed(完成状态)，调用done()方法后可得该任务被正常执行了😑。</p>
<h2 id="future-未来对象"><a class="markdownIt-Anchor" href="#future-未来对象"></a> Future 未来对象</h2>
<p>Future代表着一个未来对象，当异步操作结束后会将最终的结果设置到Future对象上，Future同样是对协程的封装，它是一个偏底层的类，具有比较多的方法可以做一些复杂的操作，但在日常开发时，并不会去使用🤭，更多的是使用其Task任务，它其实是Future的一个子类🤭。</p>
<h2 id="eventloop事件循环"><a class="markdownIt-Anchor" href="#eventloop事件循环"></a> Eventloop事件循环</h2>
<p>使用 asyncio 框架时，其实就是开启一个事件循环，事件循环对应的实例提供了注册、取消、执行与回调等方法，方便控制整个事件循环实例。</p>
<p>所谓事件循环，就是将协程函数、任务 Task、未来对象 Future 等注册到事件循环中，事件循环实例会循环执行这些函数😐，注意同一时刻下只执行某个函数对象，具体执行某个函数时，如果执行到函数中进行 I/O 耗时操作的部分，事件循环就会将该函数暂停，而去执行其他函数，等进行 I/O 耗时操作的函数执行完后，会再次加入循环队列，等事件循环下次循环到它时继续从此前位置执行，从而实现这些可异步操作对象的协同运行，达到并发的效果😲。</p>
<h2 id="结尾"><a class="markdownIt-Anchor" href="#结尾"></a> 结尾</h2>
<p>asyncio是Python中比较复杂但又非常重要的概念，在 百万「并发」基础之异步编程 上、中、下三篇文章中比较系统的讨论了异步编程的概念以及在Python中的实现方式😏，但对生成器、yield from以及asyncio等依旧没有深入探讨🤯，在HackPython后面的文章中，会系统性讨论这些概念，最后欢迎学习 HackPython 的教学课程并感觉您的阅读与支持。</p>
<p>👋👋</p>
]]></content>
      <tags>
        <tag>Python,进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Python进阶：百万「并发」基础之异步编程（中篇）</title>
    <url>/blog/2019/07/05/Python%E8%BF%9B%E9%98%B6%EF%BC%9A%E7%99%BE%E4%B8%87%E3%80%8C%E5%B9%B6%E5%8F%91%E3%80%8D%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>HackPython致力于有趣有价值的编程教学</p>
</blockquote>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>在上一篇，讨论了阻塞/非阻塞、同步/异步、并发/并行等概念，本节主要来讨论一下生成器、yield以及yield from概念并进行简单的使用。</p>
<h2 id="关键概念"><a class="markdownIt-Anchor" href="#关键概念"></a> 关键概念</h2>
<p>Python中利用了asyncio这个标准库作为异步编程框架，而aysncio以及其他多数协程库内部都大量使用了生成器，所以先从生成器聊起。为什么会是生成器🤔？回想一下生成器的特性，其利用了yield关键字做到了随时暂停以及随时执行的能力，而协程从技术实现角度而言，它的作用其实就是一个可以随时暂停会执行的函数。</p>
<h2 id="生成器"><a class="markdownIt-Anchor" href="#生成器"></a> 生成器</h2>
<p>生成器与迭代器关系紧密，😗其实生成器就是迭代器另一种更优雅的实现方式，其利用了yield关键字实现了迭代器的功能，生成器可以迭代式的利用内存空间，让数据在需要使用时才被载入，这减少内存的消耗，其利用yield关键字使用了这个功能，当生成器函数执行过程中遇到yield就会被展厅执行，等下次迭代时再次从暂停处继续执行。</p>
<p>为了让生成器可以实现简单的协程，🤩在Python 2.5 的时候对生成器的能力进行了增强，此时利用yield可以暂停生成器函数的执行返回数据，也可以通过send()方法向生成器发送数据，并且还可以利用throw()向生成器内抛出异常以实现可随时终止生成器的目的。</p>
<p>yield的作用直观如下图：</p>
<p><img src="media/15620500849438/15620762990215.jpg" alt="" /></p>
<p>从图中可看出，在一开始调用simple_coro2()方法时，获得的my_coro2变量并不是具体的值，而是一个生成器对象，此时调用其next()方法进行迭代，next()方法会让生成器函数执行到yield处，到yield后就会会将紧随在其后的变量返回，接着可以利用send()方法将值传递到生成器中，并让暂停的函数继续从暂停处执行😏，next()与send()的不同之处在于next()并不能向生成器内部传递值而send()可以，可以直接使用send(None)来实现next()方法的效果。从图中也可以看出，next()与send()会获得下一个yield返回的值。</p>
<p>顺带一提，for迭代也调用了迭代器中的__next__方法，next()内部也是该方法🤫。</p>
<h2 id="yield-from"><a class="markdownIt-Anchor" href="#yield-from"></a> yield from</h2>
<p>为了让生成器分成多个子生成器后可以很容易使用next()、send()、throw()等方法，Python3.3中引入了yield from语言🤩，它允许将一个生成器的部分操作委派给另一个生成器。</p>
<p>虽然yield from设计的目的是为了让生成器本身可以委派给子生成器，但yield from可以向任意可迭代对象进行委派操作🤭。</p>
<p>yield from iterable 本质其实就是 for item in iterable: yield item，只是写法更优雅了，简单使用如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="function"><span class="keyword">def</span> <span class="title">gen1</span><span class="params">()</span>:</span></span><br><span class="line">   ...:     <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">'abc'</span>:</span><br><span class="line">   ...:         <span class="keyword">yield</span> i</span><br><span class="line">   ...:     <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">   ...:         <span class="keyword">yield</span> i</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: list(gen1())</span><br><span class="line">Out[<span class="number">2</span>]: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: <span class="function"><span class="keyword">def</span> <span class="title">gen2</span><span class="params">()</span>:</span></span><br><span class="line">   ...:     <span class="keyword">yield</span> <span class="keyword">from</span> <span class="string">'abc'</span></span><br><span class="line">   ...:     <span class="keyword">yield</span> <span class="keyword">from</span> range(<span class="number">5</span>)</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: list(gen2())</span><br><span class="line">Out[<span class="number">5</span>]: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>上述代码中其实涉及几个概念，其中gen2()方法因为包含了yield from表达式，所以被称为😀委派生成器，而yield from后接着的表达式通常称为😀子生成器，上述代码中的’abc’,range(5)都是子生成器，而滴啊用委派生成器的代码称为😀调用方。</p>
<p>此外，yield from还可以直接将调用方发送的信息直接传递给子生成器，具体可以看下面代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line">Result = namedtuple(<span class="string">'Result'</span>, <span class="string">'count average'</span>)</span><br><span class="line"><span class="comment"># the subgenerator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span></span><br><span class="line">        print(<span class="string">'term:'</span>, term)</span><br><span class="line">        <span class="keyword">if</span> term <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total / count</span><br><span class="line">    <span class="keyword">return</span> Result(count, average)</span><br><span class="line"></span><br><span class="line"><span class="comment"># the delegating generator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grouper</span><span class="params">(results, key)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment">#只有当生成器averager()结束，才会返回结果给results赋值</span></span><br><span class="line">        results[key] = <span class="keyword">yield</span> <span class="keyword">from</span> averager()</span><br><span class="line">        print(<span class="string">'resluts[key]:'</span>, results[key])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">report</span><span class="params">(results)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> key, result <span class="keyword">in</span> sorted(results.items()):</span><br><span class="line">        group, unit = key.split(<span class="string">';'</span>)</span><br><span class="line">        print(<span class="string">'&#123;:2&#125; &#123;:5&#125; averaging &#123;:.2f&#125;&#123;&#125;'</span>.format(result.count, group, result.average, unit))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(data)</span>:</span></span><br><span class="line">    results = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key, values <span class="keyword">in</span> data.items():</span><br><span class="line">        group = grouper(results, key)</span><br><span class="line">        print(type(group))</span><br><span class="line">        next(group)</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> values:</span><br><span class="line">            r = group.send(value)</span><br><span class="line">            print(<span class="string">'r:'</span>,r)</span><br><span class="line">            print(<span class="string">'value:'</span>,value)</span><br><span class="line">        group.send(<span class="literal">None</span>)</span><br><span class="line">    report(results)</span><br><span class="line">    </span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'girls;kg'</span>:[<span class="number">40.9</span>, <span class="number">38.5</span>, <span class="number">44.3</span>, <span class="number">42.2</span>, <span class="number">45.2</span>, <span class="number">41.7</span>, <span class="number">44.5</span>, <span class="number">38.0</span>, <span class="number">40.6</span>, <span class="number">44.5</span>],</span><br><span class="line">    <span class="string">'girls;m'</span>:[<span class="number">1.6</span>, <span class="number">1.51</span>, <span class="number">1.4</span>, <span class="number">1.3</span>, <span class="number">1.41</span>, <span class="number">1.39</span>, <span class="number">1.33</span>, <span class="number">1.46</span>, <span class="number">1.45</span>, <span class="number">1.43</span>],</span><br><span class="line">    <span class="string">'boys;kg'</span>:[<span class="number">39.0</span>, <span class="number">40.8</span>, <span class="number">43.2</span>, <span class="number">40.8</span>, <span class="number">43.1</span>, <span class="number">38.6</span>, <span class="number">41.4</span>, <span class="number">40.6</span>, <span class="number">36.3</span>],</span><br><span class="line">    <span class="string">'boys;m'</span>:[<span class="number">1.38</span>, <span class="number">1.5</span>, <span class="number">1.32</span>, <span class="number">1.25</span>, <span class="number">1.37</span>, <span class="number">1.48</span>, <span class="number">1.25</span>, <span class="number">1.49</span>, <span class="number">1.46</span>],</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(data)</span><br></pre></td></tr></table></figure>
<p>在上述代码中，grouper函数是委托生成器😗，averager函数是子生成器😗，而main()函数就是调度者😗。</p>
<p>在main()函数中，首先通过grouper()获得对应的生成器对象，然后调用next()方法进行初步的迭代，此时会执行到averager()的yield处，因为yield后没有跟对应的变量，则yield返回的值为None，该值会有grouper()委托生成器直接传递给main()调度者，观察变量r的打印则可，接着for迭代中使用委托生成器的send()方法，该方法发送的数据会有委托生成器直接传递给子生成器，即averager()函数中term的值，上述代码调度的关系如下图：</p>
<p><img src="media/15620500849438/15620800978164.jpg" alt="" /></p>
<p>从图中看出，😐调度者使用send()方法传递的数据会被委派生成器直接传递给子生成器，而子生成器yield的方法数据也被直接传递会调度者，如果子生成器产生StopIteration异常则表示子生成器已经迭代完了，此时委派生成器会接收到该异常，从而继续执行yield from整个表达式后的其他表达式，这里grouper()函数中yield from执行完后，就没有逻辑了。</p>
<p>可以看出，委派生成器具有组织多个子生成器的能力，并将调度者的信息转手传递给子生成器😯。</p>
<h2 id="结尾"><a class="markdownIt-Anchor" href="#结尾"></a> 结尾</h2>
<p>在本节中，主要介绍Python中生成器、yield以及yield from的概念与使用，在下一篇中，会接着讨论Python的asyncio框架以及async/await原生协程，最后欢迎学习HackPython的教学课程并感谢您的阅读与支持。</p>
<h2 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h2>
<p><a href="https://hatboy.github.io/2019/02/16/Python%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3/#%E4%BA%8C%E3%80%81Python%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%BF%9B%E5%8C%96%E5%8F%B2" target="_blank" rel="noopener">Python 异步编程详解</a><br />
<a href="https://blog.51cto.com/youerning/2161196" target="_blank" rel="noopener">Python 也能高并发</a></p>
]]></content>
      <tags>
        <tag>Python,进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Python进阶：百万「并发」基础之异步编程（上篇）</title>
    <url>/blog/2019/07/01/Python%E8%BF%9B%E9%98%B6%EF%BC%9A%E7%99%BE%E4%B8%87%E3%80%8C%E5%B9%B6%E5%8F%91%E3%80%8D%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>HackPython致力于有趣有价值的编程教学</p>
</blockquote>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>因为GIL(全局锁)的存在，Python在运行性能方便一直是个短板，但在IO密集型网络编程里，利用aysncio等异步处理的方式可以提升百倍运行效率，但在计算密集型程序中，Python并不是最佳的选择。</p>
<p>异步编程会涉及比较多的概念，为了减轻阅读压力，将其分为上、中、下三篇文章。</p>
<h2 id="关键概念"><a class="markdownIt-Anchor" href="#关键概念"></a> 关键概念</h2>
<p>要理解异步编程，首先需要理解阻塞、非阻塞、同步以及异步的概念与关系。</p>
<p>当程序在等待某个操作完成期间，自己无法做其他事情的状态称为「阻塞」，专业点讲，当程序因未得到运行所需要的计算资源而被挂起的等待状态称为「阻塞」，「阻塞」其实无处不在，常见的有：磁盘IO阻塞、网络IO阻塞。</p>
<h2 id="阻塞与非阻塞"><a class="markdownIt-Anchor" href="#阻塞与非阻塞"></a> 阻塞与非阻塞</h2>
<p>与「阻塞」对应的就是「非阻塞」状态，所谓「非阻塞」指的是程序在等待某个操作是，自己还可以做其他事情，需要注意的是，「非阻塞」并不能在任何程序级别都可以存在，只有当程序可以囊括独立子程序单元时，它才可能存在非阻塞状态，其本质原因在于CPU单个核在那个瞬间只能处理一件事情。</p>
<p>与「阻塞」和「非阻塞」关联很大的概念分别是「同步」与「异步」。「同步」指不同的程序单元为了完成某个任务通过某种通信方式协调一致，此时可以称这些程序是同步执行的，这里协调一致并不是说要同时做，而是指大家有个顺序，「同步其实也就意味着有序」。</p>
<h2 id="同步与异步"><a class="markdownIt-Anchor" href="#同步与异步"></a> 同步与异步</h2>
<p>对应的「异步」指不同程序单元直接不需要协调也可单独完成任务，通常，没有先后顺序关联的业务逻辑可言利用异步的方式来实现，比如爬虫下载不同的网页、保存等操作都可以独立完成，下载程序单元直接无需通信协调，这也造成了「异步」是无序的。</p>
<p>一个「非阻塞」进程中通常由多个独立的子进程构成，如执行到下载逻辑时，交由下载子进程去执行自身的逻辑，而自己继续之前其他逻辑，这个「交由下载子进程」的动作就可以称为「异步」。</p>
<p>关于「同步」或「异步」描述中提出通信协调通常指异步编程或「并发」编程的同步原语，如信号量、锁、同步队列等。</p>
<p>从具体的技术层面而言，如果调用一个耗时函数，函数会挂起直达执行完毕，返回结果，那么这个函数所在程序就是「阻塞」的，其操作就是「同步」的，如果调用一个耗时函数立刻返回，等需要的数据到达后再通知函数的调用者，则该函数所在程序就是「非阻塞」的，其操作就是「异步」的。</p>
<h2 id="并发与并行"><a class="markdownIt-Anchor" href="#并发与并行"></a> 并发与并行</h2>
<p>「同步」和「异步」的概念可能会与「并发」和「并行」混淆，但两者其实描述的是不同级别的事情，对于「并发」和「并行」，Erlang 之父 Joe Armstrong 给出的图很好的解释了两者的区别</p>
<p><img src="https://pic2.zhimg.com/80/v2-674f0d37fca4fac1bd2df28a2b78e633_hd.jpg" alt="" /></p>
<p>「并发」是两个队列交替使用一台咖啡机，「并行」是两个队列同时使用两台咖啡机。</p>
<p>「并发」表示多个程序可以在同一个时间段内被执行，主要用于描述程序的组织结构，我们称这个程序是可以并发的通常指该程序设计了多个可独立执行的子任务，从而可以在同一时间段内利用有限的计算资源让多个任务以近实时的形式执行。</p>
<p>而「并行」表示多个程序可以在同一时刻被执行，「并行」的关键要有物理上的支持，比如有两台咖啡机，它通常用于描述程序的执行状态而不是程序组织结构，通常用来表示有足够的计算资源让多个任何同时执行。</p>
<p>更严谨的描述为：<br />
1.「并发」是说进程B的开始时间是在进程A的开始时间与结束时间之间，我们就说A和B是「并发」的。<br />
2.「并行」是「并发」的真子集，指同一时间两个进程运行在不同的机器上或者同一个机器不同的核心上。</p>
<p>简单总结上面的概念：<br />
非阻塞可以提高程序整体的执行效率，异步是一种组织非阻塞任务的方式(即操作其中的程序单元)，而并发是为了让独立的子任务有机会被尽快执行，但不一定可以加快任务整体的进度，而并行则是利用多核资源加快多任务的完成进度。</p>
<p>要实现并发，就需要将整体任务拆分为多个相互独立的子任务，而不同子任务之间才会有所谓的阻塞/非阻塞、同步/异步等说法，所以并发、非阻塞、异步三个概念总是如影随形。</p>
<h2 id="进程-线程与协程"><a class="markdownIt-Anchor" href="#进程-线程与协程"></a> 进程、线程与协程</h2>
<p>「进程」是操作系统中的最小的资源分配单位，每个「进程」都有各自独立的地址空间、资源句柄，它们相互独立，每个「进程」中都会有个用于描述当前进程的数据结构，操作系统会利用这些描述来管理进程，同时对操作系统而言，进程的创建于销毁时比较消耗资源的。</p>
<p>「进程」会抢占式的争夺CPU资源，同一时刻下，CPU的一个核只能执行<br />
一个进程，而单核CPU可以快速切换不同的进程来使得多进程看像去在同时执行。</p>
<p>「线程」是CPU调度的最小单位，「线程」是进程的一个实体，一个进程可以包含多个「线程」，同进程的多个「线程」是可以共享当前进程的内存地址空间与资源句柄的，「线程」的切换需要操作系统来实现调度，我们写的程序无法控制这个调度过程，适用于IO密集型任务。</p>
<p>如果想人为的控制线程的调度过程，可以使用「协程」，「协程」不等于可以自己调度的线程，它是属于线程的，即一个线程可以有多个「协程」，是一种用户状态下的轻量级线程，协程的调度可以完全由用户做主，因此使用更加灵活，可以将协程理解为可以在特定位置暂停或恢复的函数/子程序。</p>
<h2 id="异步编程"><a class="markdownIt-Anchor" href="#异步编程"></a> 异步编程</h2>
<p>异步编程就是以进程、线程、协程、函数/方法作为执行任务程序的基本单位，结合回调、事件循环、信号量等机制，以提高程序整体执行效率和并发能力的编程方式。</p>
<p>无论什么语言，要想实现异步编程就跳不开回调与事件循环。</p>
<p>在执行耗时函数时，函数会提前注册回调函数返回给调度程序，而函数耗时操作的等待与监听任务交个了操作系统，当操作系统监听到耗时操作的状态改变后就调用回调函数通知调度程序，这整个过程称为「回调」。</p>
<p>而「事件循环」是一种等待程序分配事件或消息的编程框架，简单来说就是当「 A 发生时，执行 B」，即监听当有什么发生时，就去执行什么，事件循环本质就是一种循环，它会不停的收集事件并执行对应这些事件的响应逻辑。</p>
<p>因为异步编程离不开「回调」与「事件循环」，但回调与事件循环的使用容易出现回调地狱、堆栈撕裂、错误定位与处理困难等问题，Python基于asyncio标准库来实现事件循环，为了避免其带来的危害，衍生出了基于协程的处理方案，协程本身的特性也满足了回调的要求。</p>
<p>在Python中协程与asyncio一同构建了异步编程。</p>
<h2 id="结尾"><a class="markdownIt-Anchor" href="#结尾"></a> 结尾</h2>
<p>在本节中，主要介绍了异步编程中会涉及的各种概念，在下一篇中，会接着探讨Python中的异步编程，最后欢迎学习HackPython的教学课程并感谢您的阅读与支持。</p>
]]></content>
      <tags>
        <tag>Python,进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Python进阶必学库：elasticsearch-py使用详解(下篇)</title>
    <url>/blog/2019/06/29/Python%E8%BF%9B%E9%98%B6%E5%BF%85%E5%AD%A6%E5%BA%93%EF%BC%9Aelasticsearch-py%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3-%E4%B8%8B%E7%AF%87/</url>
    <content><![CDATA[<blockquote>
<p>HackPython致力于有趣有价值的编程教学</p>
</blockquote>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>在上一篇文件中，介绍了 Elasticsearch 以及其中的关键概念，并且安装了 Elasticsearch 与 对应的 elasticsearch-py ，本章就来使用一下其基本的功能👹。</p>
<h2 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h2>
<p>Elasticsearch 本身提供了一系列 Restful API 来进行存取和查询操作，我们可以使用任意语言来使用这些API，而 elasticsearch-py 已经将这些API封装后，直接调用其中方法则可。</p>
<p>为了正常使用，先运行 elasticsearch</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cd <span class="regexp">/usr/</span>local<span class="regexp">/Cellar/</span>elasticsearch<span class="regexp">/6.8.0/</span>bin &amp;&amp; .<span class="regexp">/elasticsearch</span></span><br></pre></td></tr></table></figure>
<h3 id="创建索引-index"><a class="markdownIt-Anchor" href="#创建索引-index"></a> 创建索引 (Index)</h3>
<p>导入 elasticsearch 库的 Elasticsearch 类，使用create()方法创建一个名为 names 的 Index</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">from</span> <span class="variable">elasticsearch</span> <span class="variable">import</span> <span class="variable">Elasticsearch</span></span><br><span class="line"></span><br><span class="line"><span class="variable">es</span> = <span class="function"><span class="title">Elasticsearch</span>()</span></span><br><span class="line"></span><br><span class="line"><span class="variable"><span class="class">result</span></span> = <span class="variable">es.indices.create</span>(<span class="variable">index</span>=<span class="string">'names'</span>)</span><br><span class="line"><span class="function"><span class="title">print</span>(<span class="variable"><span class="class">result</span></span>)</span></span><br></pre></td></tr></table></figure>
<p>如果创建成功，则会返回下面结果🎉</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">&#123;<span class="symbol">'acknowledged</span>': <span class="literal">True</span>, <span class="symbol">'shards_acknowledged</span>': <span class="literal">True</span>, <span class="symbol">'index</span>': <span class="symbol">'names</span>'&#125;</span><br></pre></td></tr></table></figure>
<p>Elasticsearch 中不可以创建同名的 Index ，如果重复执行上述代码，则会出现如下错误💔</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">elasticsearch.exceptions.RequestError: <span class="constructor">RequestError(400, '<span class="params">resource_already_exists_exception</span>', '<span class="params">index</span> [<span class="params">names</span><span class="operator">/</span><span class="params">x</span>-AtvCZ-Q5uL-NB0hNeoFQ] <span class="params">already</span> <span class="params">exists</span>')</span></span><br></pre></td></tr></table></figure>
<p>错误表明，names 这个 Index 已经存在了，不可以重复创建，错误类型为 400，在创建代码中添加 ignore = 400 可以让程序忽略这个报错。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> elasticsearch import Elasticsearch</span><br><span class="line"></span><br><span class="line">es = Elasticsearch()</span><br><span class="line"></span><br><span class="line">result = es.indices.create(<span class="attribute">index</span>=<span class="string">'names'</span>, ignore = 400)</span><br><span class="line"><span class="builtin-name">print</span>(result)</span><br></pre></td></tr></table></figure>
<p>对于一些已知的、可处理的报错可以将其忽略来保证程序的正常运行，但编写程序时，我们是无法保证程序无法出错的，如果程序出现不再预知范围内的错误，最佳的方式就是让其崩溃，而不是隐藏错误，让程序以不正常的状态苟延残喘的运行下去🙅‍♂️。</p>
<h2 id="删除-index"><a class="markdownIt-Anchor" href="#删除-index"></a> 删除 Index</h2>
<p>与创建 Index 类似，代码如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> elasticsearch import Elasticsearch</span><br><span class="line"></span><br><span class="line">es = Elasticsearch()</span><br><span class="line"></span><br><span class="line">result = es.indices.delete(<span class="attribute">index</span>=<span class="string">'names'</span>, ignore=[400, 404])</span><br><span class="line"><span class="builtin-name">print</span>(result)</span><br></pre></td></tr></table></figure>
<p>同样使用了 ignore 参数，来忽略 Index 不存在而删除失败导致程序中断的问题，如果成功删除，会输出如下结果🎉：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">&#123;<span class="symbol">'acknowledged</span>': <span class="literal">True</span>&#125;</span><br></pre></td></tr></table></figure>
<p>如果 Index 已经被删除，再执行删除则会输出如下结果💔：</p>
<figure class="highlight sml"><table><tr><td class="code"><pre><span class="line">&#123;<span class="symbol">'error'</span>: &#123;<span class="symbol">'root_cause'</span>: [&#123;<span class="symbol">'type'</span>: <span class="symbol">'index_not_found_exception'</span>, <span class="symbol">'reason'</span>: <span class="symbol">'no</span> such index', <span class="symbol">'resource</span>.type': <span class="symbol">'index_or_alias'</span>, <span class="symbol">'resource</span>.id': <span class="symbol">'names'</span>, <span class="symbol">'index_uuid'</span>: <span class="symbol">'_na_'</span>, <span class="symbol">'index'</span>: <span class="symbol">'names'</span>&#125;], <span class="symbol">'type'</span>: <span class="symbol">'index_not_found_exception'</span>, <span class="symbol">'reason'</span>: <span class="symbol">'no</span> such index', <span class="symbol">'resource</span>.type': <span class="symbol">'index_or_alias'</span>, <span class="symbol">'resource</span>.id': <span class="symbol">'names'</span>, <span class="symbol">'index_uuid'</span>: <span class="symbol">'_na_'</span>, <span class="symbol">'index'</span>: <span class="symbol">'names'</span>&#125;, <span class="symbol">'status'</span>: <span class="number">404</span>&#125;</span><br></pre></td></tr></table></figure>
<p>结果表明当前 Index 不存在，删除失败，返回的结果同样是 JSON，状态码是 400，但是由于我们添加了 ignore 参数，忽略了 400 状态码，因此程序正常执行输出 JSON 结果，而不是抛出异常。</p>
<h2 id="插入数据"><a class="markdownIt-Anchor" href="#插入数据"></a> 插入数据</h2>
<p>Elasticsearch 可以直接插入结构化字典数据，代码如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> elasticsearch import Elasticsearch</span><br><span class="line"> </span><br><span class="line">es = Elasticsearch()</span><br><span class="line">es.indices.create(<span class="attribute">index</span>=<span class="string">'people'</span>, <span class="attribute">ignore</span>=400)</span><br><span class="line"> </span><br><span class="line">data = &#123;<span class="string">'name'</span>: <span class="string">' 二两'</span>, <span class="string">'age'</span>: <span class="string">'28'</span>&#125;</span><br><span class="line">result = es.create(<span class="attribute">index</span>=<span class="string">'people'</span>, <span class="attribute">doc_type</span>=<span class="string">'politics'</span>, <span class="attribute">id</span>=1, <span class="attribute">body</span>=data)</span><br><span class="line"><span class="builtin-name">print</span>(result)</span><br></pre></td></tr></table></figure>
<p>🙊创建一条数据，包括人名和年龄，然后通过调用 create () 方法插入了这条数据，在调用 create () 方法时，我们传入了四个参数，index 参数代表了索引名称，doc_type 代表了文档类型，body 则代表了文档具体内容，id 则是数据的唯一标识 ID。</p>
<p>运行结果：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">&#123;'_index': 'people', '_type': 'politics', '_id': '1', '_version': <span class="number">1</span>, 'result': 'created', '_shards': &#123;'total': <span class="number">2</span>, 'successful': <span class="number">1</span>, 'failed': <span class="number">0</span>&#125;, '_seq_no': <span class="number">0</span>, '_primary_term': <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>
<p>结果中 result 字段为 created，代表该数据插入成功🎉。</p>
<p>除 create() 方法外还可以使用 index () 方法来插入数据，create () 方法需要我们指定 id 字段来唯一标识该条数据，而 index () 方法则不需要，如果不指定 id，会自动生成一个 id，调用 index () 方法的写法如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">es.index(<span class="attribute">index</span>=<span class="string">'people'</span>, <span class="attribute">doc_type</span>=<span class="string">'politics'</span>, <span class="attribute">body</span>=data)</span><br></pre></td></tr></table></figure>
<h3 id="更新数据"><a class="markdownIt-Anchor" href="#更新数据"></a> 更新数据</h3>
<p>指定数据的 id 和内容，调用 update () 方法即可，但需要注意的是， Elasticsearch 对应的更新 API 对传递数据的格式是有要求的，更新时使用的具体代码如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">es = Elasticsearch()</span><br><span class="line">data = &#123;</span><br><span class="line">   <span class="string">'doc'</span> : &#123;</span><br><span class="line">       <span class="string">'name'</span>: <span class="string">'二两'</span>,</span><br><span class="line">       <span class="string">'age'</span>: <span class="string">'30'</span>,</span><br><span class="line">       <span class="string">'desc'</span>: <span class="string">'Java工程师'</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">result = es.update(<span class="attribute">index</span>=<span class="string">'people'</span>, <span class="attribute">doc_type</span>=<span class="string">'politics'</span>, <span class="attribute">body</span>=data, <span class="attribute">id</span>=1)</span><br><span class="line"><span class="builtin-name">print</span>(result)</span><br></pre></td></tr></table></figure>
<p>这里为数据增加了一个日期字段，然后调用了 update () 方法, update() 其他的数据格式为：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     “ doc ”：&#123;&#125;，</span><br><span class="line">     “<span class="built_in"> script </span>”：&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成功更新后，可以看到如下结果🎉：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">&#123;'_index': 'people', '_type': 'politics', '_id': '1', '_version': <span class="number">2</span>, 'result': 'updated', '_shards': &#123;'total': <span class="number">2</span>, 'successful': <span class="number">1</span>, 'failed': <span class="number">0</span>&#125;, '_seq_no': <span class="number">1</span>, '_primary_term': <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>
<p>result 字段为 updated，即表示更新成功， _version字段，这代表更新后的版本号数，2 代表这是第二个版本，因为之前已经插入过一次数据，所以第一次插入的数据是版本 1。</p>
<p>此外，还可以直接使用 index() 方法来实现更新操作，代码如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">es = Elasticsearch()</span><br><span class="line">data = &#123;</span><br><span class="line">   <span class="string">'name'</span>: <span class="string">'二两'</span>,</span><br><span class="line">   <span class="string">'age'</span>: <span class="string">'29'</span>,</span><br><span class="line">   <span class="string">'desc'</span>: <span class="string">'Python工程师'</span></span><br><span class="line">&#125;</span><br><span class="line">result = es.index(<span class="attribute">index</span>=<span class="string">'people'</span>, <span class="attribute">doc_type</span>=<span class="string">'politics'</span>, <span class="attribute">body</span>=data, <span class="attribute">id</span>=1)</span><br><span class="line"><span class="builtin-name">print</span>(result)</span><br></pre></td></tr></table></figure>
<p>成功后，会返回相同的结果，只是 _version 变为了 3。 index() 方法对格式没有要求。</p>
<h3 id="删除数据"><a class="markdownIt-Anchor" href="#删除数据"></a> 删除数据</h3>
<p>删除数据调用 delete() 方法，指定需要删除的数据 id ，代码如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">es = Elasticsearch()</span><br><span class="line">result = es.delete(<span class="attribute">index</span>=<span class="string">'people'</span>, <span class="attribute">doc_type</span>=<span class="string">'politics'</span>, <span class="attribute">id</span>=1)</span><br><span class="line"><span class="builtin-name">print</span>(result)</span><br></pre></td></tr></table></figure>
<p>成功删除后，输出如下结果🎉：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">&#123;'_index': 'people', '_type': 'politics', '_id': '1', '_version': <span class="number">4</span>, 'result': 'deleted', '_shards': &#123;'total': <span class="number">2</span>, 'successful': <span class="number">1</span>, 'failed': <span class="number">0</span>&#125;, '_seq_no': <span class="number">3</span>, '_primary_term': <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询数据"><a class="markdownIt-Anchor" href="#查询数据"></a> 查询数据</h3>
<p>上面几个操作都非常简单，而 Elasticsearch 最强大的功能是查询功能，这里来使用了 Elasticsearch ，因为中文数据与英文数据不同，英文单词之间天然由空格分割，所以可以直接利用 Elasticsearch 来搜索，而中文数据词与词时相互连接在一起的，所以需要先进行分词，即将中文数据中的词汇分割出来，🙈这里可以使用 elasticsearch-analysis-ik 插件，该插件 Elasticsearch 实现了中文分词🙈，可以使用 elasticsearch-plugin 来安装 Elasticsearch 插件，注意，插件的版本要与 Elasticsearch 主版本对应，这里使用的是 6.8.0 版本，所以安装 6.x 版本的 elasticsearch-analysis-ik 则可。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">.<span class="regexp">/elasticsearch-plugin install https:/</span><span class="regexp">/github.com/m</span>edcl<span class="regexp">/elasticsearch-analysis-ik/</span>releases<span class="regexp">/download/</span>v6.<span class="number">8.0</span><span class="regexp">/elasticsearch-analysis-ik-6.8.0.zip</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>elasticsearch-analysis-ik Github 地址为: <a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik</a> 🤫</p>
</blockquote>
<p>你安装时，请将 6.8.0 替换为自己 Elasticsearch 的版本，然后交给 elasticsearch-plugin 完成下载与安装。</p>
<p>安装完后，需要重启 Elasticsearch ，启动的过程中 Elasticsearch 会自动加载其中的数据。</p>
<p>简单重启方式🌚：</p>
<p>1.找到Elastic进程ID</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ps</span> aux | <span class="keyword">grep</span> elastic | <span class="keyword">grep</span> -v <span class="keyword">grep</span></span><br></pre></td></tr></table></figure>
<p>2.kill</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">kill</span> <span class="number">-9</span> Elastic 进程<span class="keyword">ID</span></span><br></pre></td></tr></table></figure>
<p>3.再次启动</p>
<p>启动后，新建一个索引并指定需要分词的字段，代码如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> elasticsearch import Elasticsearch</span><br><span class="line"></span><br><span class="line">es = Elasticsearch()</span><br><span class="line">mapping = &#123;</span><br><span class="line">    <span class="string">'properties'</span>: &#123;</span><br><span class="line">        <span class="string">'title'</span>: &#123;</span><br><span class="line">            <span class="string">'type'</span>: <span class="string">'text'</span>,</span><br><span class="line">            <span class="string">'analyzer'</span>: <span class="string">'ik_max_word'</span>,</span><br><span class="line">            <span class="string">'search_analyzer'</span>: <span class="string">'ik_max_word'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">es.indices.delete(<span class="attribute">index</span>=<span class="string">'people'</span>, ignore=[400, 404])</span><br><span class="line">es.indices.create(<span class="attribute">index</span>=<span class="string">'news'</span>, <span class="attribute">ignore</span>=400)</span><br><span class="line">result = es.indices.put_mapping(<span class="attribute">index</span>=<span class="string">'news'</span>, <span class="attribute">doc_type</span>=<span class="string">'politics'</span>, <span class="attribute">body</span>=mapping)</span><br><span class="line"><span class="builtin-name">print</span>(result)</span><br></pre></td></tr></table></figure>
<p>上述代码中，先将之前名为 people 的索引删除，然后新建了名为 news 的索引，然后更新了它的 mapping 信息， mapping 信息中指定了分词的字段，🌝其中将 title 字段的类型 type 指定为 text，并将分词器 analyzer 和搜索分词器 search_analyzer 设置为 ik_max_word ，即使用刚刚安装的中文分词插件，如果不指定，则默认使用英文分词器🙅‍♂️。</p>
<p>接着，插入一些数据，代码如下：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">def test2():</span><br><span class="line">    datas = [</span><br><span class="line">        &#123;</span><br><span class="line">            'title': '设计灵魂离职，走下神坛的苹果设计将去向何方？',</span><br><span class="line">            'url': 'https://www.tmtpost.com/<span class="number">403339</span>7.html',</span><br><span class="line">            'date': '<span class="number">2019-06-29</span> 11:30'</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            'title': '医生中的建筑设计师，凭什么挽救了上万人的生命？',</span><br><span class="line">            'url': 'https://www.tmtpost.com/<span class="number">403405</span>2.html',</span><br><span class="line">            'date': '<span class="number">2019-06-29</span> 11:10'</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            'title': '中国网红二十年：从痞子蔡、芙蓉姐姐到李佳琦，流量与变现的博弈',</span><br><span class="line">            'url': 'https://www.tmtpost.com/<span class="number">403404</span>5.html',</span><br><span class="line">            'date': '<span class="number">2019-06-29</span> 11:03'</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            'title': '网易云音乐、喜马拉雅等音频类应用被下架，或因违反相关规定',</span><br><span class="line">            'url': 'https://www.tmtpost.com/nictation/<span class="number">403404</span>0.html',</span><br><span class="line">            'date': '<span class="number">2019-06-29</span> 10:07'</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    for data in datas:</span><br><span class="line">        es.index(index='news', doc_type='politics', body=data)</span><br></pre></td></tr></table></figure>
<p>可以将插入的内容查询打印出来看看：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">result = es.search(<span class="attribute">index</span>=<span class="string">'news'</span>, <span class="attribute">doc_type</span>=<span class="string">'politics'</span>)</span><br><span class="line"><span class="builtin-name">print</span>(json.dumps(result, <span class="attribute">indent</span>=4, <span class="attribute">ensure_ascii</span>=<span class="literal">False</span>))</span><br></pre></td></tr></table></figure>
<p>输出结果如下🎉：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"took"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">        <span class="attr">"total"</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">"successful"</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">"skipped"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"hits"</span>: &#123;</span><br><span class="line">        <span class="attr">"total"</span>: <span class="number">4</span>,</span><br><span class="line">        <span class="attr">"max_score"</span>: <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">"hits"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"_index"</span>: <span class="string">"news"</span>,</span><br><span class="line">                <span class="attr">"_type"</span>: <span class="string">"politics"</span>,</span><br><span class="line">                <span class="attr">"_id"</span>: <span class="string">"MclZoWsB7N68fyc5DUS7"</span>,</span><br><span class="line">                <span class="attr">"_score"</span>: <span class="number">1.0</span>,</span><br><span class="line">                <span class="attr">"_source"</span>: &#123;</span><br><span class="line">                    <span class="attr">"title"</span>: <span class="string">"网易云音乐、喜马拉雅等音频类应用被下架，或因违反相关规定"</span>,</span><br><span class="line">                    <span class="attr">"url"</span>: <span class="string">"https://www.tmtpost.com/nictation/4034040.html"</span>,</span><br><span class="line">                    <span class="attr">"date"</span>: <span class="string">"2019-06-29 10:07"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>返回结果会出现在 hits 字段里面，其中有 total 字段标明了查询的结果条目数， max_score 代表了最大匹配分数。</p>
<p>我们还可以进行全文检索，这才是 Elasticsearch 搜索引擎的特性🥊：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">dsl = &#123;</span><br><span class="line">        <span class="string">'query'</span>: &#123;</span><br><span class="line">            <span class="string">'match'</span>: &#123;</span><br><span class="line">                <span class="string">'title'</span>: <span class="string">'网红 设计师'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">es = Elasticsearch()</span><br><span class="line">result = es.search(<span class="attribute">index</span>=<span class="string">'news'</span>, <span class="attribute">doc_type</span>=<span class="string">'politics'</span>, <span class="attribute">body</span>=dsl)</span><br><span class="line"><span class="builtin-name">print</span>(json.dumps(result, <span class="attribute">indent</span>=2, <span class="attribute">ensure_ascii</span>=<span class="literal">False</span>))</span><br></pre></td></tr></table></figure>
<p>Elasticsearch 支持的 DSL 语句来进行查询，使用 match 指定全文检索，检索的字段是 title，内容是 “网红 设计师”，搜索结果如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"took"</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"skipped"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"hits"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"max_score"</span>: <span class="number">2.2950945</span>,</span><br><span class="line">    <span class="attr">"hits"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span>: <span class="string">"news"</span>,</span><br><span class="line">        <span class="attr">"_type"</span>: <span class="string">"politics"</span>,</span><br><span class="line">        <span class="attr">"_id"</span>: <span class="string">"L8lZoWsB7N68fyc5DUSx"</span>,</span><br><span class="line">        <span class="attr">"_score"</span>: <span class="number">2.2950945</span>,</span><br><span class="line">        <span class="attr">"_source"</span>: &#123;</span><br><span class="line">          <span class="attr">"title"</span>: <span class="string">"医生中的建筑设计师，凭什么挽救了上万人的生命？"</span>,</span><br><span class="line">          <span class="attr">"url"</span>: <span class="string">"https://www.tmtpost.com/4034052.html"</span>,</span><br><span class="line">          <span class="attr">"date"</span>: <span class="string">"2019-06-29 11:10"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span>: <span class="string">"news"</span>,</span><br><span class="line">        <span class="attr">"_type"</span>: <span class="string">"politics"</span>,</span><br><span class="line">        <span class="attr">"_id"</span>: <span class="string">"MMlZoWsB7N68fyc5DUS2"</span>,</span><br><span class="line">        <span class="attr">"_score"</span>: <span class="number">1.8132976</span>,</span><br><span class="line">        <span class="attr">"_source"</span>: &#123;</span><br><span class="line">          <span class="attr">"title"</span>: <span class="string">"中国网红二十年：从痞子蔡、芙蓉姐姐到李佳琦，流量与变现的博弈"</span>,</span><br><span class="line">          <span class="attr">"url"</span>: <span class="string">"https://www.tmtpost.com/4034045.html"</span>,</span><br><span class="line">          <span class="attr">"date"</span>: <span class="string">"2019-06-29 11:03"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span>: <span class="string">"news"</span>,</span><br><span class="line">        <span class="attr">"_type"</span>: <span class="string">"politics"</span>,</span><br><span class="line">        <span class="attr">"_id"</span>: <span class="string">"LslZoWsB7N68fyc5DEQC"</span>,</span><br><span class="line">        <span class="attr">"_score"</span>: <span class="number">0.71580166</span>,</span><br><span class="line">        <span class="attr">"_source"</span>: &#123;</span><br><span class="line">          <span class="attr">"title"</span>: <span class="string">"设计灵魂离职，走下神坛的苹果设计将去向何方？"</span>,</span><br><span class="line">          <span class="attr">"url"</span>: <span class="string">"https://www.tmtpost.com/4033397.html"</span>,</span><br><span class="line">          <span class="attr">"date"</span>: <span class="string">"2019-06-29 11:30"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匹配的结果有两条，第一条的分数为 2.29，第二条的分数为 1.81，即查询“网红 设计师”时， Elasticsearch 认为第一个结果权重更高。从该检索结果可以看出，检索时会对对应的字段全文检索，结果还会按照检索关键词的相关性进行排序，这已经是一个搜索引擎的雏形了🙉。</p>
<blockquote>
<p>Elasticsearch 还支持非常多的查询方式:<br />
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.3/query-dsl.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/6.3/query-dsl.html</a> 🤫</p>
</blockquote>
<h2 id="进一步学习"><a class="markdownIt-Anchor" href="#进一步学习"></a> 进一步学习</h2>
<p>🤓1.Elasticsearch 权威指南：<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html</a><br />
🤓2.Elastic 中文社区：<a href="https://www.elasticsearch.cn/" target="_blank" rel="noopener">https://www.elasticsearch.cn/</a></p>
<h2 id="结尾"><a class="markdownIt-Anchor" href="#结尾"></a> 结尾</h2>
<p>Elasticsearch 简单使用就介绍到这里，Elasticsearch 本身具有一定的复杂性，简单几篇文章只能让大家对其有个基本的理解，后续还会以[课外知识]的方式分享更多 Elasticsearch 方面的内容，最后欢迎学习 HackPython 的教学课程并感觉您的阅读与支持。</p>
]]></content>
      <tags>
        <tag>Python,进阶库</tag>
      </tags>
  </entry>
  <entry>
    <title>Python进阶必学库：elasticsearch-py使用详解(上篇)</title>
    <url>/blog/2019/06/28/Python%E8%BF%9B%E9%98%B6%E5%BF%85%E5%AD%A6%E5%BA%93%EF%BC%9Aelasticsearch-py%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3-%E4%B8%8A%E7%AF%87/</url>
    <content><![CDATA[<blockquote>
<p>HackPython致力于有趣有价值的编程教学</p>
</blockquote>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>当爬虫爬取了很多数据后，如何全面的了解爬取数据的特征？这就需要对数据进行搜索了，传统通过 SQL 方式进行搜索，在数据量较大时，效率并不佳，此时 Elasticsearch 就是首选，它是一个开源的搜索引擎，建立在全文搜索引擎库 Apache Lucene 的基础上，而 Lucene 是当前无论开源还是私有的搜索引擎中最先进、高性能与全功能的搜索引擎之一，但 Lucene 使用比较复杂，而 Elasticesarch 在 Luncene 基础上进行了封装并提供了一套简单的 RESTful API ，而 elasticsearch-py 则是在这套 API 上的封装，让我们可以在 Python 项目中直接使用 Elasticsearh。</p>
<p>Elasticsearch 的准确形容：</p>
<p>一个分布式的实时文档存储系统，每个字段可以被索引与搜索<br />
一个分布式实时分析搜索引擎<br />
可以在上百个服务节点扩展，并支持 PB 级别的结构化或非结构化数据搜索</p>
<h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2>
<p>可以到 Elasticsearch 的官方网站下载 Elasticsearch 下载不同平台的安装包：</p>
<p><a href="https://www.elastic.co/downloads/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/downloads/elasticsearch</a></p>
<p>具体安装步骤可以参考官网提供的内容或自行搜索，在 Mac 上可以直接使用 brew 安装。</p>
<p>因为 Elasticsearch 是基于 Java 开发的，所有系统中需要预先安装 Java JDK，在 Mac 中同样可使用 brew 安装。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 JDK</span></span><br><span class="line">brew cask <span class="keyword">install</span> homebrew/cask-<span class="keyword">versions</span>/adoptopenjdk8</span><br><span class="line"><span class="comment"># 安装 Elasticsearch</span></span><br><span class="line">brew <span class="keyword">install</span> elasticsearch</span><br></pre></td></tr></table></figure>
<p>Mac 下通过 brew 安装完后，可以进入 <code>/usr/local/Cellar/elasticsearch/6.8.0/bin</code> 运行 elasticsearch 。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cd <span class="regexp">/usr/</span>local<span class="regexp">/Cellar/</span>elasticsearch<span class="regexp">/6.8.0/</span>bin &amp;&amp; .<span class="regexp">/elasticsearch</span></span><br></pre></td></tr></table></figure>
<p>如果想将 Elasticsearh 作为守护进程在后台运行，需要加上 -d 参数。</p>
<p>如果你是在 Windows 上面运行 Elasticseach，你应该运行 bin\elasticsearch.bat 而不是 bin\elasticsearch 。</p>
<p>正常启动后，访问 <code>localhost:9200</code> 可看到如下信息：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">curl <span class="string">localhost:</span><span class="number">9200</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span> : <span class="string">"sbUPsxx"</span>,</span><br><span class="line">  <span class="string">"cluster_name"</span> : <span class="string">"elasticsearch_ayuliao"</span>,</span><br><span class="line">  <span class="string">"cluster_uuid"</span> : <span class="string">"Bv83QVa4QMOJti9Yn1RJsw"</span>,</span><br><span class="line">  <span class="string">"version"</span> : &#123;</span><br><span class="line">    <span class="string">"number"</span> : <span class="string">"6.8.0"</span>,</span><br><span class="line">    <span class="string">"build_flavor"</span> : <span class="string">"oss"</span>,</span><br><span class="line">    <span class="string">"build_type"</span> : <span class="string">"tar"</span>,</span><br><span class="line">    <span class="string">"build_hash"</span> : <span class="string">"65b6179"</span>,</span><br><span class="line">    <span class="string">"build_date"</span> : <span class="string">"2019-05-15T20:06:13.172855Z"</span>,</span><br><span class="line">    <span class="string">"build_snapshot"</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"lucene_version"</span> : <span class="string">"7.7.0"</span>,</span><br><span class="line">    <span class="string">"minimum_wire_compatibility_version"</span> : <span class="string">"5.6.0"</span>,</span><br><span class="line">    <span class="string">"minimum_index_compatibility_version"</span> : <span class="string">"5.0.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"tagline"</span> : <span class="string">"You Know, for Search"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述信息中，可知我们安装的是 6.8.0 版本的 elasticsearch，版本很重要，因为只有安装了对应主版本的 elasticsearch-py 才能在 python 中正常使用 elasticsearch。</p>
<p>对于Elasticsearch 6.0及更高版本，请使用库的主要版本 6（6.x.y）。<br />
对于Elasticsearch 5.0及更高版本，请使用库的主要版本 5（5.x.y）。<br />
对于Elasticsearch 2.0及更高版本，请使用库的主要版本 2（2.x.y），依此类推。</p>
<p>在setup.py或 requirements.txt 中设置需求的推荐方法是：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"># Elasticsearch <span class="number">6.</span>x</span><br><span class="line">elasticsearch&gt;=<span class="number">6.0</span><span class="number">.0</span>,&lt;<span class="number">7.0</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line"># Elasticsearch <span class="number">5.</span>x</span><br><span class="line">elasticsearch&gt;=<span class="number">5.0</span><span class="number">.0</span>,&lt;<span class="number">6.0</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line"># Elasticsearch <span class="number">2.</span>x</span><br><span class="line">elasticsearch&gt;=<span class="number">2.0</span><span class="number">.0</span>,&lt;<span class="number">3.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<p>通过 pip 安装一下</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">pip install elasticsearch==<span class="number">6.4</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<h2 id="关键概念"><a class="markdownIt-Anchor" href="#关键概念"></a> 关键概念</h2>
<p>Elasticsearch 是面向文档的，意味着它存储整个对象或文档。Elasticsearch 不仅存储文档，而且索引每个文档的内容使之可以被检索。在 Elasticsearch 中，你对文档进行索引、检索、排序和过滤 – 而不是对行列数据。这是一种完全不同的思考数据的方式，也是 Elasticsearch 能支持复杂全文检索的原因。</p>
<p>下面简单介绍其中几个关键的概念：</p>
<p>节点 (Node) 与集群 (Cluster)</p>
<p>Elasticsearch 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elasticsearch 实例。</p>
<p>单个 Elasticsearch 实例称为一个节点（node），一组节点构成一个集群（cluster），而一个 集群 是一组拥有相同 <a href="http://cluster.name" target="_blank" rel="noopener">cluster.name</a> 的节点， 他们能一起工作并共享数据，还提供容错与可伸缩性。</p>
<p>索引 (Index)</p>
<p>Elasticsearch 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。</p>
<p>Elasticsearch 数据管理的顶层单位就叫做 Index（索引），每个 Index 的名称必须是全小写形式的。</p>
<p>文档 (Document)</p>
<p>Index 中单条记录称为文档 (Document)，许多条 Document 构成了一个 Index。Document 使用 JSON 格式表示，例子如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"张三"</span>,</span><br><span class="line">    <span class="attr">"age"</span>: <span class="number">28</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。</p>
<p>Type</p>
<p>Document 可以分组，比如 weather 这个 Index 里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document。但 Elasticsearch 在 7.x 之后的版本中逐渐移除 Type，为了提升搜索速度。</p>
<p>字段 (Fields)</p>
<p>每个 Document 都是一个 JSON 结构，它包含了许多字段，每个字段都有其对应的值，多个字段组成了一个 Document。</p>
<h2 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h2>
<p>很多人将 Elsticsearch 中的 index 理解为关系数据中的 database，而将 type 理解为数据库中的一个数据表，虽然表面上看两者确实存在相似性，但却是错误的类比。</p>
<p>我们都知道 Elasticsearch 是基于 Lucene 开发的，而 Elasticsearch 中不同 type 下名称相同的 filed 最终在 Lucene 中的处理方式是一样的。举个例子，两个不同 type 下的两个 user_name，在 Elasticsearch 同一个索引下其实被认为是同一个 filed，你必须在两个不同的 type 中定义相同的 filed 映射。否则，不同 type 中的相同字段名称就会在处理中出现冲突的情况，导致 Lucene 处理效率下降。</p>
<h2 id="结尾"><a class="markdownIt-Anchor" href="#结尾"></a> 结尾</h2>
<p>具体如何使用 Elsaticsearch 与 Elasticsearch-py 留到下一篇再详解，最后欢迎学习 HackPython 的教学课程并感觉您的阅读与支持。</p>
]]></content>
      <tags>
        <tag>Python,进阶库</tag>
      </tags>
  </entry>
  <entry>
    <title>Python进阶必学库：Pyinstaller使用详解</title>
    <url>/blog/2019/06/28/Python%E8%BF%9B%E9%98%B6%E5%BF%85%E5%AD%A6%E5%BA%93%EF%BC%9APyinstaller%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>HackPython致力于有趣有价值的编程教学</p>
</blockquote>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>当我们希望将自己编写好的程序传送给他人使用时，如果对方没有安装 Python 环境就无法使用程序了，我们难以让每个使用者都安装 Python 环境，是否可以在不必安装 Python 环境的前提下使用Python程序呢？</p>
<p>可以使用 Pyinstaller 将程序打包，然后再分享给其他人使用，他人使用只需双击运行打包好的程序。</p>
<p>可以通过 pip 来安装，命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> pyinstaller</span><br></pre></td></tr></table></figure>
<h2 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h2>
<p>pyinstaller 最重要的两个参数就是 -F 与 -D 参数。</p>
<p>使用-F参数， pyinstaller 会将 python 程序打包成单个可执行文件。</p>
<p>使用-D参数， pyinstaller 会将 python 程序打包成一个文件夹，运行程序时，需要进入该文件夹，点击运行相应的可执行程序。</p>
<p>为了美观，还可以通过-i参数指定打包程序的图标(icon)，但这个命令只能在 Windows 平台下生效，此外还可以使用-n参数指定生成打包文件的名称。</p>
<p>如果你使用了 PyQt5 或 tkinter 开发了界面，通常不会希望程序运行时弹出 cmd 命令行，此时就可以使用-w参数。</p>
<p>简单总结一下：</p>
<p>-F：打包 Python 程序为单个可执行文件<br />
-D：打包 Python 程序为一个文件夹<br />
-i：生成图标，只适用于 Windows 平台<br />
-n：指定打包后生成文件的名称<br />
-w：禁止命令行弹出</p>
<p>综上所述，最常见的命令为：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">pyinstaller</span> <span class="selector-tag">-i</span> <span class="selector-tag">xxx</span><span class="selector-class">.ico</span> <span class="selector-tag">-n</span> <span class="selector-tag">xxx</span> <span class="selector-tag">-w</span> <span class="selector-tag">-D</span> <span class="selector-tag">xxx</span><span class="selector-class">.py</span></span><br></pre></td></tr></table></figure>
<p>-i 参数后必须接 .ico 结尾的图标文件<br />
-D 或 -F 后必须接 python 程序的入库程序，常见情况为 <a href="http://main.py" target="_blank" rel="noopener">main.py</a></p>
<p>对应依赖比较多的程序，建议使用 -D， -F 更适合单文件的 py 脚本。</p>
<h2 id="简单原理"><a class="markdownIt-Anchor" href="#简单原理"></a> 简单原理</h2>
<p>打包时，pyinstaller此时会生成相应的spec文件，大体流程如下：</p>
<p>1、在脚本目录生成 xxx.spec 文件(取决于 -n 参数，没传，则与 <a href="http://xxx.py" target="_blank" rel="noopener">xxx.py</a> 同名为 xxx )；<br />
2、创建一个 build 目录；<br />
3、写入一些日志文件和中间流程文件到 build 目录；<br />
4、创建 dist 目录；<br />
5、生成可执行文件或文件夹到 dist 目录；</p>
<p><img src="https://raw.githubusercontent.com/ayuLiao/images/master/20190514155505.png" alt="" /></p>
<p>此时，进入 dist 目录就可以看见自己的打包文件了。</p>
<p><img src="media/15578194904208/15578205835319.jpg" alt="" /></p>
<p>双击 nameauto.exe 文件，效果如下：</p>
<p>效果如下：<br />
<img src="media/15578194904208/15578205987182.jpg" alt="" /></p>
<p>这是一个利用 tkinter 构建的程序。</p>
<h2 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h2>
<p>Pyinstaller 是跨平台的，但并不是指其生成应用是跨平台的，而是 Pyinstaller 本身是跨平台的，在 Windows 平台下，可以打包出 exe 文件。</p>
<p>避免打包后，包文件过大</p>
<p>为了避免 Pyinstaller 打包后程序或文件夹过大，如：几百 KB 的程序打包后编程 500M 左右的程序，在引用包时，尽量使用 from … import … 语句，这是因为 Pyinstaller 打包的路径其实是将 python 解释器以及项目中使用的库直接复制过来，所以如果你没事就别 import… ，那么 Pyinstaller 会将整个模块复制过去，此时打出来的包就会很大。</p>
<p>考虑路径问题</p>
<p>使用 python 时，要养成使用 os.path.join 的习惯，这不仅可以避免跨平台的路径坑( windows 路径表达与类 Unix 是不同)，又可以在打包时不会出现相对路径的问题，很多 python 程序员编写路径喜欢使用 + 号来链接路径，这会增加项目的维护成本</p>
<p>pyinstaller 打包的项目遇到路径都使用 os.path.join 则可</p>
<p>外部数据问题</p>
<p>虽然在上节中，提及了使用外部数据时，可以自定义 spec 文件中的 datas 字段，但我更常用的做法是直接将数据复制过去，不去修改datas。</p>
<p>比如我的项目中依赖 config 文件夹下的配置文件，执行将 config 文件夹整体直接复制到打包好的文件夹中则可</p>
<p>闪屏结束</p>
<p>如果是简单的程序，可能会出现运行可执行程序后出现一闪而过的情况，这种情况下要么是程序运行结束（比如直接打印的 helloWorld），要么程序出现错误退出了。</p>
<p>这种情况要么通过 input() 函数捕捉输入自己主动结束程序，要么就在 cmd 下运行 exe 文件，从而通过 cmd 看到效果</p>
<h2 id="结尾"><a class="markdownIt-Anchor" href="#结尾"></a> 结尾</h2>
<p>掌握了 Pyinstaller 后，你就可以将任意程序打包发送给他人了，最后欢迎学习 HackPython 的教学课程并感觉您的阅读与支持。</p>
]]></content>
      <tags>
        <tag>Python,进阶库</tag>
      </tags>
  </entry>
</search>
